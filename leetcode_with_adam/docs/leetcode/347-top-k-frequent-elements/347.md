# Approach 1 Naive Solution


自己想出来的naive解，O(nlogn) in time, O(n) in space.

```python
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        # hashmap to record: 
        #      val:occurence
        # O(n*logn) in time, O(n) in space
        hashtable = collections.defaultdict(int)
        for num in nums:
            hashtable[num] += 1
        
        sorted_hashtable = sorted(hashtable,key=lambda x:hashtable[x],reverse = True)

        return sorted_hashtable[:k]
```


# Approach 2 Using a trick

Neetcode的解法 O(n) in time, O(n) in space. 比较巧妙是，用了bucket sort的思想，把频率作为index，然后把频率相同的元素放在一个list里面。这样就可以直接从高频率开始取元素了. 和2-sum的思路对比如下,

![](assets/1.excalidraw.png)

算法复杂度有点搞脑子，假设你的input array is size n. 那么每种元素最多出现n次，所以最多有n种不同的频率。所以最多有n个bucket。所以最多有n个list. 但这n个list里，一共有的elements数量也为n个，每一个都visit一遍。所以总的时间复杂度为O(n).

!!! note Note
    bucket sort一样的前提是要先知道频率的范围。所以这个解法的前提是要先知道频率的范围。

下面的例子用了list of list的方式，但是其实用defaultdict也是可以的。
```python
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        # bucket sort, O(n) in time, O(n) in space

        # cost O(n) time 
        hashtable = collections.defaultdict(int)
        for num in nums:
            hashtable[num] += 1
        # cost O(n) space
        freq = [[] for _ in range(len(nums)+1)]

        # cost O(n) time
        for num,count in hashtable.items():
            freq[count].append(num)
        
        # cost O(n), since we gonna have x vals, where x == len(nums)
        res = []
        for count in range(len(freq)-1, 0, -1):
            # on average, we have O(1) time to get the value
            # 平均下来每个frequency一个元素
            for val in freq[count]:
                res.append(val)                
                if len(res) == k:
                    return res
```

下面是用defaultdict的例子
```python
from collections import defaultdict
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        hashmap = defaultdict(int)
        for num in nums:
            hashmap[num] += 1

        bucket = defaultdict(list)
        for val,freq in hashmap.items():
            bucket[freq].append(val)

        # traverse from len(nums) to 1
        res = []
        for freq in range(len(nums), 0, -1):
            for n in bucket[freq]:
                res.append(n)
                if len(res) == k:
                    return res            
```
