{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Leetcode With Adam!","text":"<p>One in tech industry, especially those who want to get in FANG, have to grind Leetcode. I have been struggling with too until i decide to to \"play\" Leetcode instead of grinding them. I will be sharing my journey here, and hope you can find something useful.</p>"},{"location":"#why-leetcode","title":"Why Leetcode?","text":"<p>There are a couple of reasons why FANG-like companies use Leetcode as their interview process:</p> <ul> <li>Google HR analytics department find out a positive pearson correlation between interview Leetcode performance and job performance. Those traditional IQ tests and brain teasers during interview show no such correlation at all.</li> <li>FANG company is huge and have different teams using internal tools. It's hard to standardize the interview process as some team have preference of certain stack over another. The interview process might be skewed. Leetcode is a good way to standardize the process with the price of extra grind for the interviewee. They hire general DSA skills, and can afford to train you on the job.</li> </ul>"},{"location":"#interview-rubrics","title":"Interview Rubrics","text":"<p>Anything could be quantified to some extend so does interview process. The interview rubrics for FANG-like companies are pretty standard. </p> <p>Tip</p> <p>Number 1 to ace the interview is to dance the interview dance.</p> <p>One rubric they use could serve as a basis to understand what's important and how you Leetcode. 15 points metrics with</p> <ul> <li>3 for asking questions, discussing edge cases and planning out ur solution</li> <li>3 for communication</li> <li>3 for getting a working solution</li> <li>3 for time/space complexity analysis</li> <li>3 for code quality and cleanness</li> </ul> <p>To score better during the rubrics, if you only have 20 minutes, you should following the following steps:</p> <ul> <li><code>Understand:</code> 5 mins for understanding questions, asking clarifying questions, discuss edge cases and planning out your solution</li> <li><code>Plan:</code> 5 mins for dry run of your solution, with example.</li> <li><code>Execute:</code> 5 mins for coding</li> <li><code>Discuss:</code> 5 mins for discussing potential optimal solution</li> </ul> <p>Now, when you leetcode and practice, you should also follow the structures.</p>"},{"location":"#roadmap","title":"Roadmap","text":"<p>Stage 1</p> <ul> <li>[x] complexity analysis</li> <li>[ ] linked list</li> <li>[x] stack</li> <li>[x] queue</li> <li>[ ] recursion</li> <li>[x] enumeration</li> <li>[ ] sorting</li> <li>[ ] binary search</li> </ul> <p>Stage 2</p> <ul> <li>[ ] hashmap</li> <li>[ ] binary tree</li> <li>[x] heap</li> <li>[ ] BF and RK string pattern matching</li> <li>[ ] Trie</li> <li>[ ] DFS and BFS graph traversal</li> </ul> <p>Stage 3</p> <ul> <li>[ ] \u8df3\u8868</li> <li>[ ] topological sort</li> <li>[ ] Dijkstra</li> <li>[ ] A*</li> <li>[ ] B+ tree</li> </ul> <p>Stage 4</p> <ul> <li>[ ] \u4f4d\u56fe</li> <li>[ ] BM</li> <li>[ ] KMP</li> <li>[ ] AC\u81ea\u52a8\u673a</li> <li>[ ] \u54c8\u5e0c\u7b97\u6cd5</li> </ul>"},{"location":"#leetcode-idols","title":"Leetcode Idols","text":"<p>There are some Leetcode and CP idols that i admire and learn from.</p>"},{"location":"#reference","title":"Reference","text":"<ul> <li>\u8fd9\u4e2a\u4eba\u4e5f\u7528\u4e86mkdoc for LC\u6a21\u7248\uff0c\u975e\u5e38\u6f02\u4eae</li> <li>OI Wiki \u4e0d\u7528\u8bf4\u4e86\u5427\uff0c\u4fe1\u606f\u5b66\u5965\u8d5b\u7684wiki, \u4e5f\u662f\u7528\u7684mkdoc</li> <li>\u843d\u8c37\u5237\u9898</li> <li>https://leetcode.com/discuss/general-discussion/1000929/solved-all-dynamic-programming-dp-problems-in-7-months</li> <li>\u6b8b\u9177\u5237\u9898\u7fa4, Huifeng Guan</li> <li>bucket and double bucket</li> <li>\u5317\u822a\u8f6f\u9662\u7684\u4eba\u5199\u7684LC\u901a\u5173\u624b\u518c</li> </ul>"},{"location":"algorithm/","title":"DSA","text":"<p>The study of DSA is painful for most of the people, including me. As long as it's still going to be a part of the interview process, We have to keep learning it. You can think of it as a game, and you are trying to get better at it.</p> <p>Note</p> <p>This is still a work in progress</p>"},{"location":"algorithm/#reference","title":"Reference","text":"<ul> <li>reddit post, why the solution works and gitbook here (\u7406\u89e3\u601d\u8def\u975e\u5e38\u4e0d\u9519)</li> </ul>"},{"location":"algorithm/binary_search/","title":"Binary Search Template","text":"<p>Binary search, \u672c\u8eab\u7684\u601d\u8def\u5e76\u4e0d\u96be\uff0c\u96be\u5c31\u96be\u5728</p> <ul> <li>should we use <code>while left &lt;= right</code> or <code>while left &lt; right</code>?</li> <li>should we update left pointers as <code>left = mid</code> or <code>left = mid + 1</code>?</li> <li>do we return <code>left</code> or <code>left - 1</code></li> </ul> <p>binary search\u53ef\u4ee5\u6709\u591a\u79cd\u5199\u6cd5\uff0c\u5982\u679c\u6bcf\u6b21\u90fd\u5199\u7684\u4e0d\u4e00\u6837\uff0c\u5c31\u4f1a\u9020\u6210\u5bf9\u4e8e\u7ed3\u675f\u6761\u4ef6\uff0c\u6307\u9488\u53d8\u5316\u7684\u6df7\u4e71\uff0c\u6240\u4ee5\u6211\u4eec\u8981\u627e\u5230\u4e00\u79cd\u56fa\u5b9a\u7684\u6a21\u677f\uff0c\u901a\u8fc7\u4fee\u6539\u6a21\u677f\u6765\u89e3\u51b3\u9898\u76ee. </p>"},{"location":"algorithm/binary_search/#templates","title":"Templates","text":"<p>\u6709\u5f88\u591a\u5927\u795e\u7684\u7ecf\u9a8c\uff0c\u603b\u7ed3\u51fa\u6765\u4e86\u5f88\u591a\u6a21\u7248\u3002\u8fd9\u91cc\u6211\u4eec\u6839\u636e\u4e00\u4e9b\u7ecf\u5178binary search\u9898\u76ee\u4f5c\u4e3ametrics, \u6765\u8bc4\u4ef7\u4e00\u4e0b\u8fd9\u4e2a\u6a21\u7248\u7684general\u6027.</p>"},{"location":"algorithm/binary_search/#template-1-comment-from-lc","title":"Template 1: Comment from LC","text":"<p>\u8fd9\u4e2atemplate\u662f704 binary search\u7684editorial\u4e0b\u9762\u56de\u590d\u533a\u63d0\u4f9b\u7684\u6a21\u7248.</p> <pre><code>def search(self, nums: List[int], target: int) -&gt; int:\n    lo, hi = 0, len(nums) - 1\n    while lo &lt; hi:\n        mid = (lo + hi) // 2\n        if nums[mid] &gt;= target:\n            hi = mid\n        else:\n            lo = mid + 1\n\n    if nums[lo] == target:\n        return lo\n    else:\n        return -1\n</code></pre>"},{"location":"algorithm/binary_search/#reference","title":"Reference","text":"<ul> <li>\u4e00\u4e2a\u5927\u795e\u7684gitbook, \u4e5d\u7ae0\u7b97\u6cd5\u63d0\u4f9b\u7684\u6a21\u7248</li> <li>\u5730\u91cc\u603b\u7ed3binary search, \u8bc4\u8bba\u533a\u5927\u4f6c\u5389\u5bb3</li> <li>LC\u7684\u9ad8\u8d5epost</li> <li>Topcoder blog, \u6309\u7167\u79bb\u6563\uff0c\u5b9e\u6570\u96c6\u8fdb\u884c\u5206\u7c7b\u5f88\u7406\u89e3\uff0c\u96be\u5ea6\u9ad8\uff0c\u4f46\u7cfb\u7edf</li> </ul>"},{"location":"algorithm/bit_manipulation/","title":"Bit Manipulation","text":"<p>In this section, we will try to understand the following:</p> <ul> <li>base, conversion between bases</li> <li>representing integers (optional)</li> <li>bit operators</li> </ul> <p>\u8fd9\u4e00\u7ae0\u7ed3\u675f\u4e4b\u540e\uff0c\u4f60\u53ef\u4ee5\u56de\u7b54, </p> <ul> <li>how to convert between base 10 to base Y (Y can be 2, 8, 16 etc)?</li> </ul>"},{"location":"algorithm/bit_manipulation/#1-base","title":"1. Base","text":"<p>Base\u4e5f\u5c31\u662f\u6211\u4eec\u719f\u6089\u76842\u8fdb\u5236\uff0c8\u8fdb\u5236\uff0c16\u8fdb\u5236\u7b49\u7b49\u3002\u8fd9\u4e9b\u90fd\u662fbase\u3002\u662f\u4e00\u79cd\u8868\u8fbe\u6570\u5b57\u7684\u65b9\u5f0f\u65b9\u6cd5\uff0c\u6211\u4eec\u4eba\u7c7b\u6700\u719f\u6089\u7684\u662f\u5341\u8fdb\u5236, </p> <p>\u5148\u6765\u770b\u4e24\u4e2a\u4f8b\u5b50123.45 in base 10,</p> \\[ 123.45 = 1*10^2 + 2*10^1 + 3*10^0 + 4*10^{-1} + 5*10^{-2} \\] <p>\u518d\u6765\u770b<code>base-8</code>\u8f6c\u6362\u5230base 10\uff0c </p> \\[ 720.5_{\\left(8\\right)} = 7*8^2 + 2*8^1 + 0*8^0 + 5*8^{-1} = 464.625_{\\left(10\\right)} \\] <p>\u770b\u5b8c\u8fd9\u4e24\u4e2a\u4f8b\u5b50\u540e\uff0c\u6211\u4eec\u6765\u5bf9\u5e94weight\u5728base\u4e2d\u7684\u610f\u4e49\uff0c123.45\u7684weights\u4e3a</p> <ul> <li>\u5c0f\u6570\u70b9\u540e\u6709\u4e24\u4f4d, \\(10^{-1}\\) and \\(10^{-2}\\).</li> <li>\u5c0f\u6570\u70b9\u524d\u6709\u4e09\u4f4d, \\(10^0\\), \\(10^1\\), and \\(10^2\\).</li> </ul> <p>\u7531\u8fd9\u4e9bweights\u5c31\u80fd\u7ec4\u6210\u6570\u5b57.</p>"},{"location":"algorithm/bit_manipulation/#11-conversion-between-bases","title":"1.1 Conversion Between Bases","text":"<p>\u4eba\u7c7b\u5341\u8fdb\u5236\uff0c\u8ba1\u7b97\u673a\u4e8c\u8fdb\u5236\uff0c\u516b\u8fdb\u5236(octal)\uff0c\u5341\u516d\u8fdb\u5236(hexadecimal)\u3002\u8fd9\u4e9b\u90fd\u662f\u5e38\u7528\u7684base. \u6bd4\u5982\u5341\u8fdb\u5236\u8f6c\u5316\u5230\u4e8c\u8fdb\u5236, 50 in base-10 to base-2,</p> <pre><code>50 / 2 = 25; 50 % 2 = 0\n25 / 2 = 12; 25 % 2 = 1\n12 / 2 = 6; 12 % 2 = 0\n6 / 2 = 3; 6 % 2 = 0\n3 / 2 = 1; 3 % 2 = 1\n1 / 2 = 0; 1 % 2 = 1\n</code></pre> <p>\u7136\u540etraverse the remainders from bottom to top, we get \\(50_{(10)} = 110010_{(2)}\\). \u5bf9\u4e8e\u5c0f\u6570\uff0c\u6211\u4eec\u53ef\u4ee5\u7528\u7c7b\u4f3c\u7684\u65b9\u6cd5\uff0c\u4e0d\u8fc7\u662f\u4e58\u4ee52. \u6bd4\u59820.6875 to base-2,</p> <pre><code>0.6875 \u00d7 2 = 1.375 with integer 1\n0.375 \u00d7 2 = 0.75 with integer 0\n0.75 \u00d7 2 = 1.5 with integer 1\n0.5 \u00d7 2 = 1 with integer 1\n</code></pre> <p>Traverse the integer part from top to bottom, we get \\(0.6875_{(10)} = 0.1011_{(2)}\\).</p> <p>Warning</p> <p>A finite fraction in one base may become infinite in another case. \u6bd4\u59821/3 in base-10 is 0.3333...\uff0c\u4f46\u662f\u5728base-3\u4e2d\u662f0.1.</p>"},{"location":"algorithm/bit_manipulation/#2-representing-integers","title":"2 Representing Integers","text":"<p>\u8ba1\u7b97\u673a\u7528binary, \u6bcf\u4e00\u4e2adigit(\u4f4d)\uff0c\u7528\u8ba1\u7b97\u673a\u672f\u8bed\u53eb\u505abit,  can only be <code>0</code> or <code>1</code>. \u4e5f\u5c31\u662f\u8bf4\uff0c<code>m</code> digits\u7684\u4e8c\u8fdb\u5236\uff0c\u80fd\u8868\u793a\u7684\u6570\u5b57\u662f\\(2^m\\) in base-10. \u6216\u8005\u8bf4, \\(2^m\\)\u8868\u793a\u7684\u662f\u53ef\u80fd\u6027. </p> <p>Tip</p> <p>\u5bf9\u4e8e\u53ef\u80fd\u6027\u7684\u7406\u89e3\uff0c\u4f60\u53ef\u4ee5\u60f3\u8c61\u6210\u4f60\u629b\u786c\u5e01\uff0c\u786c\u5e01\u6b63\u53cd\u4e24\u9762\u5bf9\u5e940\u548c1. \u4f60\u629b<code>m</code>\u6b21\u786c\u5e01\uff0c\u4f60\u6709\\(2^m\\)\u79cd\u53ef\u80fd\u6027. \u540c\u7406for m digits in a row like <code>_,_,_...,_,_</code>, you have \\(2^m\\) possibilities.</p> <p>bit\u5355\u4f4d\u592a\u5c0f\u4e86\uff0c\u6240\u4ee5\u6709\u4e861 byte = 8 bits. bytes\u80fd\u8868\u8fbe\u7684, </p> <ul> <li>1-byte number, i.e. 8 bits with \\(2^8\\) possibilities, 0 to 255.</li> <li>2-byte number, i.e. 16 bits with \\(2^{16}\\) possibilities, 0 to 65535.</li> <li>4-byte number, i.e. 32 bits with \\(2^{32}\\) possibilities, 0 to 4294967295.</li> <li>8-byte number, i.e. 64 bits with \\(2^{64}\\) possibilities, 0 to 18446744073709551615.</li> </ul>"},{"location":"algorithm/bit_manipulation/#3-signed-and-unsigned-integers","title":"3. Signed and Unsigned Integers","text":"<p>\u6211\u4eec\u4e4b\u524d\u7684\u8ba8\u8bba\uff0c\u5305\u62ec\u4e86\u6b63\u6574\u6570\u548c\u5c0f\u6570\uff0c\u4f46\u6ca1\u8ba8\u8bba\u8fc7\u8d1f\u6570\u3002\u8ba1\u7b97\u673a\u9700\u8981\u8868\u8fbe\u6b63\u6570\u548c\u8d1f\u6570\uff0c\u56e0\u6b64\u6709\u4e00\u4e2a\u6982\u5ff5\u53eb<code>sign bit</code>, \u5047\u8bbe\u6211\u4eec\u6709\u4e00\u4e2a1 byte, \u5982\u4e0b\u56fe\u6240\u793a</p> <p></p> <p>\u5176\u4e2d1 byte\u4e2d\u7684\u7b2c\u4e00\u4f4d\u662fsign bit, 0\u8868\u793a\u6b63\u6570\uff0c1\u8868\u793a\u8d1f\u6570\u3002\u5269\u4e0b\u76847\u4f4d\u662fmagnitude bits, \u7528\u6765\u8868\u793a\u6570\u5b57\u7684\u5927\u5c0f\u3002\u4e5f\u5c31\u662f\u8bf4\uff0c\u540c\u6837\u7684\u4e00\u4e2a\u6570\u636e\u7c7b\u578b\uff0c\u6839\u636e\u5b9a\u4e49\u4e0d\u540c\uff0c\u80fd\u8868\u793a\u7684\u6570\u5b57\u8303\u56f4\u4e5f\u4e0d\u540c\u3002\u6bd4\u5982, </p> <ul> <li>1 byte signed integer. \u56e0\u4e3a\\(2^7\\) = 128 for magnitude bits, \u7136\u540esign bit\u8868\u8fbe0\u6216\u80051\uff0c \u6240\u4ee5\u63a8\u7406\u51fa-128 to 127</li> <li>1 byte unsigned integer. \\(2^8\\) = 256, \u6240\u4ee50 to 255.</li> </ul> <p>\u7531\u4ee5\u4e0a\uff0c\u6211\u4eec\u53ef\u4ee5\u603b\u7ed3\u51fa,</p> <ul> <li><code>n</code> bits signed integer, \\(-2^{n-1}\\) to \\(2^{n-1}-1\\). For unsigned integer, 0 to \\(2^n-1\\).</li> </ul>"},{"location":"algorithm/bit_manipulation/#3-the-original-code-inverse-code-and-complement-code","title":"3. The Original Code, Inverse Code and Complement Code","text":""},{"location":"algorithm/bit_manipulation/#31-machine-number-and-truth-value","title":"3.1 Machine Number and Truth Value","text":"<p>\u5148\u5f97\u77e5\u9053\u4fe9\u6982\u5ff5\uff0c <code>machine number</code> and <code>truth value</code>.</p> <ul> <li><code>machine number</code>: The binary representation of a number in a computer is called its machine number. It's a signed number.</li> <li><code>truth value</code>: \u7528\u6765\u533a\u5206\u548c\u7eaf2\u8fdb\u5236\u7684\u533a\u522b\u3002</li> </ul> <p>\u6bd4\u5982\uff0cthe truth value of <code>00000010</code> is +2 and truth value of <code>10000010</code> is -2. \u4f46real value of 10000010 is 130. </p>"},{"location":"algorithm/bit_manipulation/#32-original-code","title":"3.2 Original Code","text":"<p><code>The original code</code> is the sign bit of the machine number plus the absolute value of the truth value of the machine number.</p> <p>The original code for +10 is 00001010 and for -10 is 10001010. </p>"},{"location":"algorithm/bit_manipulation/#33-inverse-code","title":"3.3 Inverse Code","text":"<p><code>The inverse code</code> \u662fderived from original code. \u5b9a\u4e49\u4e3a:</p> <ul> <li>\u5bf9\u4e8e\u975e\u8d1f\u6570, inverse code is the same as the original code.</li> <li>\u5bf9\u4e8e\u8d1f\u6570, inverse code flip every bit of the original code except the sign bit. <code>flip</code>\u7684\u5b9a\u4e49\u4e3a0\u53d8\u62101, 1\u53d8\u62100.</li> </ul> - original code inverse code +10 00001010 00001010 -10 10001010 11110101"},{"location":"algorithm/bit_manipulation/#34-complement-code","title":"3.4 Complement Code","text":"<p><code>The complement code</code> \u662fderived from the inverse code. \u5b9a\u4e49\u4e3a:</p> <ul> <li>\u5bf9\u4e8e\u975e\u8d1f\u6570, complement code is the same as the inverse code.</li> <li>\u5bf9\u4e8e\u8d1f\u6570, complement code is the inverse code plus \\(1_{\\left(2\\right)}\\).</li> </ul> - original code inverse code complement code +10 00001010 00001010 00001010 -10 10001010 11110101 11110110"},{"location":"algorithm/bit_manipulation/#35","title":"3.5 \u6709\u5565\u7528?","text":"<p>\u4e3b\u8981\u662f\u4e3a\u4e86\u65b9\u4fbf\u4eba\u8111\u8ba1\u7b97. </p>"},{"location":"algorithm/bit_manipulation/#4-bit-operations","title":"4 Bit Operations","text":"<p>\u4e00\u5171\u67096\u79cdbit operations, AND, OR, XOR, negation, left shift and right shift \u5982\u4e0b\u8868</p> Operation Symbol Description AND <code>&amp;</code> \u4e24\u4e2abit\u90fd\u662f1\uff0c\u7ed3\u679c\u662f1 OR \\(\\mid\\) \u4e24\u4e2abit\u6709\u4e00\u4e2a\u662f1\uff0c\u7ed3\u679c\u662f1 XOR <code>^</code> \u4e24\u4e2abit\u4e0d\u4e00\u6837\uff0c\u7ed3\u679c\u662f1 NOT <code>~</code> flip bit Left Shift <code>&lt;&lt;</code> \u5de6\u79fb Right Shift <code>&gt;&gt;</code> \u53f3\u79fb"},{"location":"algorithm/bit_manipulation/#41-and-or-xor-and-negation","title":"4.1 AND, OR, XOR and Negation","text":"<p>The symbol for <code>AND</code> is <code>&amp;</code>. \u4e24\u4e2abit\u90fd\u662f1\uff0c\u7ed3\u679c\u662f1. </p> <p>The symbol for <code>OR</code> is \\(\\mid\\). \u4e24\u4e2abit\u53ea\u8981\u6709\u4e00\u4e2a\u662f1\uff0c\u7ed3\u679c\u662f1.</p> <p>The symbol for <code>XOR</code> is <code>^</code> (python) but in math \\(\\oplus\\). \u4e24\u4e2abit\u4e0d\u4e00\u6837\uff0c\u7ed3\u679c\u662f1, \u6bd4\u5982</p> <ul> <li>0 \\(\\oplus\\) 0 = 0</li> <li>0 \\(\\oplus\\) 1 = 1</li> <li>1 \\(\\oplus\\) 0 = 1</li> <li>1 \\(\\oplus\\) 1 = 0</li> </ul> <p>\u5176\u5b9e\u4e5f\u53ef\u4ee5\u7528\u6765\u8868\u8fbevenn's diagram. \u4ee3\u8868\u7740symmetric set difference, \u4e5f\u5c31\u662f\u8bf4\uff0c\u4e24\u4e2a\u96c6\u5408\u7684\u5dee\u96c6\uff0c\u4e0d\u5305\u62ec\u4ea4\u96c6. \u6bd4\u5982\\(A \\oplus B = (A-B) \\cup (B-A)\\). \u5176\u5b9e\u4e5f\u5c31\u662fexclusive or\u4e86. </p> <p></p> <p>The symbol for <code>NOT</code> is <code>~</code>. flip bit.</p> <ul> <li><code>~0</code> = 1</li> <li><code>~1</code> = 0</li> </ul> <p>Tip</p> <p>For Negation, \u4f60\u5148\u6c42\u51fa\u539f\u6570\u7684complement code, \u7136\u540e\u52a01.\u6bd4\u5982\u4f60\u6709\u4e00\u4e2a\u6570\uff0c-1\uff0c \u4f60\u5148\u6c421 in binary 0001, \u7136\u540eflip bit, 1110, \u7136\u540e\u52a01, 1111. \u6216\u8005\u7528\u6211\u4eec\u4e4b\u524d\u5b66\u7684, \u5148\u5b66<code>original code</code> of -1, 10000001, \u7136\u540e<code>inverse code</code>, 01111110, \u7136\u540e<code>complement code</code>, 01111111.</p> <p>\u4f60\u53ef\u4ee5\u505a\u70b9\u7b80\u5355\u7684exercise\u6765\u7406\u89e3\u8fd9\u4e9b\u64cd\u4f5c. </p>"},{"location":"algorithm/bit_manipulation/#42-left-and-right-shift","title":"4.2 Left and Right Shift","text":"<pre><code>flowchart TD\nshift[Shift Operation] \ndir[direction]\nsign[whether it is signed or unsigned]\nshift --&gt; dir &amp; sign\n\ndir --&gt; |left| left[\"left &lt;&lt;\"]\ndir --&gt; |right| right[\"right &gt;&gt;\"]\n\nsign --&gt; |signed| signed[\"logical shift\"]\nsign --&gt; |unsigned| unsigned[\"arithmetic shift\"]\n</code></pre> <p>For left shift <code>&lt;&lt;</code>, all binary bits are shifted to the left by a certain number of positions. The high bits are discarded and the low bits are filled with 0.</p> <p>For right shift <code>&gt;&gt;</code>, all binary bits are shifted to the right by a certain number of positions. The low bits are discarded and, </p> <ul> <li>for arithmetic shift, the high bits are filled with the highest bit, \u6700\u5de6\u8fb9\u7684bit, \u4e5f\u5c31\u662fsign bit. \u5c31\u662f\u4fdd\u7559\u7b26\u53f7\u7684shift.</li> <li>for logical shift, the high bits are filled with 0. \u4e5f\u5c31\u662f\u4e0d\u4fdd\u7559\u7b26\u53f7\u7684shift.</li> </ul> <p>Warning</p> <p>\u5bf9\u4e8e\u6b63\u6574\u6570\uff0clogical shift\u548carithmetic shift\u662f\u4e00\u6837\u7684\u3002\u4f46\u662f\u5bf9\u4e8e\u8d1f\u6570\uff0clogical shift\u548carithmetic shift\u662f\u4e0d\u4e00\u6837\u7684\u3002</p> <p>-50 in binary is 11001110. </p> <pre><code>flowchart TD\na[-50]\nb[11110011]\nc[00110011]\n\na --&gt;|arithmetic right shift by 2 bits| b\na --&gt;|logical right shift by 2 bits| c\n\nb --&gt; d[-13]\nc --&gt; e[51]</code></pre>"},{"location":"algorithm/bit_manipulation/#43-shift-operation","title":"4.3 shift operation\u4e0e\u4e58\u9664\u6cd5\u7684\u5173\u7cfb","text":"<p>\u8fd9\u4e5f\u662f\u4e3a\u4ec0\u4e48\u6211\u4eec\u8981\u5b66\u8fd9\u73a9\u610f. </p>"},{"location":"algorithm/bit_manipulation/#431-left-shift-and-multiplication","title":"4.3.1 left shift and multiplication","text":"<p>left shift <code>&lt;&lt;</code> \u5bf9\u5e94\u7740multiplication. \u6bd4\u5982shift 29 by 2 bits is 116, which is same as 29 * 4. \u5b9e\u9645\u4e0a\u5f88\u597d\u7406\u89e3\uff0c\u56e0\u4e3awe discard high bits and fill low bits with 0, \u4e5f\u5c31\u662f\u8bf4\u6211\u4eec\u4ee3\u8868\u7684\u53ef\u80fd\u6027\u6574\u4f53\u589e\u52a0\u4e86\\(2^2\\). 29 in binary is 11101, shift\u4e4b\u540e\u662f1110100, which is 116. \u6211\u4eec\u89e3\u5228\u4e00\u4e0b29 = 11101, \u4ee3\u5165weights,</p> \\[ 29_{(10)} = 2^4 + 2^3 + 2^0 = 11101_{(2)} \\] <p>We shift it to the left by 2, </p> \\[ \\begin{align} 1110100_{(2)} &amp;= 2^6 + 2^5 + 2^2 \\\\               &amp;= 2^2 (2^4 + 2^3 + 2^0) \\\\               &amp;= 4 \\times 29_{(10)} \\\\ \\end{align} \\] <p>\u8fd9\u662f\u4ee52\u4e3amultiplier\u7684\u60c5\u51b5\uff0c\u5982\u679c\u662f\u4ee5\u5176\u4ed6\u6570\u4e3amultiplier\uff0c\u53ef\u4ee5\u7528\\(\\sum 2^n\\)\u7684\u7ebf\u6027\u7ec4\u5408\u8868\u793a, \u6bd4\u5982\u4f60\u60f3\u8981\u4e00\u4e2a\u6570 a x 6, <code>(a &lt;&lt; 2) + (a &lt;&lt; 1)</code>. \u4e5f\u5c31\u662f\\(2^2 + 2^1 = 6\\)</p> <p>Warning</p> <p>\u4f46\u662f\u8981\u6ce8\u610f\uff0c\u5982\u679c\u4e58\u6cd5\u7ed3\u679c\u8d85\u8fc7\u4e86\u6570\u636e\u7c7b\u578b\u80fd\u8868\u793a\u7684\u8303\u56f4\uff0c\u5c31\u4f1aoverflow. \u6bd4\u598232\u4f4d\u7684int, 2^31-1 = 2147483647, 2^31 = 2147483648, \u8d85\u8fc7\u4e86int\u80fd\u8868\u793a\u7684\u8303\u56f4.</p>"},{"location":"algorithm/bit_manipulation/#432-right-shift-and-division","title":"4.3.2 right shift and division","text":"<p>arithmetic right shift <code>&gt;&gt;</code> \u5bf9\u5e94\u7740division. 50\u7ecf\u8fc72\u4f4darithmetic right shift, \u5f97\u523012\uff0c \u4e5f\u5c31\u662f\\(\\frac{50}{2^2}\\), \u8fd9\u4e2a\u53ea\u5bf9\u6b63\u6574\u6570hold.</p>"},{"location":"algorithm/bit_manipulation/#44-properties-of-bit-operations","title":"4.4 Properties of Bit Operations","text":"<p>Assuming signed integers,</p> - formulation description example idempotent law \\(a \\&amp; a = a, a \\mid a = a\\) \u6211operate\u6211\u81ea\u5df1\uff0c\u8fd8\u662f\u6211\u81ea\u5df1. - commutative law \\(a \\&amp; b = b \\&amp; a\\), \\(a \\mid b = b \\mid a\\), \\(a \\oplus b = b \\oplus a\\) \u4ea4\u6362\u5f8b - associative law \\((a \\&amp; b) \\&amp; c = a \\&amp; (b \\&amp; c)\\), \\((a \\mid b) \\mid c = a \\mid (b \\mid c)\\), \\((a \\oplus b) \\oplus c = a \\oplus (b \\oplus c)\\) \u7ed3\u5408\u5f8b - distributive law \\(a \\&amp; (b \\mid c) = (a \\&amp; b) \\mid (a \\&amp; c)\\), \\(a \\mid (b \\&amp; c) = (a \\mid b) \\&amp; (a \\mid c)\\),\\(a \\oplus (b \\&amp; c) = (a \\oplus b) \\&amp; (a \\oplus c)\\), \u5206\u914d\u5f8b - De Morgan's law \\(\\sim (a \\&amp; b) = \\sim a \\mid \\sim b\\), \\(\\sim (a \\mid b) = \\sim a \\&amp; \\sim b\\) \u5fb7\u6469\u6839\u5b9a\u5f8b - <p>\u4e0a\u8ff0\u8fd9\u4e9b\u6cd5\u5219\u4e4b\u5916\uff0c\u52a0\u51cf\u4e58\u9664\u6cd5\u4e5f\u6709\u5bf9\u5e94\u7684\u6cd5\u5219\uff0c\u6bd4\u5982</p> <ul> <li>AND Operation: <ul> <li>\\(a \\&amp; 0 = 0\\), </li> <li>\\(a \\&amp; (-1) = a\\), </li> <li>\\(a \\&amp; (\\sim a) = 0\\)</li> </ul> </li> <li>OR Operation: <ul> <li>\\(a \\mid 0 = a\\), </li> <li>\\(a \\mid (\\sim a) = -1\\)</li> </ul> </li> <li>XOR Operation: <ul> <li>\\(a \\oplus 0 = a\\), </li> <li>\\(a \\oplus a = 0\\)</li> </ul> </li> <li>Negation Operation (flipping bits): <ul> <li>\\(\\sim 0 = -1\\), </li> <li>\\(\\sim (-1) = 0\\)</li> </ul> </li> <li>Other Properties:<ul> <li>\\(a \\&amp; (a-1)\\) is to change the last 1 in the binary representation of a to 0.</li> <li>\\(a \\&amp; (-a)\\) is to keep only the last 1 of the binary representation of a, and set the remaining 1s to 0.</li> </ul> </li> </ul> <p>\u8fd9\u4e9bproperties\u5bf9\u4e8e\u7406\u89e3bit manipulation\u548c\u505abit\u7684\u9898\u76ee\u5f88\u6709\u7528.</p>"},{"location":"algorithm/bit_manipulation/tricks/","title":"Bit Tricks for CP","text":"<p>\u8fd9\u4e00\u7ae0\u6211\u4eec\u6765\u770b\u4e00\u4e9bbit manipulation\u7684tricks, \u8fd9\u4e9btricks\u53ef\u4ee5\u5e2e\u52a9\u6211\u4eec\u5feb\u901f\u7684\u89e3\u51b3\u4e00\u4e9b\u95ee\u9898\uff0c\u8981\u6ce8\u610f\u7684\u662f\u4ee5\u4e0b\u8fd9\u4e9btrick, \u5c31\u50cf\u7b49\u4ef7\u6570\u5217\u7684\u6c42\u548c\u516c\u5f0f\u4e00\u6837\uff0c\u4f5c\u4e3a\u4e00\u4e2a\u6570\u5b66\u5de5\u5177\u8ba9\u6211\u4eec\u52a0\u901f\u505a\u4e00\u4e9b\u8ba1\u7b97, \u5bf9\u4e8e\u67d0\u4e9b\u9700\u8981recursion\u6216\u8005loop\u7684\u9898\u76ee\uff0c\u6211\u4eec\u5047\u8bbe\u77e5\u9053\u8fd9\u4e9btricks, \u5c31\u53ef\u4ee5\u4e0d\u7528error-prone\u7684recursion\u6216\u8005loop\u6765\u89e3\u51b3\u95ee\u9898. \u4f46\u8fd9\u4e00\u90e8\u5206\u77e5\u8bc6\u7684\u5b66\u4e60\u7eaf\u7cb9\u53ea\u662f\u4e3a\u4e86\u89e3puzzle,\u56e0\u4e3a:</p> <ul> <li>\u727a\u7272\u4e86readability</li> <li>\u6709\u4e9btrick\u53ef\u80fd\u4f1a\u5bfc\u81f4overflow. handle overflow\u7684\u95ee\u9898</li> <li>\u5e76\u4e0d\u6d89\u53ca\u5230\u4ec0\u4e48\u6570\u636e\u7ed3\u6784\uff0c\u53ea\u662f\u7528\u6765\u505a<ul> <li>\u5c40\u90e8\u4f18\u5316 (CP\u4e2d\u5076\u5c14\u9700\u8981)</li> <li>\u67d0\u4e9btricks\u4e0d\u9700\u8981recursion or loop.</li> </ul> </li> </ul> <p>\u7b97\u662f\u6bd4\u8f83low priority\u7684\u77e5\u8bc6\u70b9.</p>"},{"location":"algorithm/bit_manipulation/tricks/#1","title":"1. \u5947\u5076\u6027","text":"<p>\u901a\u5e38\u5224\u65adodd or even\u4f1a\u7528\u5230modulus operator, \u6bd4\u5982</p> <pre><code>if x%2 == 0:\n    print(\"Even\")\nelse:\n    print(\"Odd\")\n</code></pre> <p>\u4f46\u6211\u4eec\u53ef\u4ee5\u770bleast significant bit(\u6700\u53f3\u8fb9\u7684bit), \u662f\u5426\u662f0 or 1\u6765\u5224\u65ad\u5947\u5076\u6027\u3002\u5982\u679c\u662f0, \u90a3\u4e48\u662feven, \u5982\u679c\u662f1, \u90a3\u4e48\u662fodd. \u8fd9\u4e5f\u662f\u4e3a\u5565\u53eb\u4e8c\u8fdb\u5236\u7684\u539f\u56e0\uff0c\u56e0\u4e3a\u5947\u6570\u8fd8\u6ca1\u8fdb\u4f4d\u5462. \u6211\u4eecdry run\u4e00\u4e0b<code>7=111</code>,  <pre><code>    111\n   &amp;  1\n   -----\n      1\n</code></pre> \u6240\u4ee5\u4ee5\u540e\u6211\u4eec\u53ef\u4ee5\u7528\u4e0b\u9762\u7684lambda function\u6765\u5224\u65ad\u5947\u5076\u6027, </p> <pre><code>is_odd = lambda x: x&amp;1 == 1\n</code></pre> Leetcode 191 Number of Bits <p>Given an unsigned integer, calculate the number of '1' bits it has (also known as the Hamming weight). For example, the 32-bit integer <code>11</code> has binary representation <code>00000000000000000000000000001011</code>, so the function should return <code>3</code>. </p> <p>Solution here.</p>"},{"location":"algorithm/bit_manipulation/tricks/#2-power-of-two","title":"2. Power of Two","text":"<p>\u68c0\u9a8c\u4e00\u4e2ainteger <code>n</code>\u662f\u5426\u662f\u4e00\u4e2apower of 2, \\(n=2^x\\), \u6211\u4eec\u53ea\u9700\u8981\u505a,</p> <pre><code># edge case for this operation\nif n == 0:\n    return True\n\nif n &amp; (n-1) == 0:\n    return True\n\nreturn False\n</code></pre> Leetcode 231 Power of Two <p>Given an integer <code>n</code>, write a function to determine if it is a power of two. Let's say <code>n=16</code>, then <code>16=2**4</code>, so it's a power of 2.</p> <p>Solution here</p>"},{"location":"algorithm/bit_manipulation/tricks/#3-play-with-kth-bits","title":"3. Play with kth Bits","text":"<p>\u8fd9\u4e2atrick\u5b9a\u4e49\u7684kth bits from the right (kth least significant bit), \u6709\u4ee5\u4e0b\u56db\u79cd\u64cd\u4f5c, \u5047\u8bbe\u6211\u4eec\u6709\u4e00\u4e2a\u6570\u5b57<code>n</code>,</p> - - check if \\(k_{th}\\) bit is set <code>n &amp; (1 &lt;&lt; k) != 0</code> toggle \\(k_{th}\\) bit <code>n ^ (1 &lt;&lt; k)</code> set \\(k_{th}\\) bit <code>n | (1 &lt;&lt; k)</code> unset \\(k_{th}\\) bit <code>n &amp; ~(1 &lt;&lt; k)</code>"},{"location":"algorithm/bit_manipulation/tricks/#31-check-if-k_th-bit-is-set","title":"3.1 check if \\(k_{th}\\) bit is set","text":"<p>\u628a<code>1</code>\u5411\u5de6\u79fb\u52a8<code>k</code>\u4f4d (<code>1&lt;&lt;k</code>)\uff0c\u7136\u540e\u548c<code>n</code>\u505a<code>&amp;</code>\u64cd\u4f5c\uff0c\u5982\u679c\u7ed3\u679c\u4e0d\u662f0\uff0c\u90a3\u4e48<code>kth</code> bit\u662fset.</p>"},{"location":"algorithm/bit_manipulation/tricks/#32-toggle-k_th-bit","title":"3.2 Toggle \\(k_{th}\\) bit","text":"<p>\u540c\u7406\uff0c\u628a<code>1</code>\u5411\u5de6\u79fb\u52a8<code>k</code>\u4f4d (<code>1&lt;&lt;k</code>)\uff0c\u7136\u540e\u548c<code>n</code>\u505a<code>^</code>\u64cd\u4f5c\uff0c\u5c31\u662ftoggle\u4e86<code>kth</code> bit. \u7531\u4e8e\u662fXOR, \u5c31\u4e24\u79cdcase:</p> <ul> <li>kth bit is 0, then 0 ^ 1 = 1</li> <li>kth bit is 1, then 1 ^ 1 = 0</li> </ul>"},{"location":"algorithm/bit_manipulation/tricks/#33-set-k_th-bit","title":"3.3 Set \\(k_{th}\\) bit","text":"<p>\u8fd9\u4e2a\u540c\u7406\uff0c\u5f88\u597d\u7406\u89e3</p>"},{"location":"algorithm/bit_manipulation/tricks/#34-unset-k_th-bit","title":"3.4 Unset \\(k_{th}\\) bit","text":"<p>\u5f88\u597d\u7406\u89e3.</p>"},{"location":"algorithm/bit_manipulation/tricks/#4-multiply-or-divide-a-number-by-2k","title":"4. Multiply or Divide a number by \\(2^k\\)","text":"operation - example Multiply by \\(2^k\\) <code>n &lt;&lt; k</code> - Divide by \\(2^k\\) <code>n &gt;&gt; k</code> - <p>Warning</p> <p>\u5f80\u5de6\u662f\u4e58\u6cd5\uff0c\u5f80\u53f3\u662f\u9664\u6cd5. \u4f46\u662f\u8981\u6ce8\u610f\uff0c\u5982\u679c\u662fright shift for negative number \u4ee5\u53caoverflow\u7684\u95ee\u9898.</p>"},{"location":"algorithm/bit_manipulation/tricks/#5-find-if-n-2k","title":"5. Find if \\(n \\% 2^k\\)","text":"<p>\u4e00\u4e2a\u7528bitwise\u5feb\u901f\u8ba1\u7b97, \u4efb\u610f\u6570\u5b57<code>n</code> mod \\(2^k\\)\u7684\u65b9\u6cd5\u662f,</p> \\[ x \\&amp; ( (1&lt;&lt;k) - 1) \\] <p>\u6211\u4eec\u6765\u4e3e\u4e2a\u4f8b\u5b50<code>n=10, k=2</code>, <pre><code>10 % 2^2 = 2\n</code></pre></p>"},{"location":"algorithm/bit_manipulation/tricks/#6","title":"6.","text":"<p>Place holder here. Come back in the future.</p>"},{"location":"algorithm/bit_manipulation/tricks/#reference","title":"Reference","text":"<ul> <li>TLE by Priyansh, 10 bitwise tricks</li> </ul>"},{"location":"algorithm/enumerate/","title":"Enumerate (\u679a\u4e3e)","text":""},{"location":"algorithm/enumerate/#enumerate_1","title":"Enumerate\u5b9a\u4e49","text":"<p>An <code>enumeration</code> is a complete, ordered listing of all the items in a collection. The term is commonly used in mathematics and computer science to refer to a listing of all of the elements of a set. In the context of DSA, it refers to try out all potential solutions to a problem.</p> <p>Tip</p> <p>\u7b54\u9898\u987a\u5e8f\u7b2c\u4e00\u6b65\u5c31\u662f\u5148\u60f3\u51fabrute force(enumerate), \u4e4b\u540e\u518d\u6269\u5c55\u5176\u5b83\u7b97\u6cd5\u7684\u53ef\u80fd\u6027\u3002\u7ed3\u5408constraint\u7ed9\u7684\u8303\u56f4\uff0c\u6765\u6392\u9664\u6389\u4e00\u4e9b\u5728\u5f53\u524dconstraints\u4e0b\uff0c\u590d\u6742\u5ea6\u592a\u9ad8\u7684\u5907\u9009\u7b97\u6cd5\uff0c\u7136\u540e\u518d\u4ece\u5269\u4e0b\u7684\u7b97\u6cd5\u4e2d\u9009\u62e9\u6700\u4f18\u6216\u4f60\u4f1a\u7684\u3002</p>"},{"location":"algorithm/enumerate/#enumerate_2","title":"Enumerate\u7684\u5e94\u7528","text":"<ul> <li>\u66b4\u529b\u641c\u7d22\u4f60\u7684password\u554a, \u8fd9\u4e9b\u90fd\u662f\u679a\u4e3e. \u6bd4\u5982\u4f60\u7684\u5bc6\u7801\u57288-16\u4f4d\uff0c\u901a\u8fc7\u4f60\u5b9a\u4e49\u7684password\u9700\u6c42\uff0c\u5927\u5c0f\u5199\u7b49\uff0c\u6392\u9664\u6389\u4e00\u4e9b\u4e0d\u53ef\u80fd\u7684\u7ec4\u5408\uff0c\u7136\u540e\u518d\u53bb\u5c1d\u8bd5\u5269\u4e0b\u7684\u7ec4\u5408\u3002</li> </ul> <p>\u6bd4\u8f83\u5173\u952e\u7684\u662f:</p>"},{"location":"algorithm/enumerate/#_1","title":"\u4f8b\u9898","text":"<p>\u679a\u4e3e\u4e09\u8981\u7d20</p> <ul> <li><code>define solution space</code>: \u5b9a\u4e49\u89e3\u7a7a\u95f4, \u5373\u7136\u8981\u66b4\u529b\u641c\u7d22\uff0c\u8981\u60f3\u6e05\u695a\u53ef\u80fd\u7684\u60c5\u51b5\u662f\u4ec0\u4e48\uff1f\u8981\u679a\u4e3e\u4ec0\u4e48\uff1f</li> <li><code>shorten solution space</code>: \u7f29\u5c0f\u89e3\u7a7a\u95f4, \u901a\u8fc7constraints\u6765\u7f29\u5c0f\u89e3\u7a7a\u95f4\uff0c\u662f\u5426\u6709\u8840\u60c5\u51b5\u4e0d\u9700\u8981\u8003\u8651\uff1f\u6bd4\u5982\u4e0a\u9762\u7684\u5bc6\u7801\u4f8b\u5b50\uff0c\u4f60\u4e0d\u9700\u8981\u8003\u8651\u5168\u662f\u5c0f\u5199\u7684\u60c5\u51b5\uff0c\u56e0\u4e3a\u5bc6\u7801\u89c4\u8303\u8981\u6c42\u5fc5\u987b\u6709\u5927\u5199\u3002\u901a\u8fc7\u5927\u5c0f\u5199\uff0c\u957f\u5ea6, \u7279\u6b8a\u7b26\u53f7\u7b49\u7b49\u79cd\u79cd\u6765\u7f29\u5c0f\u89e3\u7a7a\u95f4, \u63d0\u9ad8\u6548\u7387\u3002</li> <li><code>order of enumeration</code>: \u679a\u4e3e\u7684\u987a\u5e8f, \u6709\u65f6\u5019\u679a\u4e3e\u7684\u987a\u5e8f\u4e5f\u662f\u6709\u8bb2\u7a76\u7684\u3002\u5faa\u73af\u65f6\uff0ci, j\u8fd8\u662fi+1, j+1, \u8fb9\u754c\u70b9\u554a\uff0c\u5148\u5faa\u73afi or j</li> </ul> <p>\u4f8b\u9898</p> <p>\u4e00\u4e2a\u6570\u7ec4\u4e2d\u7684\u6570\uff0c\u4e92\u4e0d\u76f8\u540c\uff0c\u6c42\u5176\u4e2d\u548c\u4e3a0\u7684\u6570\u5bf9\u7684\u7ec4\u5408</p>"},{"location":"algorithm/enumerate/#1","title":"\u65b9\u6cd51: \u679a\u4e3e\u6240\u6709\u60c5\u51b5","text":"<pre><code>for i in range(n):\n    for j in range(n):\n        if i != j and a[i] + a[j] == 0:\n            res += 1\n</code></pre> <p>\u8fd9\u4e2a\u65b9\u6cd5\u5b9e\u9645\u4e0a\u679a\u4e3e\u4e86\\(n^2\\)\u6b21. \u4f46\u6211\u4eec\u6709\u4e24\u4e2a\u5c0f\u4f18\u5316\u53ef\u4ee5\u505a\uff0c</p> <ul> <li>\u6211\u4eec\u5e76\u6ca1\u6709\u5145\u5206\u5229\u7528<code>\u4e00\u4e2a\u6570\u7ec4\u4e2d\u4e92\u4e0d\u76f8\u540c</code>\u8fd9\u4e2a\u6761\u4ef6\u3002\u6211\u4eec\u53ea\u662f\u8003\u8651\u5230\u4e86\u60c5\u51b5\uff0c\u901a\u8fc7<code>i != j</code>\u6765\u6392\u9664\u6389\u4e86\u91cd\u590d\u7684\u60c5\u51b5\u3002\u4f46\u662f\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7<code>i &gt; j</code>\u6765\u6392\u9664\u6389\u4e00\u4e9b\u60c5\u51b5\uff0c\u8fd9\u6837\u53ef\u4ee5\u51cf\u5c11\\(n\\)\u6b21\u679a\u4e3e\u6b21\u6570, \u4e5f\u5c31\u662f\\(O(n^2-n)\\)</li> <li>\u9898\u76ee\u6ca1\u8981\u6c42\u662f\u6709\u5e8f\u8fd8\u662f\u65e0\u5e8f\u7684\u3002A.K.A. \u5982\u679c(a,b)\u662f\u7b54\u6848\uff0c\u90a3\u4e48(b,a)\u4e5f\u662f\u7b54\u6848\u3002\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7<code>i &lt; j</code>\u6765\u8003\u8651\u7b2c\u4e00\u4e2a\u6570\u5b57\u5728\u524d\u7684\u60c5\u51b5\uff0c\u8fd9\u6837\u53ef\u4ee5\u51cf\u5c11\\(n/2\\)\u6b21\u679a\u4e3e\u6b21\u6570, \u6700\u540e\u518d\u7b54\u6848x2\u5373\u53ef\u3002\u4e5f\u5c31\u662f\\(O(\\frac{n^2}{2})\\)</li> </ul>"},{"location":"algorithm/enumerate/#2","title":"\u65b9\u6cd52: \u4f18\u5316\u679a\u4e3e","text":"<p><pre><code>for i in range(n):\n    for j in range(i):\n        if a[i] + a[j] == 0:\n            res += 1\nres *= 2\n</code></pre> \u4f60\u628a\u6240\u6709(i,j)\u5217\u4e0b, \u4f1a\u53d1\u73b0\u8fd9\u6837\u7684\u7ec4\u5408\u662f\u4e0d\u4f1a\u91cd\u590d\u7684\u3002\u56e0\u4e3a<code>i &gt; j</code>, \u6240\u4ee5\u4e0d\u4f1a\u6709\u91cd\u590d\u7684\u7ec4\u5408\u3002\u8fd9\u6837\u6211\u4eec\u5c31\u51cf\u5c11\u4e86\u4e00\u534a\u7684\u679a\u4e3e\u6b21\u6570\u3002</p> <pre><code>(1, 0)\n(2, 0)\n(2, 1)\n(3, 0)\n(3, 1)\n(3, 2)\n(4, 0)\n(4, 1)\n(4, 2)\n(4, 3)\n</code></pre> <p>\u540c\u7406\u4f60\u4e5f\u53ef\u4ee5\u53cd\u4e00\u53cd\uff0c\u8ba9<code>i &lt; j</code></p> <pre><code>for i in range(n):\n    for j in range(i+1, n):\n        if a[i] + a[j] == 0:\n            res += 1\nres *= 2\n</code></pre> <p>\u5217\u51fa\u6240\u6709\u7ed3\u679c <pre><code>(0, 1)\n(0, 2)\n(0, 3)\n(0, 4)\n(1, 2)\n(1, 3)\n(1, 4)\n(2, 3)\n(2, 4)\n(3, 4)\n</code></pre></p> <p>\u7ed3\u5408\u4ee5\u4e0a\u4e24\u79cd\u60c5\u51b5\uff0c\u8fd9\u79cd\u7b97\u6cd5\u7684\u590d\u6742\u5ea6\uff0c\\(O(\\frac{n^2}{2})\\approx O(n^2)\\), \u867d\u7136\u6ca1\u6709\u5927\u7684\u8fdb\u5316\uff0c\u4f46\u662f\u6211\u4eec\u901a\u8fc7\u679a\u4e3e\u7684\u4f18\u5316\uff0c\u51cf\u5c11\u4e86\u4e00\u534a\u7684\u679a\u4e3e\u6b21\u6570\u3002</p>"},{"location":"algorithm/enumerate/#3","title":"\u65b9\u6cd53: \u5229\u7528\u8f85\u52a9\u7a7a\u95f4","text":"<p>\u8fd9\u4e00\u6bb5\u7565\uff0c\u8981\u4e48\u7528array\u7ed3\u5408bucket sort\u7684\u601d\u60f3\uff0c\u8981\u4e48hashmap.</p>"},{"location":"algorithm/enumerate/#_2","title":"\u76f8\u5173\u9898\u76ee","text":"<ul> <li>1 two sum<ul> <li>\u68a6\u5f00\u59cb\u7684\u5730\u65b9\uff0c\u8fd9\u9898\u7684\u66b4\u529b\u89e3\u6cd5\u5c31\u662f\u679a\u4e3e\u6240\u6709\u60c5\u51b5\uff0c\u7136\u540e\u627e\u5230\u7b54\u6848. \u4f60\u53ef\u4ee5\u8bd5\u8bd5\u65b9\u6cd52\u91cc\u7684\u4f18\u5316\u679a\u4e3e.</li> </ul> </li> </ul>"},{"location":"algorithm/enumerate/#reference","title":"Reference","text":"<ul> <li>enumerate in cybersecurity</li> </ul>"},{"location":"algorithm/recursion/","title":"Recursion","text":"<p>\u8fd9\u4e00\u8282\u6211\u4eec\u6765\u8bb2\u9012\u5f52\u7684\u601d\u60f3\u3002</p>"},{"location":"algorithm/recursion/backtracking/","title":"Backtracking (\u56de\u6eaf\u7b97\u6cd5)","text":""},{"location":"algorithm/recursion/divide_and_conquer/","title":"Divide and Conquer (\u5206\u6cbb\u6cd5)","text":""},{"location":"algorithm/recursion/divide_and_conquer/#_1","title":"\u5206\u6cbb\u7684\u5b9a\u4e49","text":""},{"location":"algorithm/recursion/recursion/","title":"Recursion (\u9012\u5f52)","text":""},{"location":"algorithm/recursion/recursion/#_1","title":"\u9012\u5f52\u7684\u5b9a\u4e49","text":"<p>\u9012\u5f52\u662f\u4e00\u79cd\u89e3\u51b3\u95ee\u9898\u7684\u601d\u60f3\uff0c\u5e76\u4e0d\u662f\u4e00\u79cd\u5177\u4f53\u7684\u7b97\u6cd5\u6216\u8005\u6570\u636e\u7ed3\u6784\u3002\u5b83\u662f\u4e00\u79cd\u5c06\u95ee\u9898\u5206\u89e3\u4e3a\u66f4\u5c0f\u7684\u5b50\u95ee\u9898\u6765\u89e3\u51b3\u7684\u65b9\u6cd5\u3002</p>"},{"location":"algorithm/recursion/recursion/#_2","title":"\u9012\u5f52\u7684\u5e94\u7528","text":"<p>\u9012\u5f52\u4f5c\u4e3a\u4e00\u79cd\u601d\u60f3\uff0c\u901a\u5e38\u6bd4\u8f83\u96be\u60f3\u5230\u548ccouter-intuitive, \u4f46\u4ee3\u7801\u975e\u5e38\u7b80\u6d01\u3002\u9012\u5f52\u5f80\u5f80\u4f5c\u4e3a\u5176\u4ed6\u7b97\u6cd5\u7684\u57fa\u7840\uff0c\u6bd4\u5982graph + tree traversal, \u4f46\u4e5f\u6709\u5e94\u7528\u7684\uff0c\u6bd4\u5982:</p> <ul> <li>file system traversal, \u4f60\u60f3recursive\u5217\u51fa\u5f53\u524d\u76ee\u5f55\u7684\u6240\u6709<code>.txt</code>\u6587\u4ef6, <code>ls -R | grep '.txt'</code>. \u5f53\u7136\uff0c\u4f60\u4e00\u822c\u662f\u5199file parser\u7684\uff0c\u5199\u9012\u5f52\u4f1a\u5f88\u7b80\u5355, \u4e5f\u53ef\u4ee5\u7528<code>os.walk()</code> if you python.</li> <li>used in merge sort</li> </ul>"},{"location":"algorithm/recursion/recursion/#_3","title":"\u9012\u5f52\u7684\u7279\u70b9","text":"<p>\u601d\u8003\u9898</p> <p>\u7ed9\u4e00\u4e2a\u6b63\u6574\u6570n, \u8f93\u51fa\u4ece1\u5230n\u7684\u6240\u6709\u6574\u6570\u7684\u548c\u3002\u7528iteration\u548c\u9ad8\u65af\u516c\u5f0f\u5f88\u7b80\u5355\uff0c\u4f46\u4f60\u80fd\u7528\u9012\u5f52\u6765\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\u5417\uff1f</p> \u601d\u8003\u9898\u7b54\u6848 <p>\u6211\u4eec\u53ef\u4ee5\u5c06\u6c42<code>sum(n)</code>\u95ee\u9898\u5206\u89e3\u4e3a\u5176\u5b50\u95ee\u9898\u5229\u7528\u516c\u5f0f, <code>sum(n) = sum(n-1) + n</code>\uff1a</p> <ul> <li>1\u5230n-1\u7684\u6240\u6709\u6574\u6570\u7684\u548c <code>sum(n-1)</code> (\u5b50\u95ee\u9898)</li> <li>n (\u5df2\u7ecf\u77e5\u9053)</li> </ul> <p>\u4e8e\u662f\u6211\u4eec\u53ef\u4ee5\u5f97\u5230\u9012\u5f52\u7684\u5b9a\u4e49\u5f97\u5230, </p> <ul> <li>base case: <code>sum(1) = 1</code></li> <li>recursive case: <code>sum(n) = sum(n-1) + n</code></li> </ul> <pre><code>def sum(n):\n    if n == 1:\n        return 1\n    return sum(n-1) + n\n</code></pre>"},{"location":"algorithm/recursion/recursion/#memoization","title":"Memoization (\u8bb0\u5fc6\u5316\u641c\u7d22)","text":"<p>\u9012\u5f52\u7684inefficiency\uff0c\u5b83\u4f1a\u91cd\u590d\u8ba1\u7b97\u4e00\u4e9b\u5b50\u95ee\u9898\u3002\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528memoization\u6765\u907f\u514d\u91cd\u590d\u8ba1\u7b97\u3002</p> <p>\u5982\u4e0b\u56fe\u6240\u793a\uff0crecursion\u5c31\u50cf\u72d7\u718a\u5403\u7389\u7c73\uff0c\u5403\u4e00\u4e2a\u6389\u4e00\u4e2a\uff0c\u4e4b\u524d\u7b97\u8fc7\u7684\u7ed3\u679c\u7528\u5b8c\u5c31\u4e22\u4e86\uff0c\u8fd8\u5f97\u518d\u7b97\u4e00\u6b21\u3002\u6211\u4eec\u53ef\u4ee5\u7528memoization\u6765\u907f\u514d\u8fd9\u79cd\u60c5\u51b5\u3002</p> <p></p>"},{"location":"algorithm/recursion/recursion/#complexity","title":"Complexity","text":"<p>space complexity has recursion-related or non-recursion-related.</p>"},{"location":"algorithm/recursion/recursion/#summary","title":"Summary","text":""},{"location":"algorithm/recursion/recursion/#_4","title":"\u76f8\u5173\u9898\u76ee","text":"<ul> <li>70 climbing stairs and solution.</li> <li>509 Fibonacci number and solution.</li> <li>206 Reverse Linked List and solution.</li> </ul>"},{"location":"algorithm/recursion/recursion/#reference","title":"Reference","text":"<ul> <li>3blue1brown on recursion<ul> <li>visualization and 5-step method</li> </ul> </li> <li>tail recursion</li> </ul>"},{"location":"contest/","title":"LC Contest","text":"<p>Tip</p> <p>My goal is to reach <code>Knight</code> in 2024. Best strategy is to participate in every contest and solve &gt;= 3 consistently.</p>"},{"location":"contest/#contest-rating-badge","title":"Contest Rating &amp; Badge","text":"<p>The contest badge is calculated based on the contest rating.</p> <p>For LeetCoders with rating &gt;=2228.9, If you are in the top 5% of the contest rating, you\u2019ll get the \u201cGuardian\u201d badge.</p> <p>If you are in the top 25% of the contest rating, you\u2019ll get the \u201cKnight\u201d badge.</p> Level Proportion Badge Rating LV3 5 \\(\\%\\) Guardian \u22652228.90 <p></p> LV2 20 \\(\\%\\) Knight \u22651842.73 <p></p> LV1 75 \\(\\%\\) - - - <p>For top 10 users (excluding LCCN users), your LeetCode ID will be colored orange on the ranking board. You'll also have the honor with you when you post/comment under discuss.</p>"},{"location":"contest/#rating-predictor","title":"Rating Predictor","text":"<p>Get your rating changes right after the completion of LeetCode contests, https://lccn.lbao.site</p>"},{"location":"contest/#reference","title":"Reference","text":"<ul> <li>Youtuber TLE Eliminator that updates weekly contest result</li> <li>Doocs\u793e\u533a\u7684leetcode contest solution</li> </ul>"},{"location":"contest/biweekly/","title":"Bi-Weekly History","text":"<p>biweekly 128</p> <p>2/4, \u7b2c\u4e09\u9898graph, \u6211\u8fd8\u6ca1\u5b66\u3002\u7b2c\u56db\u9898\u611f\u89c9\u662f\u4e2amonotonic queue, \u6211\u5f88close\u4e86\uff0c\u4f46\u662f\u6ca1\u5199\u51fa\u6765\u3002</p> number description solution 3110 Score of a String adjacency pair\u7684\u95ee\u9898 solution 3111 Minimum Rectangles to Cover Points simulation solution - - - 3113 Find the Number of Subarrays Where Boundary Elements Are Maximum monotonically decreasing queue solution <p>biweekly 127</p> <p>2/4, \u53ef\u60dc\u7684\u662f\u7b2c\u4e09\u9898\u662f\u6807\u51c6sliding window\u9898\u76ee\uff0c\u4e0d\u8fc7prefix-sum\u88ab\u66ff\u6362\u6210\u4e86<code>bit OR</code>\u7684\u64cd\u4f5c\u4ee5\u53canullify nums[left]. \u4e3a\u4e86\u80fd \u51c6\u786e\u7684nullify, \u9700\u8981\u7ef4\u62a4\u4e00\u4e2a32\u7684\u6570\u7ec4\u6765\u8bb0\u5f55\u6bcf\u4e2abit\u7684\u51fa\u73b0\u6b21\u6570.</p> number description solution 3095 shortest subarray with OR at least K I brute force solution 3096 Minimum Levels to Gain More Points prefix sum\u7684\u9898\u76ee solution 3097 Shortest Subarray with OR at Least K II sliding window, bit manipulation solution 3098 Find the Sum of Subsequence Powers"},{"location":"contest/biweekly/biweekly_124/","title":"Biweekly 124","text":"<p>2/4, \u8fd8\u662f\u9700\u8981\u52aa\u529b</p>","tags":["Dynamic Programming","Bucket Sort"]},{"location":"contest/biweekly/biweekly_124/#1-maximum-number-of-operations-with-the-same-score-i","title":"1 Maximum Number of Operations With the Same Score I","text":"<p>\u5f88\u7b80\u5355\u7684\u53cc\u6307\u9488\u9898\u76ee.</p> <pre><code>class Solution:\n    def maxOperations(self, nums: List[int]) -&gt; int:\n        left,right = 0,1\n        prev,curr = nums[left]+nums[right],0\n        ans = 0\n        while right &lt; len(nums):\n            curr = nums[left] + nums[right]\n            if curr != prev:\n                break\n            # if reach here, it's the same\n            ans += 1\n            prev = curr\n            left += 2\n            right += 2\n        return ans\n</code></pre>","tags":["Dynamic Programming","Bucket Sort"]},{"location":"contest/biweekly/biweekly_124/#2-apply-operations-to-make-string-empty","title":"2 Apply Operations to Make String Empty","text":"<p>\u6267\u884c\u7684operation\u662f\uff0c\u5220\u9664\u7b2c\u4e00\u4e2a\u9047\u5230\u768426\u4e2a\u82f1\u6587\u5b57\u7b26\uff0c\u7136\u540e\u95ee\uff0c\u5728string\u8fb9\u7a7a\u4e4b\u524d\uff0c\u6700\u540e\u4e00\u4e2a\u975e\u7a7a\u7684\u5b57\u7b26\u662f\u4ec0\u4e48\u3002\u5047\u8bben\u6b21operation, \u4f1a\u53d8\u6210<code>\"\"</code>, \u5176\u5b9e\u5c31\u662f\u6c42\u7b2cn\u6b21\u64cd\u4f5c\u5220\u9664\u4e86\u4ec0\u4e48.</p> <p>\u80fd\u7559\u5230\u6700\u540e\u7684\uff0c\u4e5f\u5fc5\u5b9a\u662f\u51fa\u73b0\u6b21\u6570\u6700\u591a\u7684\u5b57\u7b26. \u6211\u76f4\u63a5\u8054\u60f3\u5230bucket sort, \u5efa\u4e00\u4e2aauxillary array, \u7136\u540e\u4ece\u540e\u5f80\u524dtraverse\u627e\u5230\u7b2c\u4e00\u4e2a\u975e\u7a7a, \u7136\u540ebreak. \u8fd9\u4e00\u6b65\u53ea\u80fd\u4fdd\u8bc1\u6211\u4eec\u83b7\u5f97\u6700\u540e\u4e00\u4e2a\u975e\u7a7a\u7684string\u91cc\u6240\u6709char, \u4e0d\u4fdd\u8bc1\u987a\u5e8f\u3002\u5982\u679c\u4f60\u6700\u540e\u662f<code>abc</code>, \u90a3\u4e48\u6211\u7684\u68c0\u7d22\u7684\u7ed3\u679c\u4f1a\u662f<code>['a','c','b']</code> etc.</p> <p>\u600e\u4e48\u4fdd\u8bc1\u83b7\u5f97\u8fd9\u4e2a\u987a\u5e8f\u5462? \u6211\u53c8\u5efa\u4e86\u4e00\u4e2ahashmap, \u8bb0\u5f55last non-empty string\u4e2d\u6bcf\u4e2achar\u7684\u51fa\u73b0\u6b21\u6570\u3002\u7136\u540e\u4f60traverse string, \u5982\u679c\u8fd9\u4e2achar\u5728hashmap\u91cc\uff0c\u90a3\u4e48\u5c31\u51cf\u5c11\u6b21\u6570\uff0c\u5982\u679c\u6b21\u6570\u4e3a0\uff0c\u90a3\u4e48\u8fd9\u5c31\u4f1a\u662f\u6700\u540e\u4e00\u4e2a\u975e\u7a7a\u7684char.</p> <pre><code>from collections import defaultdict\nclass Solution:\n    def lastNonEmptyString(self, s: str) -&gt; str:\n        # create a hashmap for char:occurence\n        # based on occruence, do a bucket sort and traverse from the end\n        hashmap = defaultdict(int)\n        for c in s:\n            hashmap[c] += 1\n\n        buckets = [[] for _ in range(len(s)+1)]\n\n        for char,occurence in hashmap.items():\n            buckets[occurence].append(char)\n\n        # now, we traverse from the end\n        candidates = []\n        for count in range(len(buckets)-1,-1,-1):\n            if len(buckets[count]) != 0:\n                for item in buckets[count]:\n                    candidates.append(item)\n                break\n\n        # count will be the number of appearance, candidate will be \n        solution_map = dict()\n        for candidate in candidates:\n            solution_map[candidate] = count\n\n        # edge case\n        if count == 1:\n            return \"\".join(candidates)\n\n\n        # general case\n        res = []\n        for i in range(len(s)):\n            if s[i] in solution_map:\n                solution_map[s[i]] -= 1\n                if solution_map[s[i]] == 0:\n                    res.append(s[i])\n\n        return \"\".join(res)\n</code></pre>","tags":["Dynamic Programming","Bucket Sort"]},{"location":"contest/biweekly/biweekly_124/#3-maximum-number-of-operations-with-the-same-score-ii","title":"3 Maximum Number of Operations With the Same Score II","text":"<p>\u8fd9\u9898\u662f3040, \u4e5f\u662f\u7b2c\u4e00\u9898\u7684\u53d8\u79cd. \u4f46\u8fd9\u6b21\u6211\u4eec\u6269\u5bbd\u4e86operation\u7684\u5b9a\u4e49:</p> <ul> <li>choose the first two elements of <code>nums</code> and delete them</li> <li>choose the last two elements of <code>nums</code>  and delete them</li> <li>choose the first and the last elements of <code>nums</code> and delete them</li> </ul> <p>\u6c42\u6bcf\u6b21operation\u5f97\u5206\u90fd\u4e00\u6837\u65f6\u5019\uff0c\u6700\u591a\u80fd\u8fdb\u884c\u591a\u5c11\u6b21operation. \u679c\u7136\u5728\u6253\u6bd4\u8d5b\u7684\u65f6\u5019\uff0c\u5927\u5bb6\u90fd\u5148\u60f3\u51fa\u6765top-down. </p> <pre><code>class Solution:\n    def maxOperations(self, nums: List[int]) -&gt; int:\n        @cache\n        def f(arr,prev):\n            # base case\n            if len(arr)&lt;2:\n                return 0\n\n            # 3 possible\u53ef\u80fd\u6027\n            sm1=arr[0]+arr[1]\n            sm2=arr[-1]+arr[-2]\n            sm3=arr[0]+arr[-1]\n            ans=0\n\n            if prev == sm1:\n                ans = max(ans,1 + f(arr[2:],sm1))\n            if prev == sm2:\n                ans = max(ans,1 + f(arr[:-2],sm2))\n            if prev == sm3:\n                ans = max(ans,1 + f(arr[1:-1],sm3))\n\n            return ans\n\n        return max(f(tuple(nums[2:]),nums[0]+nums[1]),\n                   f(tuple(nums[:-2]),nums[-1]+nums[-2]),\n                   f(tuple(nums[1:-1]),nums[0]+nums[-1]))  + 1\n</code></pre>","tags":["Dynamic Programming","Bucket Sort"]},{"location":"contest/biweekly/biweekly_124/#4-maximize-consecutive-elements-in-an-array-after-modification","title":"4 Maximize Consecutive Elements in an Array After Modification","text":"<p>LC 3041, \u7ed9\u4f60\u4e00\u4e2a\u6570\u7ec4, \u6bd4\u5982<code>[2,1,5,1,1]</code>, \u4f60\u53ef\u4ee5\u7ed9any arbitrary number + 1, \u7136\u540e\u8ba9\u4f60\u6c42\u8fde\u7eed\u6700\u957f\u7684\u5b50\u6570\u7ec4\u7684\u957f\u5ea6. </p> <p>Example 1:</p> <pre><code>Input: nums = [2,1,5,1,1]\nOutput: 3\nExplanation: We can increase the elements at indices 0 and 3. The resulting array is nums = [3,1,5,2,1].\nWe select the elements [3,1,5,2,1] and we sort them to obtain [1,2,3], which are consecutive.\nIt can be shown that we cannot select more than 3 consecutive elements.\n</code></pre> <p>Example 2:</p> <pre><code>Input: nums = [1,4,7,10]\nOutput: 1\nExplanation: The maximum consecutive elements that we can select is 1.\n</code></pre> <p>\u8fd9\u9898\u6211\u4e00\u5f00\u59cb\u6709\u4e24\u4e2a\u601d\u8def:</p> <ul> <li>\u4e00\u4e2a\u662f\u6839\u636e\u6bcf\u4e00\u4e2avalue, \u5411\u53f3\u8f90\u6563\uff0c\u7136\u540e\u627e\u7b54\u6848\u3002\u4f46\u53d1\u73b0case\u4e0dgeneral, \u65e0\u6cd5\u6c42\u51fa</li> <li>\u8ba1\u7b97gap, \u7136\u540e\u627egap\u4e3a1\u7684\u90fd\u662ffillable\u7684</li> </ul> <p>\u4e24\u4e2a\u601d\u8def\u90fd\u4e0d\u5bf9, \u7528dp\u548cgap\u7684\u4e0d\u540c\u6765\u5206\u7c7b\u4f60\u7684\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b.</p>","tags":["Dynamic Programming","Bucket Sort"]},{"location":"contest/biweekly/biweekly_124/#approach-1-dp-by-lee","title":"Approach 1 DP by lee\u5927\u795e","text":"<p>\\(O(n) + O(nlogn)\\approx O(nlogn)\\) in time, O(n) in space.</p> <p>Lee is crazy, his Solution here</p> <p>Constraints:</p> <ul> <li><code>1 &lt;= nums.length &lt;= 10**5</code></li> <li><code>1 &lt;= nums[i] &lt;= 10**6</code></li> </ul> <p>\u6211\u4eec\u7684\u6570\u7ec4\u957f\u5ea6\u662f\\(10^5\\) and range is \\(10^6\\), \u6240\u4ee5\u6211\u4eec\u76f4\u63a5\u6784\u5efa\u4e00\u4e2a\u4e3a\\(10^6\\)\u4e3a\u957f\u5ea6\u7684hashmap (worst case scenario)\uff0c\u5b9a\u4e49\u6211\u4eec\u7684dp. </p> <p>Note</p> <p><code>dp[num]</code>:  maximum length of consecutive sequence ending with <code>num</code>. <code>num</code>\u662fdp array\u7684index, \u4e5f\u662fnums\u4e2d\u7684\u503c</p> <p>\u8fd9\u4e00\u6b65\u6700\u5173\u952e\u662fending, </p> <p>Note</p> <p>0 for all. </p> <p>Once we sort the array <code>nums</code>, each <code>num</code> in sorted <code>nums</code> can be updated like this </p> <ul> <li>we use <code>num</code> as <code>num</code> itself, \u56e0\u4e3a\u6211\u4eec\u53ef\u4ee5\u4e0d\u6539\u53d8, <code>dp[num] = dp[num-1] + 1</code></li> <li>we use <code>num</code> as <code>num + 1</code>, \u56e0\u4e3a\u6211\u4eec\u53ef\u4ee5\u52a01\uff0c\u6240\u4ee5 <code>dp[num+1] = dp[num] + 1</code></li> </ul> <p>\u4e5f\u5c31\u662f\u4e00\u9c7c\u4e24\u5403\uff0c\u4e00\u6b21\u53cc\u66f4\u65b0.</p> <pre><code>class Solution:\n    def maxSelectedElements(self, nums: List[int]) -&gt; int:\n        dp = collections.defaultdict(int)\n        nums.sort()\n        for num in nums:\n            # update use num as num + 1 with the increment\n            dp[num+1] = dp[num] + 1\n            # update use num as num as num without increment\n            dp[num] = dp[num-1] + 1\n\n        return max(dp.values())\n</code></pre>","tags":["Dynamic Programming","Bucket Sort"]},{"location":"contest/biweekly/biweekly_124/#q1-work","title":"Q1: \u4e3a\u4ec0\u4e48\u8fd9\u4e2a\u66f4\u65b0\u987a\u5e8fwork?","text":"<p>\u4f60\u5982\u679c\u6362\u4e00\u4e0b\u66f4\u65b0\u987a\u5e8f\uff0c\u5982\u4e0b\u6240\u793a\uff0c\u662f\u4e0d\u4f1awork\u7684. </p> <pre><code>class Solution:\n    def maxSelectedElements(self, nums: List[int]) -&gt; int:\n        dp = collections.defaultdict(int)\n        nums.sort()\n        for num in nums:\n            # update use num as num as num without increment\n            dp[num] = dp[num-1] + 1\n            # update use num as num + 1 with the increment\n            dp[num+1] = dp[num] + 1\n\n        return max(dp.values())\n</code></pre> <p>\u56e0\u4e3a\u8fd9\u4e00\u6b65\u7684\u66f4\u65b0\u662f\u76f8\u5bf9\u72ec\u7acb\u7684\uff0c\u4e5f\u5c31\u662f\u8bf4\uff0c\u4f60\u5148\u66f4\u65b0\u4e86<code>dp[num]</code>, \u4f60\u4e0b\u4e00\u4e2a\u516c\u5f0f\u53c8\u662f\u4f9d\u8d56\u4e8e<code>dp[num]</code>\u7684\u503c\uff0c\u6240\u4ee5\u4f60\u4e0d\u80fd\u5148\u66f4\u65b0<code>dp[num]</code>. \u8fd9\u4e24\u6b21\u66f4\u65b0\uff0c\u90fd\u662f\u4f9d\u8d56\u4e8e\u4e0a\u4e00\u4e2a\u65f6\u6b65.</p>","tags":["Dynamic Programming","Bucket Sort"]},{"location":"contest/biweekly/biweekly_124/#q2-01","title":"Q2 \u4e3a\u4ec0\u4e48\u521d\u59cb\u5316\u4e3a0\u800c\u4e0d\u662f1?","text":"<p>\u8fd9\u91cc\u5f88tricky\u7684\u70b9\u662f\uff0c\u4f60\u5982\u679c\u7406\u89e3ending with <code>num</code>, \u4f60\u53ef\u80fd\u81f3\u5c11\u4e3ainitialize\u4e3a0. \u4f46\u8fd9\u6837\u4f1a\u8ba9\u8ba1\u7b97\u590d\u6742\u5316. \u5047\u8bbe\u8fd9\u4e2a\u6570\u7ec4\u7684return\u4e3a0, \u6bd4\u5982<code>[1,4,7,10]</code>, \u90a3\u8d70\u8fc7\u4e00\u904d</p> <pre><code>for num in nums:\n    dp[num+1] = dp[num] + 1\n    dp[num] = dp[num-1] + 1\n</code></pre> <p>dp\u4f1a\u662f</p> <pre><code>{\n    \"1\":1,\n    \"2\":1,\n    \"4\":1,\n    \"5\":1,\n    \"7\":1,\n    \"8\":1,\n    \"10\":1,\n    \"11\":1\n}\n</code></pre> <p>\u5176\u5b9e\u5c31\u662f\u53d8\u5316\u4e4b\u540e\u7684\u4e5f\u8003\u8651\u5728\u91cc\u9762\u4e86, \u6bd4\u5982dp[2] == 1, \u4f46\u662f2\u4e0d\u5728nums\u91cc\u9762\u662f\u75311\u53d8\u5316\u800c\u6765\u7684. \u6240\u4ee5\u8fd9\u91cc\u521d\u59cb\u5316\u8bbe\u4e3a0 \u5373\u53ef.\u518d\u6765\u4e00\u6b21dry run for <code>[1,1,1,2,5]</code>, dry run\u7ed3\u679c\u4e3a\u4e0b\u56fe,</p> <p></p>","tags":["Dynamic Programming","Bucket Sort"]},{"location":"contest/biweekly/biweekly_124/#q3","title":"Q3: \u5982\u4f55\u4e0b\u6b21\u8fd8\u80fd\u60f3\u5230\u8fd9\u4e2a\u89e3\u6cd5?","text":"<p>\u8fd9\u4e2a\u89e3\u6cd5\u7684\u5173\u952e\u662f\uff0c\u4f60\u8981\u7406\u89e3ending with <code>num</code>, \u8fd9\u4e2a\u662f\u6700\u5173\u952e\u7684\u4e00\u6b65. \u4e4b\u540e\u6211\u4e5f\u65e0\u80fd\u4e3a\u529b\u3002\u4ed6\u5988\u7684\uff0cdp\u771f\u96be.\u753b\u4e2adecistion tree + \u5b9a\u4e49optimal substructure+ overlapping subproblem.</p> <p></p> <p>decision tree\u753b\u5b8c\u6e05\u6670\u591a\u4e86\u5427\uff0c\u4e3a\u4ec0\u4e48\u6211\u4eec\u662f\u4f9d\u8d56\u4e8e\u4e0a\u4e00\u4e2a\u65f6\u6b65\u7684\u503c\uff0c\u6240\u4ee5\u6211\u4eec\u4e0d\u80fd\u5148\u66f4\u65b0<code>dp[num]</code>, \u800c\u662f\u5148\u66f4\u65b0<code>dp[num+1]</code>.</p> <p>Then, </p> <ul> <li><code>optimal substructure</code>: \u6c42\u8fd9\u4e2a\u95ee\u9898, <code>[1,4,9,14]</code>\u7684\u89e3\uff0c\u53ef\u4ee5\u901a\u8fc7\u6c42<code>[1,4,9]</code>\u7684\u89e3\uff0c\u4ee5\u6b64\u7c7b\u63a8\u7684\u5b50\u95ee\u9898\u5230base case <code>[1]</code>\u5417? \u53ef\u4ee5\u7684</li> <li><code>overlapping subproblem</code>: \u6bcf\u4e2asubproblem, \u90fd\u5305\u542b\u4e86base case? Yes. \u6240\u4ee5\u8fd9\u9898\u62e5\u6709overlapping subproblem.</li> </ul>","tags":["Dynamic Programming","Bucket Sort"]},{"location":"contest/biweekly/biweekly_124/#space-optimized","title":"Space optimized","text":"<p>can you try?</p>","tags":["Dynamic Programming","Bucket Sort"]},{"location":"contest/weekly/","title":"Weekly History","text":"<p>weekly 396</p> number description solution 3136 Valid Word set some flags and one-pass scan solution 3137 Minimum Number of Operations to make word k-periodic frequency map of each segment,\u627e\u5230\u6700\u5927\u9891\u7387\u7684\u5b57\u6bb5<code>word[i:i+k]</code> solution 3138 Minimum Length of Anagram Concatenation \u627e\u5230\u4e00\u4e2astring\u4e2d\u7684\u6700\u957fanagram, \u7b49\u4ef7\u5728\u6240\u6709char\u7684\u9891\u7387hash\u8868\u91cc\uff0c\u627e\u5230\u9891\u7387\u7684gcd(greatest common divisor) solution 3139 Minimum Cost to Equalize Array - - <p>weekly 392</p> number description solution 3105 Longest Strictly Increasing or Strictly Decreasing Subarray \u7ef4\u62a4\u4e24\u4e2a<code>int</code>\u6765\u8ba1\u7b97\u5f53\u524d\u4e3a\u6b62\u6700\u957f\u7684\u4e25\u683c\u5355\u8c03\u9012\u589e\u548c\u9012\u51cf\u6570\u7ec4 solution 3106 Lexicographically Smallest String After Operations With Constraint \u4ece\u5de6\u5230\u53f3\u7684\u7ed9<code>s</code>\u6574\u5bb9\uff0c\u6bcf\u6b21\u6574\u5bb9\u5148\u4ece<code>a</code>\u6574\u5230<code>z</code>. \u9700\u8981\u505a\u4e2a\u8ba1\u7b97distance\u7684helper function. solution 3107 Minimum Operations to Make Median of Array Equal to K \u6392\u5e8f\u540e\uff0cvertical line for <code>y = k</code>, \u7136\u540e\"\u79fb\u52a8\"\u6570\u7ec4\u8ba9<code>y=k</code>\u81f3\u5c11\u6b63\u597d\u6709\u8d85\u8fc7\u6570\u7ec4\u4e00\u534a\u7684\u6570 solution 3108 Minimum Cost Walk in Weighted Graph - - <p>weekly 391</p> number description solution 3099 Harshad Number simple math solution 3100 Water Bottles II simulation, drinking phase + exchange phase solution 3101 Count Alternating Subarrays sliding window solution 3102 Minimize Manhattan Distances - - <p>weekly 352</p> number description solution 2760 Longest Even Odd Subarray with Threshold 2761 Prime Pairs with Target Sum 2762 Continuous Subarray 2763 Sum of inbalance number of all subarrays <p>weekly 351</p> number description solution 2748 Number of Beautiful Pairs - solution 2749 Minimum Operations to make the integer zero - - 2750 Ways to Split Array into Good Subarrays - - 2751 Robot Collisions - - <p>Weekly 350</p> <p>First time join contest, got 0/4. Attend virtual, after 2 months of grinding, got 2/4.</p> number description solution 2739 Total Distance Traveled very simulation, math solution 2740 Find the Value of the Partition sort + brute force solution 2741 Special Permutation dp + bitmask - 2742 Painting the Walls - -"},{"location":"contest/weekly/weekly_385/","title":"Weekly 385","text":"<p>1/4, \u5c31\u505a\u51fa\u7b2c\u4e00\u9898. </p> <p></p>"},{"location":"contest/weekly/weekly_385/#1-count-prefix-and-suffix-pairs","title":"1 Count Prefix and Suffix Pairs","text":"<p>\u7ed9\u5b9a\u4e00\u4e2a\u6570\u7ec4\u6bd4\u5982, <code>words = [\"pa\",\"papa\",\"ma\",\"mama\"]</code>, \u6c42\u89e3\u5176\u4e2d\u6709\u591a\u5c11\u4e2apairs, \u6ee1\u8db3 i &lt; j, and words[i] is a prefix and a suffix of words[j]. \u4f8b\u5982,  <pre><code>Input: words = [\"pa\",\"papa\",\"ma\",\"mama\"]\nOutput: 2\nExplanation: In this example, the counted index pairs are:\ni = 0 and j = 1 because isPrefixAndSuffix(\"pa\", \"papa\") is true.\ni = 2 and j = 3 because isPrefixAndSuffix(\"ma\", \"mama\") is true.\nTherefore, the answer is 2.  \n</code></pre></p> <p>\u601d\u8def\u5982\u4e0b\uff0c</p> <ul> <li>\u5199\u4e00\u4e2ahelper function, \u5224\u65ad\u4e24\u4e2aword_1\u662f\u5426\u662fword_2\u7684\u524d\u7f00\u548c\u540e\u7f00\uff0clike <code>is_prefix_suffix(word_1,word_2)</code></li> <li>\u679a\u4e3e\u6240\u6709\u7684i,j pair, \u540c\u65f6\u6ee1\u8db3helper function\u4ee5\u53ca<code>i &lt; j</code></li> </ul> <p>\u590d\u6742\u5ea6\u5206\u6790</p> <p>\u65f6\u95f4\u590d\u6742\u5ea6\u662f\\(O(n^2m)\\), \u7a7a\u95f4\u590d\u6742\u5ea6\u662f\\(O(1)\\), \u5176\u4e2d\\(n\\)\u662fwords array\u7684\u957f\u5ea6\uff0c\\(m\\)\u662fword\u7684\u957f\u5ea6</p> <pre><code>class Solution:\n    def countPrefixSuffixPairs(self, words: List[str]) -&gt; int:\n        def helper(word_1,word_2):\n            if len(word_1) &gt; len(word_2):\n                return False\n\n            left,right = 0,-1            \n            for _ in range(len(word_1)):\n                if word_1[left] != word_2[left]:\n                    return False                \n                if word_1[right] != word_2[right]:\n                    return False\n\n                right -= 1\n                left += 1\n            # if reach here\n            return True\n\n        # do something instead\n        n = len(words)\n        res = 0\n        for i in range(n):\n            for j in range(i+1,n):\n                if helper(words[i],words[j]):\n                    res += 1    \n\n        return res\n</code></pre>"},{"location":"contest/weekly/weekly_385/#2-find-the-length-of-the-longest-common-prefix","title":"2 Find the Length of the Longest Common Prefix","text":"<p>\u5148\u770b\u4f8b\u5b50,  <pre><code>Input: arr1 = [1,10,100], arr2 = [1000]\nOutput: 3\nExplanation: There are 3 pairs (arr1[i], arr2[j]):\n- The longest common prefix of (1, 1000) is 1.\n- The longest common prefix of (10, 1000) is 10.\n- The longest common prefix of (100, 1000) is 100.\nThe longest common prefix is 100 with a length of 3.\n</code></pre></p> <p>\u7ed9\u4e24\u4e2a\u6570\u7ec4\uff0c\u6bcf\u4e2a\u6570\u7ec4\u5206\u522b\u53d6\u4e00\u4e2a\u6210\u4e3a\u4e00\u4e2apair, \u7136\u540e\u6c42\u89e3\u6240\u6709pairs\u4e2d\uff0clongest common prefix\u7684\u957f\u5ea6. \u6211\u7684\u601d\u8def\u662f(TLE\u4e86),</p> <ul> <li>\u4e00\u4e2ahelper function \u6c42length of the common prefix of two numbers, <code>common_prefix_length(num1,num2)</code></li> <li>\u7136\u540e\u679a\u4e3e\u6240\u6709\u7684pair, \u6c42\u89e3\u6700\u957f\u7684prefix</li> </ul> <pre><code>class Solution:\n    def longestCommonPrefix(self, arr1: List[int], arr2: List[int]) -&gt; int:\n        def helper(int_1,int_2):\n            word_1,word_2 = str(int_1),str(int_2)\n            res = 0\n\n            for i in range(min(len(word_1),len(word_2))):\n                if word_1[i] != word_2[i]:\n                    return res\n                res += 1\n\n            return res\n\n        best = 0\n\n        for i in range(len(arr1)):\n            for j in range(len(arr2)):\n                candidate = helper(arr1[i],arr2[j])\n                best = max(best,candidate)\n        return best\n</code></pre> <p>\u4f46\u8fd9\u4e2a\u65b9\u6cd5TLE, \u7b54\u6848\u5982\u4e0b.</p> 3043 Find the Length of the Longest Common Prefix <p>\u7528\u4e24\u4e2ahashset\u5206\u522b\u50a8\u5b58arr1\u548carr2\u7684\u6240\u6709\u53ef\u80fd\u7684prefix, \u7136\u540e\u53d6\u4ea4\u96c6\uff0c\u6700\u540e\u6c42\u89e3\u6700\u957f\u7684prefix. Solution here.</p>"},{"location":"contest/weekly/weekly_385/#3-most-frequent-prime","title":"3 Most Frequent Prime","text":""},{"location":"contest/weekly/weekly_385/#4-count-prefix-and-suffix-pairs-ii","title":"4 Count Prefix and Suffix Pairs II","text":""},{"location":"data_structure/","title":"Data Structure","text":"<p>Computer science is all about state and manipulation of state. State is stored in a certain way and structure, and that's what we call <code>data structure</code>. </p>"},{"location":"data_structure/heap/","title":"Heap (\u5806)","text":""},{"location":"data_structure/heap/#heap_1","title":"Heap\u7684\u5b9a\u4e49","text":"<p>Heap is a special type of tree that</p> <ul> <li>Complete Binary Tree: all levels are filled except possibly the last level and filled from left to right. \u4e3a\u4ec0\u4e48\u9700\u8981\u8fd9\u4e2a\u6761\u4ef6\u5462\uff1f\u56e0\u4e3a\u8fd9\u6837\u53ef\u4ee5\u7528\u6570\u7ec4\u6765\u8868\u793aheap\uff0c\u5177\u4f53\u770b\u4e0b\u4e00\u4e2a\u6027\u8d28.</li> <li>parent-child relationship: For a parent node at index <code>i</code> and its child nodes at index <code>2i+1</code> and <code>2i+2</code> (0-based index). \u8fd9\u4e2a\u6027\u8d28\u662f\u4e3a\u4e86\u65b9\u4fbf\u7528\u6570\u7ec4\u6765\u8868\u793aheap, \u89c1Python.</li> <li>Heap Property: The maximum or minimum is always at the root. Also, value of each node is greater than or equal to the value of its children (max heap) or less than or equal to the value of its children (min heap)</li> </ul> <p>Let's take a look at min heap to see how it works.</p> <pre><code>        1\n      /   \\\n     2     3\n    / \\   / \\\n   4   5 6   7\n</code></pre> <p>Each child is greater than or equal to its parent. The root is the smallest value. It also satisfies the complete binary tree property. If we represent it in array, it would be</p> <pre><code>nums = [1 2 3 4 5 6 7]\n</code></pre> <p>Note</p> <p><code>priority queue</code> is an abstract data structure like a blueprint while <code>heap</code> is a concrete implementation of priority queue. It can be min-heap or max-heap. Ppl usually use both terms interchangeably.</p> <p>\u9009\u62e9heap\u7684\u4e3b\u8981\u539f\u56e0\u662f\u5176</p> <ul> <li>Get the max/min value\u6bd4\u8f83\u5feb. \u5bf9\u4e8e\u4e00\u4e9b\u9700\u8981\u9891\u7e41\u83b7\u53d6\u6700\u5927\u6700\u5c0f\u503c\u7684\u573a\u666f\uff0cheap\u662f\u5f88\u597d\u7684candidate. \u65f6\u95f4\u590d\u6742\u5ea6\u4e3a\\(O(1) + O(\\log n)\\approx O(\\log n)\\). \u5c5e\u4e8e<code>heappop()</code>\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u3002</li> <li>For insertion, it's \\(O(\\log n)\\), which is also pretty good.</li> </ul> <p>Tip</p> <p>\u4e3a\u4ec0\u4e48<code>heappop()</code>\u590d\u6742\u5ea6\u4e3aO(1) + O(log n)? \u56e0\u4e3a<code>heappop()</code>\u662f\u5148pop\u51fa\u6765\uff0c\u7136\u540e\u4e3a\u4e86maintain heap property, \u518d\u8c03\u6574heap\u7684\u7ed3\u6784\uff0c\u540e\u8005\u65f6\u95f4\u590d\u6742\u5ea6\u662f\\(O(\\log n)\\). \u8c03\u6574heap property\u662f\u4e24\u90e8\u66f2, \u4f60pop\u8d70\u4e86\uff0c\u7f3a\u4e2aroot, \u4f60\u5148</p> <ul> <li>replace the root with the last element in the heap</li> <li>sift down the root node to maintain the heap property \\(O(h) = O(\\log n)\\)</li> </ul>"},{"location":"data_structure/heap/#heap_2","title":"Heap\u7684\u5e94\u7528\u573a\u666f","text":"<p>\u6709\u4ee5\u4e0b\u51e0\u4e2a\u5e94\u7528\u573a\u666f:</p> <ul> <li><code>jira ticketing system</code>: the ticket with the highest priority is always at the top. \u8fd9\u5176\u5b9e\u5c31\u662f\u4e00\u79cdpriority queue\u7684\u5e94\u7528.</li> <li><code>patient scheduling</code>: the patient with the most severe condition is always at the top, \u5e76\u4e0d\u4e00\u5b9a\u662ffirst come first serve.</li> </ul> Heap for Python Dev <p>If you using python, you just need to remember <code>from heapq import heapify, heappush, heappop</code> to use min heap. The syntax are - <code>heapify(list)</code>: convert a list into a heap - <code>heappush(heap, item)</code>: push an item onto the heap - <code>heappop(heap)</code>: pop the smallest item from the heap Python doesn't implement max heap by default but the hacky way would be pass in a negative version of the list to the heap and then pop it out and negate it.</p>"},{"location":"data_structure/heap/#heap_3","title":"Heap\u627e\u513f\u5b50\u548c\u7238\u5988","text":"<p>Heap\u7684\u4e00\u4e2a\u91cd\u8981\u6027\u8d28\u662f\uff0c\u53ef\u4ee5\u7528\u6570\u7ec4\u6765\u8868\u793aheap. \u4e3a\u4ec0\u4e48\u5462\uff1f\u56e0\u4e3aheap\u662fcomplete binary tree, \u6240\u4ee5\u53ef\u4ee5\u7528\u6570\u7ec4\u6765\u8868\u793a, \u4e5f\u5c31\u662f\u6ee1\u8db3\u5982\u679c\u4f60\u77e5\u9053parent node's index, you can find its children's index.</p> <p>$$ \\begin{align} l_{left} = 2i_p+1 \\ l_{right} = 2i_p+2 \\end{align} $$ where \\(i_p\\) is the parent's index, \\(l_{left}\\) is the left child's index, and \\(l_{right}\\) is the right child's index.</p> <p>\u601d\u8003\u9898</p> <p>\u6240\u6709\u7684sorted array\u90fd\u662fheap\u5417\uff1f\u6240\u6709\u7684heap\u90fd\u662fsorted array\u5417\uff1f</p> \u601d\u8003\u9898\u7b54\u6848 <p>\u6240\u6709\u7684sorted array\u90fd\u662fheap, \u4f46\u662f\u6240\u6709\u7684heap\u90fd\u4e0d\u662fsorted array. \u56e0\u4e3asorted array, \u80af\u5b9a\u6ee1\u8db3\u513f\u5b50\u6bd4\u7238\u7238\u5927\u7684\u6027\u8d28\u3002sorted array\u7684constrains\u5f3a\u4e00\u4e9b, \u76f8\u5f53\u4e8e\u8fd8\u8981\u6c42heap\u7684\u6bcf\u4e00\u5c42\uff0c\u5e73\u8f88\u7684\uff0c\u4ece\u5de6\u5230\u53f3\u90fd\u662f\u6709\u5e8f\u7684\uff0c\u8fd9\u4e2a\u6027\u8d28\u4e0d\u80fd\u4fdd\u8bc1\u6240\u6709\u7684heap\u90fd\u80fd\u6ee1\u8db3.</p> <p>On the other hand, if you know the child's index, you can find its parent's index by</p> <p>$$ \\begin{equation} i_p = \\lfloor \\frac{i_c-1}{2} \\rfloor \\end{equation} $$ where \\(i_c\\) is the child's index (can be both left or right child)</p>"},{"location":"data_structure/heap/#_1","title":"\u76f8\u5173\u9898\u76ee","text":"<p>Heap\u7684\u9898\u76ee\u4e3b\u8981\u6709\u4ee5\u4e0b\u51e0\u7c7b:</p> <ul> <li>The top k problem</li> <li>The k-th largest/smallest element problem</li> <li>Heap sort (\u4e0d\u8003)</li> </ul> <p>\u6216\u8005\u770b\u89c1\u5173\u952e\u8bcd, smallest, largest, minimal or maximal, top k, k-th, \u5c31\u53ef\u4ee5\u8003\u8651\u7528heap\u4f5c\u4e3a\u5907\u9009\u65b9\u6848\u4e4b\u4e00.</p> <ul> <li>215 Kth Largest Element in an Array and solution.</li> <li>973 K Closest Points to Origin and solution.</li> </ul>"},{"location":"data_structure/heap/#references","title":"References","text":"<p>\u8fd9\u91cc\u9644\u4e0a\u4e00\u4e2a\u5168\u5bb6\u798f, \u5237LC\u53ea\u9700\u8981\u77e5\u9053binary heap\u5c31\u8db3\u591f\u4e86.</p> <pre><code>flowchart TD\n    A[Priority Queue]\n    B[Binary Heap]\n    B_1[Min Heap]\n    B_2[Max Heap]\n    C[Binomial Heap]\n    D[Fibonacci Heap]\n\n    A --&gt; B &amp; C &amp; D\n    B --&gt; B_1 &amp; B_2</code></pre> <ul> <li>geek4geek, good explanation</li> </ul>"},{"location":"data_structure/heap/heapify/","title":"Heapify is Linear?","text":"<p>It always bugs me why heapify or build heap is <code>O(n)</code> but heap sort is <code>O(nlogn)</code>. Look at the following python heapq API, </p> <p></p>"},{"location":"data_structure/heap/heapify/#sift-up-and-sift-down","title":"Sift Up and Sift Down","text":"<p>\u5148\u6765\u4ecb\u7ecd\u4e00\u4e0bheap\u7684\u57fa\u672c\u64cd\u4f5c\uff0csift up and sift down.\u8fd9\u4e24\u4e2aoperation\u662fheap\u91cc\u505a\u4efb\u4f55\u64cd\u4f5c\u7684\u57fa\u7840\uff0c\u7528\u4e8e\u5b9e\u73b0insertion and deletion while maintaining the heap property and complete binary tree property.</p> <p>Remember, min heap\u6709\u4e24\u4e2aproperty, complete binary tree and heap property. \u8fd9\u4e5f\u5c31\u610f\u5473\u7740, \u5f53\u4f60\u63d2\u5165\u7684\u65f6\u5019\uff0c\u5fc5\u7136\u662f\u4ece\u4e0a\u81f3\u4e0b\uff0c\u4ece\u5de6\u81f3\u53f3\u7684\u63d2\u5165. \u63d2\u5165\u4e4b\u540e\u7684newly inserted node, \u8981\u6162\u6162\u7684\u5f80\u4e0a\u6d6e\uff0c\u76f4\u5230\u6ee1\u8db3heap property. \u8fd9\u4e2a\u8fc7\u7a0b\u53eb\u505a<code>sift up</code>, \u4f60sift up\u7684\u8fc7\u7a0b\uff0c\u662f\u548c\u81ea\u5df1parent\u6bd4\u5927\u5c0f\uff0c\u5982\u679c\u6bd4parent\u5c0f\uff0c\u5c31\u548cparent swap to maintain the heap property. \u8fd9\u4e2a\u8fc7\u7a0b\u662f<code>O(logn)</code>.</p> <p>Sift down is the opposite of sift up. \u5f53\u4f60\u5220\u9664\u4e00\u4e2anode\u7684\u65f6\u5019\uff0c\u4f60\u8981\u628a\u6700\u540e\u4e00\u4e2anode\u653e\u5230root\u7684\u4f4d\u7f6e\uff0c\u7136\u540e\u6162\u6162\u7684\u5f80\u4e0b\u6c89\uff0c\u76f4\u5230\u6ee1\u8db3heap property. \u8fd9\u4e2a\u8fc7\u7a0b\u662f<code>O(logn)</code>. \u6709\u4e9b\u8bb8\u4e0d\u540c\u7684\u662f\uff0c\u4f60\u6c38\u8fdc\u6709\u4e24\u4e2achild, \u53ea\u8981parent\u6bd4<code>min(child1, child2)</code>\u8981\u5c0f\uff0c\u5c31\u5f80\u66f4\u5c0f\u7684\u90a3\u4e2achildren swap.</p> <p>So, we summarize what we have so far</p> operation sift up sift down Insertion \\(O\\log(n)\\) N/A Deletion N/A \\(O\\log(n)\\)"},{"location":"data_structure/heap/heapify/#heapify-with-sift-up-and-sift-down","title":"Heapify with Sift Up and Sift Down","text":"<p>\u6709\u4e24\u79cd\u65b9\u6cd5\u5b9e\u73b0heapify, </p> <ul> <li><code>sift up</code> method: \u5c06\u6240\u6709nodes\u90fd\u6765\u4e00\u904dsift up. \u8fd9\u4e2a\u65b9\u6cd5\u662f<code>O(nlogn)</code>.</li> <li><code>sift down</code> method: \u4ece\u6700\u540e\u4e00\u4e2anode\u7684parent\u5f00\u59cb\uff0c\u628a\u6240\u6709\u7684non-leaf nodes, \u90fd\u6765\u4e00\u904dsift down. \u8fd9\u4e2a\u65b9\u6cd5\u662f<code>O(n)</code>.</li> </ul> <p>\u539f\u56e0\u662f\uff0cleaf nodes\u7531\u4e8e\u6ca1\u6709children nodes, \u6240\u4ee5\u81ea\u52a8\u6ee1\u8db3heap property. \u6839\u636e\u8fd9\u4e00\u7279\u70b9\uff0csift down is cheaper.</p> <p>\u4e00\u8bed\u60ca\u9192\u68a6\u4e2d\u4eba</p> <p>root only has 1 node but bottom layer (leaf nodes) has half of the nodes. It makes sense to sift down since we are checking half of what we would have to check if we sift up.</p> <p>\u6211\u4eec\u6765\u770b\u56fe, for sift up, \u6211\u4eec\u628a\u6240\u6709\u7684non-root nodes\u90fd\u6765\u4e00\u904dsift up, \u8fd9\u4e2a\u8fc7\u7a0b\u662f<code>O(nlogn)</code>. </p> <p></p> <p>sift up\u4e2d\u6bcf\u4e00\u5c42\u7684\u64cd\u4f5c\u6570\u91cf\u90fd\u6ee1\u8db3\uff0c\u5f53\u524d\u5c42\u7684nodes\u6570\u91cf\u548c\u5230root\u7684\u8ddd\u79bb\u7684\u4e58\u79ef. For a heap of size 31, \u603b\u8ba198\u6b21\u64cd\u4f5c.</p> <p>\u518d\u6765\u770b\u770bsift down, \u5c06\u6240\u6709\u7684non-leaf nodes\u90fd\u6765\u4e00\u904dsift down, \u8fd9\u4e2a\u8fc7\u7a0b\u662f<code>O(n)</code>.</p> <p></p> <p>sift down\u4e2d\uff0c\u6bcf\u4e00\u5c42\u7684\u64cd\u4f5c\u6570\u91cf\u90fd\u6ee1\u8db3\uff0c\u5f53\u524d\u5c42\u7684nodes\u6570\u91cf\u548c\u5230bottom\u7684\u8ddd\u79bb\u7684\u4e58\u79ef. For a heap of size 31, \u603b\u8ba126\u6b21\u64cd\u4f5c.</p> <p>\u90a3\u4e3a\u4ec0\u4e48\u4f1a\u6709\u8fd9\u4e48\u5927\u7684\u5dee\u522b\u5462\uff1f\u4e3b\u8981\u7531\u4e8e\u8fd9\u70b9:</p> <p>heap is more dense at bottom: \u7531\u4e8eheap\u662fcomplete binary tree, \u6240\u4ee5bottom layer\u7684nodes\u6570\u91cf\u662f\u6700\u591a\u7684, \u5982\u679c\u5b9a\u4e49\u4e00\u4e2a\u5bc6\u5ea6\\(\\rho\\), \u8d8a\u5f80\u4e0b\u7684\u5bc6\u5ea6\u8d8a\u9ad8. \u7531\u4e8e\u5e95\u90e8\u5bc6\u5ea6\u9ad8\uff0c\u9020\u5c31\u4e86leaf nodes\u7684\u6570\u91cf\u662fnon-leaf nodes\u7684\u4e24\u500d.</p> <p>\u8fd9\u5bfc\u81f4\u4e86\u8d8a\u4e0b\u9762\u7684nodes,\u4e0d\u4ec5\u6570\u91cf\u591a\uff0c\u800c\u4e14\u8ddd\u79bbroot\u7684\u8ddd\u79bb\u4e5f\u66f4\u8fdc\uff0c\u4f46\u8ddd\u79bbleaf nodes\u7684\u8ddd\u79bb\u5374\u662f\u66f4\u8fd1\u7684. \u8ba9\u6211\u4eec\u6765\u5b9a\u4e49\u4e00\u4e2a\\(\\bar{d}\\) \u4ee3\u8868\u7740\u6bcf\u4e00\u4e2anodes\u6240\u9700\u8981swap\u7684\u5e73\u5747\u8ddd\u79bb\u3002\u6240\u4ee5\u8bf4sift down\u5360\u5c3d\u4e86\u5929\u65f6\u5730\u5229\u4eba\u548c:</p> <ul> <li>\u4ece\u6570\u91cf\u4e0a\u6765\u8bf4\uff0csift down\u53ea\u9700\u8981\u5904\u7406\u4e00\u534a\u7684nodes.</li> <li>\u4ece\u8ddd\u79bb\u4e0a\u6765\u8bf4\uff0csift down\u4e2d\uff0c<ul> <li>\u66f4\u591anodes\u6240\u5728\u7684\u5e95\u5c42\uff0c\u53ea\u9700\u8981\u8d70\u5230leaf nodes\uff0c\u5e73\u5747\u4e0b\u6765\u6bcf\u4e2anodes\u8981\u8d70\u7684\u8ddd\u79bb\u8fd8\u5c0f.</li> <li>\u8f83\u5c11nodes\u6240\u5728\u7684\u4e0a\u5c42, \u7a0d\u5fae\u82e6\u4e00\u70b9\uff0c\u8d70\u5230\u5e95\u90e8\u8ddd\u79bb\u8f83\u8fdc\uff0c\u4f46\u662f\u6570\u91cf\u5c11\uff0c\u6240\u4ee5\u603b\u4f53\u6765\u8bf4\uff0c\u8fd8\u4e0d\u9519</li> </ul> </li> </ul> <p>sift down\u7b97\u662f\u6bd4\u8f83\u53cb\u5584\u7684\u7ed3\u6784\uff0c\u5927\u591a\u6570\u4eba\u5403\u70b9\u5c0f\u82e6\uff0c\u5c11\u6570\u4eba\u5403\u5927\u82e6, \\(\\bar{d}_{siftdown}\\) \u6bd4\u8f83\u5c0f\u3002\u518d\u6765\u770b\u770bsift up</p> <ul> <li>\u4ece\u6570\u91cf\u4e0a\u6765\u8bf4\uff0csift up\u9700\u8981\u5904\u7406\u6240\u6709\u7684nodes - 1. \u53ea\u6709root node\u4e0d\u9700\u8981\u5904\u7406.</li> <li>\u4ece\u8ddd\u79bb\u4e0a\u6765\u8bf4\uff0csift up\u4e2d\uff0c<ul> <li>\u66f4\u591a\u7684nodes\u6240\u5728\u7684\u5e95\u5c42\uff0c\u9700\u8981\u8d70\u5230root, \u8ddd\u79bb\u8f83\u8fdc. \u600e\u4e48\u8bf4\uff0c\u6211\u4e0d\u4ec5\u6570\u91cf\u591a\uff0c\u6211\u8d70\u7684\u8fd8\u8fdc</li> <li>\u8f83\u5c11\u7684nodes\u6240\u5728\u7684\u4e0a\u5c42\uff0c\u8d70\u5230root\u8ddd\u79bb\u8f83\u8fd1\uff0c\u4f46\u662f\u6570\u91cf\u5c11\uff0c\u6240\u4ee5\u603b\u4f53\u6765\u8bf4\uff0c\u8fd8\u4e0d\u9519</li> </ul> </li> </ul> <p>sift up\u5c31\u4e0d\u4e00\u6837\u4e86\uff0c\u5927\u591a\u6570\u4eba\u5403\u5927\u82e6\uff0c\u5c11\u6570\u4eba\u5403\u70b9\u5c0f\u82e6\u3002 \\(\\bar{d}_{siftup}\\) \u6bd4\u8f83\u5927, \u4e0d\u5408\u7406\u3002</p> <p>\u7efc\u5408\u6bd4\u8f83\u4e00\u4e0b\uff0csummarize it here</p> - # of nodes for operation \\(\\bar{d}\\) sift up \\(n-1\\) \u6bcf\u4e2anodes\u8981\u8d70\u7684\u5e73\u5747\u8ddd\u79bb\u8f83\u5927 sift down \\(\\approx \\frac{n}{2}\\) \u6bcf\u4e2anodes\u8981\u8d70\u7684\u5e73\u5747\u8ddd\u79bb\u8f83\u5c0f <p>\u7efc\u4e0a\u6240\u8ff0\uff0csift down \u4e0d\u4ec5\u6570\u91cf\u4e0a\u66f4\u53cb\u597d\uff0c\u800c\u4e14\u6bcf\u4e2anode\u8981\u8d70\u7684\u8ddd\u79bb\u4e0a\u4e5f\u66f4\u53cb\u597d\uff0c\u6240\u4ee5heapify with sift down is <code>O(n)</code>.</p>"},{"location":"data_structure/heap/heapify/#mathematical-proof","title":"Mathematical Proof","text":""},{"location":"data_structure/heap/heapify/#sift-down","title":"Sift Down","text":"<p>\u6211\u4eecintuitively understand why sift down is faster than sift up. \u4f46\u662f\u6211\u4eec\u8fd8\u662f\u9700\u8981\u4e00\u4e2a\u6570\u5b66\u8bc1\u660e\u6765\u8bc1\u660e\u8fd9\u4e00\u70b9. \u5148\u6765\u770b\u770bsift down\u7684\u90a3\u5f20\u56fe\uff0c\u6211\u4eec\u628a\u65b9\u7a0b\u53f3\u8fb9\u7684\u90e8\u5206\u7d2f\u52a0\u5728\u4e00\u8d77\u627e\u89c4\u5f8b, <pre><code># distance to bottom x number of nodes (from bottom to top)\n(1 * 8) + (2 * 4) + (3 * 2) + (4 * 1) = 26\n</code></pre> \u5047\u8bbe\u603b\u8ba1\u6709\\(n\\)\u4e2anodes, \u518dgeneralize\u4e00\u4e0b\uff0c\u8003\u8651bottom layer <pre><code>(0 * n/2) + (1 * n/4) + (2 * n/8) + ... + (h * 1) = n\n</code></pre> where \\(h = \\log_2(n)\\).</p> <p>We generalize the above equation into a more compact series, </p> \\[ \\begin{align} 1 \\cdot \\frac{1}{4} + 2 \\cdot \\frac{1}{8} + 3 \\cdot \\frac{1}{16} + ... + h \\cdot 1 &amp;= \\sum_{k=1}^{h} \\frac{kn}{2^{k+1}} \\\\ &amp;= \\frac{n}{4}\\sum_{k=1}^{h} \\frac{k}{2^{k-1}} &lt; \\frac{n}{4}\\sum_{k=1}^{\\infty} \\frac{k}{2^{k-1}}\\\\ \\end{align} \\] <p>And then, \u6211\u4eec\u63d0\u53d6\u5bfc\u6570\u7b26\u53f7\u540e\uff0c\u5f97\u5230\u65e0\u9650\u7ea7\u6570\u7684\u90e8\u5206\uff0c</p> \\[ \\begin{align} \\frac{n}{4}\\sum_{k=1}^{\\infty} \\frac{k}{2^{k-1}} &amp;= \\frac{n}{4}\\sum_{k=1}^{\\infty}kx^{k-1}\\quad x = \\frac{1}{2} \\\\ &amp;= \\frac{n}{4}\\frac{d}{dx}\\sum_{k=1}^{\\infty}x^k \\\\ &amp;= \\frac{n}{4}\\frac{d}{dx}\\left(\\frac{x}{1-x}\\right) \\\\ &amp;= \\frac{n}{4}\\frac{1}{(1-x)^2} \\\\ &amp;= \\frac{n}{4}\\frac{1}{(1-\\frac{1}{2})^2} \\\\ &amp;= n\\\\ \\end{align} \\]"},{"location":"data_structure/heap/heapify/#summary","title":"Summary","text":"<p>\u8fd9\u4e00\u7ae0\u6211\u4eec\uff0c</p> <ul> <li>\u4ecb\u7ecd\u4e86sift up and sift down in heap</li> <li>\u6bd4\u8f83\u4e86sift up and sift down\u7684\u5728heapify\u7684\u65f6\u95f4\u590d\u6742\u5ea6</li> <li>\u7528\u6570\u5b66\u8bc1\u660e\u4e86sift down\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u662f<code>O(n)</code></li> </ul>"},{"location":"data_structure/heap/heapify/#reference","title":"Reference","text":"<ul> <li>Heap Visualization at 19:40</li> <li>Stackoverflow: why build heap is O(n) but heapify and heap sort is O(nlogn)</li> </ul>"},{"location":"data_structure/monotonic_queue/","title":"Monotonic Queue (\u5355\u8c03\u961f\u5217)","text":""},{"location":"data_structure/monotonic_queue/#_1","title":"\u4e3a\u4ec0\u4e48\u9700\u8981\u5355\u8c03\u961f\u5217?","text":"<p>\u5728\u7406\u89e3\u5355\u8c03\u961f\u5217\u4e4b\u524d\uff0c\u5148\u770b\u770b\u5b83\u89e3\u51b3\u4e86\u4ec0\u4e48\u95ee\u9898</p> Sliding Window <p>Given an array of length <code>n</code>, find the maximum value of each subarray of length <code>k</code>.</p> <p>\u4f60\u628a\u56fe\u753b\u51fa\u6765\uff0cn = 10, k = 5, \u4f60\u4f1a\u53d1\u73b0\u8fd9\u662f\u4e00\u4e2a\u6ed1\u52a8\u7a97\u53e3\u95ee\u9898\u3002</p> <p></p> <p>brute force solution\u6bd4\u8f83\u5bb9\u6613\u60f3\u5230\uff0c\u5efa\u7acb\u4e00\u4e2a\u5927\u5c0f\u4e3ak\u7684\u7a97\u53e3\uff0c\u6bcf\u6b21\u79fb\u52a8\u4e00\u683c\uff0c\u7136\u540e\u627e\u5230\u7a97\u53e3\u5185\u7684\u6700\u5927\u503c\u3002\u8fd9\u6837\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u662f\\(O(nk)\\). \u4f60\u53d1\u73b0\u6709\u5927\u91cf\u7684overlap\u7684\u8ba1\u7b97\uff0c\u4f46\u4f60\u4f1a\u53d1\u73b0\uff0c\u5b9e\u9645\u4e0a\uff0c\u6bcf\u6b21\u79fb\u52a8\u7a97\u53e3\uff0c\u53ea\u6709\u4e00\u4e2a\u5143\u7d20\u8fdb\u5165\u7a97\u53e3\uff0c\u4e00\u4e2a\u5143\u7d20\u79bb\u5f00\u7a97\u53e3, \u56e0\u6b64\u53ef\u4ee5\u5229\u7528\u8fd9\u4e2a\u903b\u8f91\u6765\u4f18\u5316\u7b97\u6cd5, \u4f7f\u65f6\u95f4\u590d\u6742\u5ea6\u964d\u5230\\(O(n)\\)\uff0c\u8fd9\u5c31\u662f\u5355\u8c03\u961f\u5217\u7684\u601d\u60f3\u3002</p> Warning <p>\u53ea\u6bd4\u8f83window\u5185\u6700\u5927\u503c\u4e0e\u65b0\u8fdb\u5165\u548c\u79bb\u5f00\u7684\u5143\u7d20\u662f\u4e0d\u8db3\u591f\u7684\uff0c\u5047\u8bbe\u4f60window\u4e2d\u6700\u5927\u503c\u4e3a10\uff0c\u4f46\u4f60\u6709\u4e24\u4e2a10. window\u4e2d\u7b2c\u4e8c\u5927\u7684\u503c\u4e3a7\uff0cincoming value\u4e3a9, outgoing value\u4e3a10. \u5982</p> <p><pre><code>nums = [10,10,7,4,9,1], k = 4\n\nfirst_window = [10,10,7,4]\nincoming_value = 9\noutgoing_value = 10\n</code></pre> \u4f60\u9700\u8981\u975e\u5e38\u591a\u7684\u989d\u5916\u7684\u903b\u8f91\u6765\u5904\u7406\u8fd9\u79cd\u60c5\u51b5\uff0c\u4e14\u5f88\u96begeneralize. \u800c\u5355\u8c03\u961f\u5217\u53ef\u4ee5\u5f88\u597d\u7684\u5904\u7406\u8fd9\u79cd\u60c5\u51b5\u3002</p>"},{"location":"data_structure/monotonic_queue/#definition","title":"Definition","text":"<p>\u5355\u8c03\u961f\u5217\u987e\u540d\u601d\u4e49,</p> <ul> <li><code>\u5355\u8c03</code>: \u6307\u7684\u662f\u6808\u5185\u5143\u7d20\u7684\u5355\u8c03\u6027. \u53ef\u589e\u53ef\u51cf.</li> <li><code>\u961f\u5217</code>: \u6307\u7684\u662f\u6808\u5185\u5143\u7d20\u53ea\u80fdenqueue\u548cdequeue.\u4e5f\u5c31\u662foperation on both ends.</li> </ul>"},{"location":"data_structure/monotonic_queue/#implementation","title":"\u5355\u8c03\u961f\u5217\u7684implementation","text":"<p>Maintain a monotonic queue, \u6700\u91cd\u8981\u7684\u662f\u7ef4\u6301\u5176\u5355\u8c03\u6027, \u6bd4\u5982\u7ef4\u62a4\u4e00\u4e2a\u5355\u8c03\u9012\u589e\u7684\u961f\u5217,\u5177\u4f53\u903b\u8f91\u662f</p> <ul> <li><code>case 1</code>: \u65b0\u5143\u7d20\u6bd4\u6240\u6709\u5143\u7d20\u5927\uff0c\u76f4\u63a5\u5165\u961f</li> <li><code>case 2</code>: \u65b0\u5143\u7d20\u6bd4\u90e8\u5206\u5143\u7d20\u5927, pop\u961f\u5217\u4e2d\u6bd4\u5b83\u5927\u7684\u5143\u7d20\uff0c\u5165\u961f</li> <li><code>case 3</code>: \u65b0\u5143\u7d20\u6bd4\u6240\u6709\u5143\u7d20\u5c0f\uff0c\u6e05\u7a7a\u961f\u5217\uff0c\u5165\u961f</li> </ul> <p>\u5176\u4e2dcase 3\u662fcase 2\u7684\u7279\u4f8b, \u6240\u4ee5\u53ef\u4ee5\u5f52\u5165\u4e00\u8d77. \u540c\u7406\uff0c\u4e0a\u8ff0\u7ef4\u62a4\u5355\u8c03\u9012\u589e\u7684\u903b\u8f91\u548c\u5355\u8c03\u9012\u51cf\u903b\u8f91\u76f8\u540c\u3002\u90a3\u4e48\u63a5\u4e0b\u6765\u6211\u4eec\u6765\u770bimplementation, </p>"},{"location":"data_structure/monotonic_queue/#_2","title":"\u5355\u8c03\u9012\u589e\u961f\u5217","text":"<pre><code>def monotonic_increasing(nums):\n    \"\"\"\n    monotonically increasing queue\n\n    :param _type_ nums: _description_\n    \"\"\"\n    queue = deque()\n    n = len(nums)\n    print(\"monotonically increasing queue:\")\n    print(\"*\" * 40)\n    for i in range(n):\n        # \u628a\u5c0f\u7684\u5f80\u5de6\u585e\n        while queue and nums[i] &lt;= queue[-1]:\n            queue.pop()\n        queue.append(nums[i])\n        print(f\"{i}: {queue}\")\n    print(\"\\n\")\n</code></pre> <p>\u5047\u8bbe\u6211\u4eec\u7684\u8f93\u5165\u4e3a<code>nums = [1,3,-1,-3,5,3,6,7]</code>, \u6211\u4eec\u6765\u770b\u770b\u5355\u8c03\u9012\u589e\u961f\u5217\u7684\u53d8\u5316.</p> <pre><code>monotonically increasing queue:\n****************************************\n0: deque([1])\n1: deque([1, 3])\n2: deque([-1])\n3: deque([-3])\n4: deque([-3, 5])\n5: deque([-3, 3])\n6: deque([-3, 3, 6])\n7: deque([-3, 3, 6, 7])\n</code></pre>"},{"location":"data_structure/monotonic_queue/#_3","title":"\u5355\u8c03\u9012\u51cf\u961f\u5217","text":"<p><pre><code>def monotonic_decreasing(nums):\n    \"\"\"\n    monotonically decreasing queue\n\n    :param _type_ nums: _description_\n    \"\"\"\n    queue = deque()\n    n = len(nums)\n    print(\"monotonically decreasing queue:\")\n    print(\"*\" * 40)\n    for i in range(n):\n        # \u628a\u5927\u7684\u5f80\u5de6\u585e\n        while queue and nums[i] &gt;= queue[-1]:\n            queue.pop()\n        queue.append(nums[i])\n        print(f\"{i}: {queue}\")\n    print(\"\\n\")\n</code></pre> \u540c\u7406\uff0c\u6211\u4eec\u6765\u770b\u770b\u5355\u8c03\u9012\u51cf\u961f\u5217\u7684\u53d8\u5316.</p> <pre><code>monotonically decreasing queue:\n****************************************\n0: deque([1])\n1: deque([3])\n2: deque([3, -1])\n3: deque([3, -1, -3])\n4: deque([5])\n5: deque([5, 3])\n6: deque([6])\n7: deque([7])\n</code></pre>"},{"location":"data_structure/monotonic_queue/#summary","title":"Summary","text":"<p>\u6240\u4ee5\uff0c\u6211\u4eec\u53ef\u4ee5\u603b\u7ed3\u51fa\u4ee5\u4e0b\u51e0\u70b9, </p> <ul> <li><code>\u5355\u8c03\u9012\u589e\u961f\u5217:</code> \u7ef4\u62a4\u7684\u662f\u9012\u589e\u6027\u548c\u6700\u5c0f\u503c, <code>\u5355\u8c03\u9012\u51cf\u961f\u5217:</code> \u7ef4\u62a4\u7684\u662f\u9012\u51cf\u6027\u548c\u6700\u5927\u503c</li> <li>\u5728<code>enqueue</code>\u4e4b\u524d\uff0c\u6211\u4eec\u9700\u8981<code>dequeue</code>\u4e00\u4e9b\u5143\u7d20\uff0c\u4ee5\u7ef4\u6301\u5355\u8c03\u6027 (case 2 + case 3), \u6700\u574f\u60c5\u51b5\u5168\u90e8<code>dequeue</code></li> </ul>"},{"location":"data_structure/monotonic_queue/#sliding-window","title":"Sliding Window\u7684\u9650\u5236\u6761\u4ef6","text":"<p>\u6211\u4eec\u4e0a\u8ff0\u53ea\u7ef4\u62a4\u4e86monotonic queue, \u4f46\u8fd9\u7c7b\u6570\u636e\u7ed3\u6784\u7684\u5e94\u7528\uff0c\u5f80\u5f80\u7275\u626f\u5230sliding window\u7684\u95ee\u9898\uff0c\u6240\u4ee5\u6211\u4eec\u9700\u8981\u5728\u7ef4\u62a4\u5355\u8c03\u884c\u4e4b\u5916\uff0c\u8fd8\u9700\u8981\u7ef4\u62a4sliding window\u7684\u9650\u5236\u6761\u4ef6\uff0c\u6bd4\u5982</p> <ul> <li><code>window size</code>: \u7a97\u53e3\u5927\u5c0f, \u4e5f\u5c31\u662f\u4f60\u7684monotonic queue\u4e0d\u80fd\u5927\u4e8ewindow size k</li> <li><code>monotonic queue</code>\u91cc\u6ca1\u6709\u9664\u4e86window\u7a97\u53e3\u91cc\u4ee5\u4e3a\u7684\u6570. </li> </ul> <p>\u7b2c\u4e00\u4e2a\u5f88\u597d\u7406\u89e3\u548c\u5b9e\u73b0\uff0c\u7b2c\u4e8c\u4e2a\u770b\u4f3ctrivial, \u4f46\u5b9e\u9645\u4e0a\u9700\u8981\u4e00\u4e9b\u989d\u5916\u7684\u8865\u5145\u903b\u8f91\u6765\u5b9e\u73b0. \u6700\u7b80\u5355\u7684\u5904\u7406\u65b9\u6cd5\u662fmaintain index instead of value in the queue. </p>"},{"location":"data_structure/monotonic_queue/#sliding-window_1","title":"Sliding Window\u4f8b\u5b50","text":"<p>\u5047\u8bbe\u6211\u4eec\u6709\u8fd9\u4e00\u9053\u9898\u76ee\uff0c\u8ba9\u4f60\u5c06\u6bcf\u4e2a\u7a97\u53e3\u7684\u6700\u5927\u503c\u627e\u51fa\u6765\uff0c\u7136\u540e\u7ec4\u5408\u6210\u4e00\u4e2a\u6570\u7ec4\u8fd4\u56de.</p> <pre><code>Input: nums = [1,3,-1,-3,5,3,6,7], k = 3\nWindow position                Max          window\n---------------               -----         -----\n[1  3  -1] -3  5  3  6  7       3             1\n 1 [3  -1  -3] 5  3  6  7       3             2\n 1  3 [-1  -3  5] 3  6  7       5             3\n 1  3  -1 [-3  5  3] 6  7       5             4\n 1  3  -1  -3 [5  3  6] 7       6             5\n 1  3  -1  -3  5 [3  6  7]      7             6\n</code></pre> <p>\u5047\u8bbe\u6211\u4eec\u5bf9\u4e0a\u8ff0\u4f8b\u5b50\u7ef4\u62a4\u4e00\u4e2a\u5355\u8c03\u9012\u589e\u7684monotonic queue with the constraints of window size <code>k==3</code>, dry run \u5982\u4e0b,</p> \u5f53\u524dwindow \u64cd\u4f5c with window\u961f\u5217\u72b6\u6001 w/o window\u961f\u5217\u72b6\u6001 1 1 \u5165\u961f <code>{1}</code> <code>{1}</code> 1 3 \u6bd4 1 \u5927\uff0c3 \u5165\u961f <code>{1 3}</code> <code>{1 3}</code> 1 -1 \u6bd4\u961f\u5217\u4e2d\u6240\u6709\u5143\u7d20\u5c0f\uff0c\u6240\u4ee5\u6e05\u7a7a\u961f\u5217 -1 \u5165\u961f <code>{-1}</code> <code>{-1}</code> 2 -3 \u6bd4\u961f\u5217\u4e2d\u6240\u6709\u5143\u7d20\u5c0f\uff0c\u6240\u4ee5\u6e05\u7a7a\u961f\u5217 -3 \u5165\u961f <code>{-3}</code> <code>{-3}</code> 3 5 \u6bd4 -3 \u5927\uff0c\u76f4\u63a5\u5165\u961f <code>{-3 5}</code> <code>{-3 5}</code> 4 3 \u6bd4 5 \u5c0f\uff0c5 \u51fa\u961f\uff0c3 \u5165\u961f <code>{-3 3}</code> <code>{-3 3}</code> 5 -3 \u5df2\u7ecf\u5728\u7a97\u4f53\u5916\uff0c\u6240\u4ee5 -3 \u51fa\u961f\uff1b6 \u6bd4 3 \u5927\uff0c6 \u5165\u961f <code>{3 6}</code> <code>{-3 3 6}</code> 6 7 \u6bd4 6 \u5927\uff0c7 \u5165\u961f <code>{3 6 7}</code> <code>{-3 3 6 7}</code> <p>\u73b0\u5728\u6211\u4eec\u77e5\u9053\u7ef4\u62a4window size\u7684monotonic queue\u4e86, \u4f46\u5177\u4f53\u843d\u5b9e\u5230\u4ee3\u7801\u91cc\uff0c\u6211\u4eec\u9700\u8981\u56de\u7b54\u7684\u95ee\u9898\u662f, \u600e\u4e48\u5224\u65ad\u6211\u4eec</p>"},{"location":"data_structure/monotonic_queue/#_4","title":"\u76f8\u5173\u9898\u76ee","text":"<p>Credit to this post</p> <ul> <li>LC 84. Largest Rectangle in Histogram</li> <li>LC 239. Sliding Window Maximum and solution.</li> <li>LC 862. Shortest Subarray with Sum at Least K</li> <li>LC 901. Online Stock Span</li> <li>LC 907. Sum of Subarray Minimums</li> </ul>"},{"location":"data_structure/monotonic_queue/#reference","title":"Reference","text":""},{"location":"data_structure/monotonic_stack/","title":"Monotonic Stack (\u5355\u8c03\u6808)","text":""},{"location":"data_structure/monotonic_stack/#_1","title":"\u5355\u8c03\u6808\u7684\u5b9a\u4e49","text":"<p><code>\u5355\u8c03\u6808</code>\u662f\u5728<code>\u6808</code>LIFO\u7684\u57fa\u7840\u4e0a\uff0c\u5143\u7d20\u6ee1\u8db3top to bottom\u662f\u4e25\u683c\u5355\u8c03\u9012\u589e\u6216\u8005\u4e25\u683c\u5355\u8c03\u9012\u51cf\u7684\u3002\u4ece\u4e0a\u5f80\u4e0b\u662f\u5355\u8c03\u9012\u589e\u7684stack, \u53eb\u505a<code>\u5355\u8c03\u9012\u589e\u6808</code>\uff0c\u53cd\u4e4b\u53eb\u505a<code>\u5355\u8c03\u9012\u51cf\u6808</code>.</p> <p></p> \u5355\u8c03\u6808\u7684\u590d\u6742\u5ea6 <p>\u5355\u8c03\u6808\u7684\u65f6\u95f4\u548c\u7a7a\u95f4\u590d\u6742\u5ea6\u662fO(n), \u4f60\u53ef\u80fd\u4f1a\u8bef\u4ee5\u4e3a<code>for</code> nested with <code>while</code>, \u4f46<code>while</code>\u53ea\u8d1f\u8d23pop stack\u76f4\u5230\u4e3a\u7a7a. <code>for</code>\u53ea\u8d1f\u8d23\u585e\u8fdb\u53bb. \u5982\u679c\u5faa\u73af\u5b8c\uff0c\u6700\u574f\u60c5\u51b5\u662f, \u6bcf\u4e2a\u5143\u7d20\u90fd\u6700\u591a\u8fdb\u6808\u4e00\u6b21\uff0c\u51fa\u6808\u4e00\u6b21, \u4e00\u5171n\u4e2a\u5143\u7d20\uff0c\u6240\u4ee5\u65f6\u95f4\u590d\u6742\u5ea6\u662fO(n). \u6bd4\u5982 \u5bf9\u4e8e\u4e25\u683c\u5355\u8c03\u9012\u589e\u7684\uff0c<code>nums = [1,2,3,4,5]</code>, \u6bcf\u4e2a\u5143\u7d20\u90fd\u8fdb\u51fa\u4e00\u6b21.</p>"},{"location":"data_structure/monotonic_stack/#monotonic-stack_1","title":"Monotonic Stack\u89e3\u51b3\u4ec0\u4e48\u95ee\u9898?","text":"<p>\u64c5\u957f\u89e3\u51b3nearest biggest or smallest element in an array\u7684\u95ee\u9898. \u6709\u4ee5\u4e0b\u51e0\u4e2a\u4f8b\u5b50\uff0c</p> <ul> <li>\u6bd4\u5982\u8bf4\u4f60\u6709\u4e00\u4e2a\u80a1\u7968\u8d70\u52bf\u56fe, \u8bb0\u5f55\u4e86\u6bcf\u4e00\u5929\u6bcf\u6b21\u80a1\u7968\u4ef7\u683c\u7684\u53d8\u5316. \u4f60\u60f3\u5feb\u901f\u83b7\u5f97\u6bcf\u4e00\u4e2a\u70b9\u7684, next greater value, \u53ef\u4ee5\u8fdb\u884c\u4e00\u4e9b\u7edf\u8ba1\u5206\u6790.</li> </ul>"},{"location":"data_structure/monotonic_stack/#next-greater-element","title":"\u5e94\u7528: Next Greater Element","text":"<p>\u627enext greater element, \u663e\u7136\u662f\u8981\u627e\u4e2a\u4e25\u683c\u9012\u589e\u6808\u3002Template \u5982\u4e0b <pre><code>def monotoneIncreasingStack(nums):\n    stack = []\n    for num in nums:\n        while stack and num &gt;= stack[-1]:\n            stack.pop()\n        stack.append(num)\n</code></pre></p> \u4e25\u683c\u548c\u4e0d\u4e25\u683c\u7684\u533a\u522b <p>\u4e25\u683c\u9012\u589e\u6808\u662f\u4e0d\u4f1a\u6709\u76f8\u7b49\u7684\u5143\u7d20\u7684\uff0c\u800c\u975e\u4e25\u683c\u9012\u589e\u6808\u662f\u53ef\u4ee5\u6709\u76f8\u7b49\u7684\u5143\u7d20\u7684\u3002\u6240\u4ee5\u4e25\u683c\u9012\u589e\u6808\u9700\u8981\u5254\u9664stack\u4e2d\u76f8\u7b49\u7684\u5143\u7d20\uff0c\u5373<code>num == stack[-1]</code>. \u52a0\u4e4b\u9700\u8981\u5254\u9664stack\u4e2d\u6bd4\u65b0\u6765\u7684\u5143\u7d20\u5c0f\u7684\u5143\u7d20\uff0c\u5373<code>num &gt; stack[-1]</code>. \u6240\u4ee5\u6761\u4ef6\u662f<code>num &gt;= stack[-1]:</code>\u5728stack\u975e\u7a7a\uff0c\u90fd\u9700\u8981\u5254\u9664</p> <ul> <li>\u4e25\u683c\u9012\u589e\u6808: <code>while stack and num &gt;= stack[-1]:</code></li> <li>\u9012\u589e\u6808: <code>while stack and num &gt; stack[-1]:</code> </li> </ul>"},{"location":"data_structure/monotonic_stack/#next-smaller-element","title":"\u5e94\u7528: Next Smaller Element","text":"<p>\u627enext smaller element, \u663e\u7136\u662f\u8981\u627e\u4e2a\u9012\u51cf\u6808\u3002Template \u5982\u4e0b <pre><code>def monotoneDecreasingStack(nums):\n    stack = []\n    for num in nums:\n        while stack and num &lt;= stack[-1]:\n            stack.pop()\n        stack.append(num)\n</code></pre></p>"},{"location":"data_structure/monotonic_stack/#_2","title":"\u76f8\u5173\u9898\u76ee","text":"<ul> <li>LC 496 Next Greater Element I and solution<ul> <li>\u633a\u4e0d\u9519\u7684\u5165\u95e8\u9898</li> </ul> </li> <li>LC 739. Daily Temperatures and solution.<ul> <li>\u7ecf\u5178\u4f8b\u9898\uff0c\u5165\u95e8\u9898</li> </ul> </li> <li>LC 1762 Buildings With an Ocean View and solution.<ul> <li>\u5165\u95e8\u9898</li> </ul> </li> </ul>"},{"location":"data_structure/monotonic_stack/#reference","title":"Reference","text":"<ul> <li>\u7b97\u6cd5\u901a\u5173\u624b\u518c Monotonic stack</li> </ul>"},{"location":"data_structure/queue/","title":"Queue","text":""},{"location":"data_structure/queue/#queue_1","title":"Queue\u7684\u5b9a\u4e49","text":"<p>Queue (\u961f\u5217): \u4e00\u79cd\u7ebf\u6027\u8868\u6570\u636e\u7ed3\u6784\uff0c\u53ea\u5141\u8bb8\u5728\u8868\u7684\u4e00\u7aef\u8fdb\u884c\u63d2\u5165\uff0c\u800c\u5728\u53e6\u4e00\u7aef\u8fdb\u884c\u5220\u9664. \u8fd9\u79cd\u6570\u636e\u7ed3\u6784\u9075\u5faaFIFO (First In First Out)\u7684\u539f\u5219. \u4e5f\u5c31\u662f\u8bf4\uff0c\u5148\u8fdb\u5165\u961f\u5217\u7684\u5143\u7d20\uff0c\u5148\u88ab\u5220\u9664. </p> <p></p> <p>\u4f60\u53ef\u4ee5\u76f4\u63a5\u7406\u89e3\u6210\u6392\u961f\uff0c\u5148\u6765\u7684\u5148\u670d\u52a1. \u4f60\u53bb\u94f6\u884c\u6392\u961f\uff0c\u5148\u6765\u7684\u4eba\u5148\u529e\u4e1a\u52a1\uff0c\u540e\u6765\u7684\u4eba\u540e\u529e\u4e1a\u52a1. \u8fd9\u5c31\u662fqueue\u7684\u7279\u6027.</p> \u4e3a\u5565\u6211\u753b\u6210\u53f3\u8fdb\u5de6\u51fa? <p>\u7edd\u5927\u591a\u6570\u6587\u660e\u7684\u4eba\uff0c\u90fd\u9002\u7528\u4e8e\u4ece\u5de6\u5f80\u53f3\u9605\u8bfb\u3002\u4f46\u4e3a\u4ec0\u4e48\u6211queue\u753b\u6210\u53cd\u4eba\u7c7b\u7684\u53f3\u8fdb\u5de6\u51fa\u5417? </p> <p>Unlike stack, \u53ea\u5141\u8bb8\u4e00\u4e2a\u7aef\u53e3\u6267\u884c\u589e\u52a0\u548c\u5220\u9664\u64cd\u4f5c, queue\u6709\u4e24\u4e2a\u7aef\u53e3\uff0c\u4e00\u4e2a\u4e13\u95e8\u7528\u6765\u589e\u52a0\u5143\u7d20\uff0c\u53e6\u4e00\u4e2a\u7528\u6765\u5220\u9664\u5143\u7d20. </p> <ul> <li><code>dequeue()</code>: remove an element from the head of the queue</li> <li><code>enqueue()</code>: add an element to the tail of the queue</li> </ul>"},{"location":"data_structure/queue/#queue_2","title":"Queue\u7684\u5e94\u7528","text":"<p>Microservices, \u4e00\u4e2a\u5f88\u6d41\u884c\u7684\u67b6\u6784\u6a21\u5f0f, \u7528\u6765\u89e3\u8026\u548cscale application.\u4e2d\u95f4\u9700\u8981\u4e00\u4e2a\u6d88\u606f\u4f20\u9012\u7684\u7cfb\u7edf, \u8fd9\u65f6\u5019\u5c31\u9700\u8981\u4e2d\u95f4\u4ef6. \u6bd4\u8f83\u706b\u7684\u4e2d\u95f4\u4ef6RabbitMQ, \u5c31\u662f\u4e00\u4e2adistributed message queue, \u7528\u6765\u505a\u6d88\u606f\u7684\u4f20\u9012. \u5148\u6765\u7684\u4efb\u52a1\u5148\u5904\u7406, \u8fd9\u5c31\u662fqueue\u7684\u7279\u6027, FIFO (first in first out).</p> <p></p>"},{"location":"data_structure/queue/#queue_3","title":"Queue\u7684\u5b9e\u73b0","text":"<p>Queue\u4f5c\u4e3a\u4e00\u79cdlinear data structure, \u4e00\u822c\u5206\u4e3a\u987a\u5e8f\u50a8\u5b58\u548c\u94fe\u5f0f\u50a8\u5b58\u4e24\u79cd\u65b9\u5f0f. \u987a\u5e8f\u50a8\u5b58\u4e00\u822c\u7528\u6570\u7ec4\u5b9e\u73b0\uff0c\u94fe\u5f0f\u50a8\u5b58\u4e00\u822c\u7528\u94fe\u8868\u5b9e\u73b0.</p> <pre><code>graph TD\n    A[Queue]\n\n    subgraph \"\u987a\u5e8f\u50a8\u5b58\"\n    B[Array-based Queue]\n    C[Circular Array-based Queue]        \n    end\n\n    subgraph \"\u94fe\u5f0f\u50a8\u5b58\"\n    D[Linked List-based Queue] \n    end\n\n    A --&gt; B &amp; C &amp; D</code></pre> <p>\u90a3\u4e48\u5148\u6765\u770b\u770b\u9700\u8981\u5b9e\u73b0queue\u7684\u54ea\u4e9b\u529f\u80fd:</p> <ul> <li><code>init()</code>: \u521d\u59cb\u5316queue, \u6709\u4e00\u4e2acapacity.</li> <li><code>is_empty()</code>: \u5224\u65adqueue\u662f\u5426\u4e3a\u7a7a</li> <li><code>is_full()</code>: \u5224\u65adqueue\u662f\u5426\u6ee1\u4e86</li> <li><code>enqueue()</code>: \u5c06\u5143\u7d20\u52a0\u5165queue</li> <li><code>dequeue()</code>: \u5c06\u5143\u7d20\u4ecequeue\u4e2d\u5220\u9664</li> <li><code>head_value()</code>: \u67e5\u770bqueue\u7684\u5934\u5143\u7d20, \u4e5f\u5c31\u662f\u5373\u5c06\u88abdequeue\u7684\u5143\u7d20.</li> <li><code>tail_value()</code>: \u67e5\u770bqueue\u7684\u5c3e\u5143\u7d20, \u4e5f\u5c31\u662f\u6700\u540e\u4e00\u4e2a\u88abenqueue\u7684\u5143\u7d20.</li> </ul> <p>\u7531\u4e8e\u9700\u8981\u5b9e\u73b0\u652f\u6301\u4e24\u5934\u7684\u64cd\u4f5c\uff0cunlike stack using only 1 pointer <code>top</code>, queue\u5c31\u9700\u8981\u7ef4\u62a4\u4e24\u4e2apointer <code>head</code> and <code>tail</code>. \u5f00\u9500\u7a0d\u5fae\u5927\u4e00\u70b9.</p>"},{"location":"data_structure/queue/#1-array-based-queue","title":"\u65b9\u6cd51: Array-based Queue","text":"<p>Array-based Queue: \u4f7f\u7528\u6570\u7ec4\u8fdb\u884c\u5b9e\u73b0\uff0c\u5728python\u4e2dlist\u53ef\u4ee5\u5f88\u597d\u7684\u5b9e\u73b0. </p> <p>Array\u662f\u4e00\u6bb5\u8fde\u7eed\u7684memory, \u4f46\u53ea\u6709\u5728<code>head</code> and <code>tail</code> pointer\u4e2d\u95f4\u7684\u90e8\u5206\uff0c<code>[head+1,tail]</code> \u624d\u662fqueue\u7684\u6709\u6548\u90e8\u5206.</p> <p></p> <p>\u5177\u4f53implementation\u5982\u4e0b:</p> <pre><code>class Queue:\n    # \u521d\u59cb\u5316\u7a7a\u961f\u5217\n    def __init__(self, size=100):\n        self.size = size\n        self.queue = [None for _ in range(size)]\n        self.head = -1\n        self.tail = -1\n\n    # \u5224\u65ad\u961f\u5217\u662f\u5426\u4e3a\u7a7a\n    def is_empty(self):\n        return self.head == self.tail\n\n    # \u5224\u65ad\u961f\u5217\u662f\u5426\u5df2\u6ee1\n    def is_full(self):\n        return self.tail + 1 == self.size\n\n    # \u5165\u961f\u64cd\u4f5c\n    def enqueue(self, value):\n        if self.is_full():\n            raise Exception('Queue is full')\n        else:\n            self.tail += 1\n            self.queue[self.tail] = value\n\n    # \u51fa\u961f\u64cd\u4f5c\n    def dequeue(self):\n        if self.is_empty():\n            raise Exception('Queue is empty')\n        else:\n            self.head += 1\n            return self.queue[self.head]\n\n    # \u83b7\u53d6\u961f\u5934\u5143\u7d20\n    def head_value(self):\n        if self.is_empty():\n            raise Exception('Queue is empty')\n        else:\n            return self.queue[self.head + 1]\n\n    # \u83b7\u53d6\u961f\u5c3e\u5143\u7d20\n    def tail_value(self):\n        if self.is_empty():\n            raise Exception('Queue is empty')\n        else:\n            return self.queue[self.tail]\n</code></pre> <p><code>Array-based Queue</code>\u4f1a\u9020\u6210\u4ec0\u4e48\u95ee\u9898\u5462? \u5982\u679c\u4f60array size\u4e3a5\uff0c\u4f60\u505a\u4ee5\u4e0b\u7684\u64cd\u4f5c:</p> <ul> <li><code>enqueue()</code> 2\u6b21</li> <li><code>enqueue()</code> 1\u6b21, <code>dequeue()</code> 1\u6b21. \u8fd9\u6837repeat 5\u6b21</li> </ul> <p>\u4f60\u4f1a\u53d1\u73b0\u4f60\u7684<code>tail</code> pointer\u5df2\u7ecf\u5230\u4e86\u9759\u6001array\u7684size limit, \u4e5f\u5c31\u662f<code>tail = 4</code> (0-indexed). \u5982\u4e0b\u56fe\u6240\u793a\uff0c </p> <p></p> <p>\u8fd9\u65f6\u5019\u4f60\u6709\u4e24\u4e2a\u9009\u62e9:</p> <ul> <li><code>shift array</code>: \u5c06\u6574\u4e2aarray\u5411\u5de6\u79fb\u52a8\u4e00\u4f4d, \u8fd9\u6837\u4f60\u5c31\u53ef\u4ee5\u7ee7\u7eed<code>enqueue()</code>\u4e86. </li> <li><code>\u52a8\u6001\u6269\u5bb9</code>: \u521b\u5efa\u4e00\u4e2a\u65b0\u7684array, \u5927\u5c0f\u662f\u539f\u6765\u7684\u4e24\u500d, \u7136\u540e\u5c06\u539f\u6765\u7684array copy\u5230\u65b0\u7684array\u4e2d, \u7136\u540edestroy\u8001\u7684array.</li> </ul> <p>\u4f60\u5982\u679c\u4f7f\u7528\u65b9\u68481\uff0cworst case scenario, \u867d\u7136\u4f60array\u8fd8\u6709\u7a7a\u95f4\uff0c\u4f46\u662f\u6bcf\u6b21<code>enqueue()</code>\u90fd\u8981\u505a\u4e24\u6b21\u64cd\u4f5c. \u4f60\u5982\u679c\u4f7f\u7528\u65b9\u68482\uff0c\u90a3\u4e48\u4f60\u539f\u6765\u7684\u7a7a\u95f4\u4e0d\u5c31\u6d6a\u8d39\u4e86\u5417? \u8fd9\u4e24\u79cd\u65b9\u6cd5\u90fd\u4e0d\u662f\u5f88\u597d. \u6240\u4ee5\u603b\u7ed3\u4e00\u4e0b\uff0c<code>Array-based Queue</code>\u7684\u7f3a\u70b9\u5c31\u662f:</p> <ul> <li>\u6709\u4e00\u5b9a\u6982\u7387\u4f1a\u9020\u6210\u7a7a\u95f4\u6d6a\u8d39</li> </ul> <p>\u90a3\u4e48\u6211\u4eec\u6709\u4ec0\u4e48\u529e\u6cd5\u7269\u5c3d\u5176\u7528\u561b??</p>"},{"location":"data_structure/queue/#2-circular-array-based-queue","title":"\u65b9\u6cd52 Circular Array-based Queue","text":"<p>Circular Array-based Queue: \u4e3a\u4e86\u89e3\u51b3<code>Array-based Queue</code>\u7684\u7a7a\u95f4\u6d6a\u8d39\u95ee\u9898\uff0c\u5229\u7528\u53cc\u6307\u9488\u8fdb\u6765wrap around, \u6765manipulate array\u4ece\u800c\u4e0d\u81f3\u4e8e\u6d6a\u8d39\u7a7a\u95f4. </p> LC 622. Design Circular Queue <p>\u8fd9\u9898\u5c31\u662f\u8003\u7684\u8fd9\u79cd\u5b9e\u73b0\u65b9\u6cd5.</p> <ul> <li><code>Linked List-based Queue</code>: \u7565</li> <li><code>two stack emulation</code>: \u7528\u4fe9stack, \u98a0\u6765\u5012\u53bb, \u4e00\u4e2astack\u7528\u6765push, \u4e00\u4e2astack\u7528\u6765pop, \u8fd9\u6837\u5c31\u53ef\u4ee5\u5b9e\u73b0queue\u7684FIFO\u7279\u6027\u4e86. \u60f3\u8c61\u6210\u4e00\u4e2aspring coil or tower of Hanoi. \u8fd9\u9898\u53ef\u4ee5\u770b\u8fd9\u91cc.<ul> <li>LC 232. Implement Queue using Stacks</li> </ul> </li> </ul> <p>\u8fd9\u4e09\u79cd\u65b9\u5f0f\u7684\u590d\u6742\u5ea6\u5982\u4e0b\u8868:</p> Operation Array-based Queue Linked List-based Queue Two Stack Emulation Enqueue O(1) O(1) O(1) Dequeue O(n) O(1) O(n) Peek O(1) O(1) O(n) <p>\u5148\u6765\u770b\u770b\u6784\u5efa\u8fd9\u4e2aqueue, \u6211\u4eec\u9700\u8981:</p> <ul> <li><code>self.queue</code>: \u4e00\u4e2aarray, \u7528\u6765\u5b58\u50a8queue\u7684element</li> <li><code>self.count</code>: \u4e00\u4e2acounter, \u7528\u6765\u8bb0\u5f55queue\u7684element\u4e2a\u6570</li> <li><code>self.capacity</code>: \u4e00\u4e2aint, \u7528\u6765\u8bb0\u5f55queue\u7684\u6700\u5927\u5bb9\u91cf</li> <li><code>self.head</code>: \u4e00\u4e2aint, \u6c38\u8fdc\u6307\u5411queue\u7684first element in the queue.</li> </ul> <p>\u5f53\u6709\u4e86\u8fd9\u4e9b\u5173\u7cfb\uff0c\u6211\u4eec\u53ef\u4ee5\u63a8\u7b97\u51fatail pointer\u7684\u4f4d\u7f6e</p> <ul> <li><code>tail = (head + count - 1) % capacity</code>: \u6307\u5411first available empty slot ready to be enqueued</li> <li><code>tail_enqueue = (head + count - 1) % capacity</code>: \u6307\u5411the last element in the queue (\u521a\u521aenqueue\u8fdb\u6765\u7684).</li> </ul> <p><code>tail</code> points to the last item in the queue, \u4e5f\u5c31\u662f\u521a\u521aenqueue\u8fdb\u6765\u7684element. <code>tail_enqueue</code> points to the last available slot ready to be enqueued, \u4e5f\u5c31\u662f\"\u53ef\u4ee5\u5141\u8bb8\u88ab\u8986\u76d6\u7684\u4f4d\u7f6e\".</p> <p>Tip</p> <p>\u91cc\u9762\u7684<code>%</code>\u662f\u53d6\u4f59\u6570\u7684\u610f\u601d, \u4e5f\u5c31\u662f\u8bf4\uff0c\u5f53\u6211\u4eec\u7684head\u5728\u4e00\u7aef\u65f6\uff0c\u6211\u4eec\u53ef\u4ee5wrap around\u5230\u53e6\u4e00\u7aef\uff0c\u8fd9\u6837\u5c31\u5b9e\u73b0\u4e86circular queue\u7684\u7279\u6027. \u4efb\u4f55circular\u7684\u7279\u6027\uff0c\u90fd\u53ef\u4ee5\u89e3.</p> <p>\u770b\u4e0b\u56fe\u6765\u7406\u89e3wrap around\u548ctwo pointers technique, </p> <p></p> <p>\u4f60\u4ece\u8fd9\u91cc\u53ef\u4ee5\u770b\u5230, </p> <pre><code>class MyCircularQueue:\n    \"\"\"\n    Use array to implement \"circular \"queue. Imagine we have a full queue like \n    [1, 2, 3, 4 ,5 ]\n    and we execute two dequeue() from the top. \n    [_, _, 3, 4 ,5 ]\n    Now, we have some space near the head but we don't have space at the tail. \n    It will cause problem if we decide to enqueue(i), we will be\n    - shifting everything to fill the empty space near head of the queue (O(n))\n    - expand the fix-sized array, (create an array of size 2n, move to it, destroy the old array)\n    \"\"\"\n    def __init__(self, k: int):\n        self.queue = [0 for _ in range(k)]\n        self.count = 0\n        self.capacity = k\n        # always points to the head of the queue\n        self.head = 0\n\n    def enQueue(self, value: int) -&gt; bool:\n        \"\"\"\n        Insert an element into the circular queue from tail. Return true if the operation\n        is successful. Return false if the queue is maxed out.\n        \"\"\"\n        if self.count == self.capacity:\n            return False\n        # last available slot ready to be enqueued\n        tail_enqueue = (self.head + self.count) % self.capacity\n        self.queue[tail_enqueue] = value\n        self.count += 1\n        return True\n\n    def deQueue(self) -&gt; bool:\n        \"\"\"\n        Pop an element from the head. Return true if the operation is successful.\n        Return false if the queue is empty\n        \"\"\"\n        if self.count == 0:\n            return False\n        # remove the element at head\n        self.head = (self.head + 1) % self.capacity\n        self.count -= 1\n        return True\n\n\n    def Front(self) -&gt; int:\n        if self.count == 0:\n            return -1\n        return self.queue[self.head]\n\n\n    def Rear(self) -&gt; int:\n        if self.count == 0:\n            return -1\n        # points to last item in the queue (who just enqueued)\n        tail = (self.head + self.count - 1) % self.capacity\n        return self.queue[tail]\n\n    def isEmpty(self) -&gt; bool:\n        return self.count == 0\n\n    def isFull(self) -&gt; bool:\n        return self.count == self.capacity\n</code></pre>"},{"location":"data_structure/queue/#3-linked-list-based-queue","title":"\u65b9\u6cd53: Linked List-based Queue","text":""},{"location":"data_structure/queue/#reference","title":"Reference","text":""},{"location":"data_structure/stack/","title":"Stack","text":""},{"location":"data_structure/stack/#stack_1","title":"Stack\u7684\u5b9a\u4e49","text":"<p>Stack (\u5806\u6808): AKA \u6808\uff0c\u662f\u4e00\u79cd\u7ebf\u6027\u50a8\u5b58\u7ed3\u6784\uff0c\u662f\u4e00\u79cd\u53ea\u5141\u8bb8\u5728\u4e00\u7aef\u8fdb\u884c\u63d2\u5165\u548c\u5220\u9664\u64cd\u4f5c\u7684\u7ebf\u6027\u8868\u3002\u6808\u9075\u5faaLIFO\uff08Last In First Out\uff09\u539f\u5219\uff0c\u5373\u6700\u540e\u8fdb\u5165\u7684\u5143\u7d20\u6700\u5148\u51fa\u6765.</p> <p>\u4e00\u4e2a\u6808\u7684\u793a\u610f\u56fe\u5982\u4e0b:</p> <p></p> <p>\u5176\u4e2dtop\u662f\u6808\u9876\u662f\u552f\u4e00\u5141\u8bb8\u64cd\u4f5c\u7684\u4e00\u7aef\uff0c\u800cbase\u662f\u6808\u5e95\u3002\u6808\u5e95\u662f\u56fa\u5b9a\u7684\uff0c\u800c\u6808\u9876\u662f\u52a8\u6001\u7684\u3002stack\u6709\u4e24\u4e2a\u57fa\u672c\u64cd\u4f5c:</p> <ul> <li><code>push(value)</code>: \u5c06\u5143\u7d20\u4ecetop\u5165\u6808</li> <li><code>pop()</code>: \u5c06\u6808\u9876\u5143\u7d20\u51fa\u6808</li> </ul> <p>\u5b83\u7b26\u5408\u539f\u5219LIFO (Last In First Out)\u7684\u7ebf\u6027\u8868.</p>"},{"location":"data_structure/stack/#stack_2","title":"Stack\u7684\u5e94\u7528","text":"<p>Stack\u5e94\u7528\u975e\u5e38\u5e7f\u6cdb\uff0c\u5c5e\u4e8e\u625b\u628a\u5b50\u7ea7\u522b\u7684auxillary DS, \u6309\u5206\u7c7b\u53ef\u4ee5\u7406\u89e3\u4e3a\u4ee5\u4e0b2\u7c7b:</p> <ul> <li>very convenient save and access, \u53ef\u4ee5\u4f5c\u4e3aauxillary DS, \u4fdd\u5b58\u4e34\u65f6\u7684\u4fe1\u606f, \u7528\u4e8e\u5feb\u901f\u8bbf\u95ee. \u6bd4\u5982<ul> <li>\u6d4f\u89c8\u5668\u7684\u524d\u8fdb\u540e\u9000, \u4fdd\u5b58\u4f60\u7684recently visited sites</li> <li>undo operation in text editor, undo\u53ef\u4ee5cancel\u4f60\u7684operations and reverts to previous state. \u8fd9\u4e2aprevious state\u88ab\u4fdd\u5b58\u5728stack\u91cc\u9762, \u9700\u8981\u7684\u65f6\u5019\u5728pop\u51fa\u6765</li> <li>\u4f60\u7684teammate\u5f00\u53d1\u4e86\u4e00\u4e2a\u65b0feature, \u5e0c\u671b\u4f60\u53bb\u770b\u770bbranch, \u7136\u540e\u4f60\u5f88\u521a\u597d\u5de5\u4f5c\u5230\u4e00\u534a\uff0c\u4e0d\u597dcommit\uff0c\u6240\u4ee5\u4f60\u9700\u8981\u7528git stash. <code>git stash</code>\u4e4b\u540e\uff0c\u53bb\u770b\u4e86\u4ed6\u7684branch, \u7136\u540e\u56de\u6765<code>git stash pop</code>\uff0c\u7ee7\u7eed\u4f60\u7684\u5de5\u4f5c. \u8fd9\u4e2a\u529f\u80fd\u7684\u5b9e\u73b0\u5c31\u662f\u901a\u8fc7stack\u6765\u5b9e\u73b0\u7684.</li> </ul> </li> <li>\u6839\u636eLIFO, \u8f7b\u677e\u505a\u5230\u9006\u5e8f, \u6bd4\u5982<ul> <li>\u7ffb\u8f6c\u4e00\u7ec4\u5143\u7d20, \u6bd4\u5982python negative slicing for reverse, <code>nums[::-1]</code>, \u4f60\u53ef\u4ee5\u7528stack\u6765\u5b9e\u73b0</li> </ul> </li> </ul> <p>\u5e0c\u671b\u6211\u8bf4\u4e86\u8fd9\u4e48\u591a, \u4f60\u80fd\u5bf9stack\u52a0\u6df1\u5370\u8c61, \u5e76\u4e14\u80fd\u591f\u5728\u5b9e\u9645\u5de5\u4f5c\u4e2d\u5e94\u7528.</p>"},{"location":"data_structure/stack/#stack_3","title":"Stack\u7684\u5b9e\u73b0","text":"<p>stack\u6709\u4e24\u79cd\u50a8\u5b58\u65b9\u5f0f,</p> <ul> <li>\u987a\u5e8f\u50a8\u5b58: \u5229\u7528\u4e00\u7ec4contiguous memory\u6765\u4f9d\u6b21\u50a8\u5b58bottom to top\u7684\u5143\u7d20, \u540c\u65f6\u7ef4\u62a4\u4e00\u4e2apointer top, \u6c38\u8fdc\u6307\u5411\u6808\u9876\u5143\u7d20. \u662f\u7528\u6570\u7ec4\u5b9e\u73b0\u7684.</li> <li>\u94fe\u5f0f\u50a8\u5b58: \u7528\u94fe\u8868\u6765\u5b9e\u73b0, \u6bcf\u4e2a\u8282\u70b9\u6709\u4e00\u4e2a\u6307\u9488\u6307\u5411\u4e0b\u4e00\u4e2a\u8282\u70b9. \u5143\u7d20\u6309\u7167\u63d2\u5165\u987a\u5e8f\uff0c\u4f9d\u6b21\u63d2\u5165\u5230\u94fe\u8868\u7684\u7b2c\u4e00\u4e2a\u8282\u70b9\u4e4b\u524d\uff0c\u5e76\u4f7f\u7528\u4e00\u4e2a\u6307\u9488<code>top</code>\u6307\u5411\u65b0\u63d2\u5165\u7684\u8282\u70b9. \u8fd9\u6837\u65b0\u63d2\u5165\u7684\u8282\u70b9\u5c31\u6210\u4e3a\u4e86\u6808\u9876\u5143\u7d20. \u65b9\u4fbf\u63d2\u5165\u548c\u5220\u9664\u64cd\u4f5c, \u901a\u5e38\u7528\u5355\u94fe\u8868\u5b9e\u73b0.</li> </ul> <p>\u65e2\u7136\u660e\u767d\u4e86stack\u7684\u50a8\u5b58\u65b9\u5f0f\uff0c\u6211\u4eec\u5c31\u8981\u770b\u770b\u6211\u4eec\u4e00\u822c\u5b9e\u73b0stack\u7684\u65f6\u5019\uff0c\u9700\u8981\u5b9e\u73b0\u54ea\u4e9b\u65b9\u6cd5:</p> <ul> <li><code>init()</code>: \u521d\u59cb\u5316stack, \u8bbe\u8ba1\u4e00\u4e2acapacity (\u5982\u679c\u9759\u6001)\u4ee5\u53ca\u521d\u59cb\u5316top\u6307\u9488.</li> <li><code>is_empty()</code>: \u5224\u65adstack\u662f\u5426\u4e3a\u7a7a</li> <li><code>is_full()</code>: \u5224\u65adstack\u662f\u5426\u6ee1\u4e86</li> <li><code>push(value)</code>: \u5c06\u5143\u7d20\u4ecetop\u5165\u6808</li> <li><code>pop()</code>: \u5c06\u6808\u9876\u5143\u7d20\u51fa\u6808</li> <li><code>peek()</code>: \u8fd4\u56de\u6808\u9876\u5143\u7d20\uff0c\u4f46\u4e0d\u51fa\u6808.</li> </ul> <p>\u63a5\u4e0b\u6765\u6211\u4eec\u770b\u770bstack\u7684\u5b9e\u73b0\uff0c\u6211\u4eec\u5148\u770b\u770b\u987a\u5e8f\u50a8\u5b58\u7684\u5b9e\u73b0.</p>"},{"location":"data_structure/stack/#1","title":"\u65b9\u6cd51: \u987a\u5e8f\u50a8\u5b58\u7684\u5b9e\u73b0","text":"<p>Note</p> <p>Python\u6216\u8005\u5176\u5b83\u652f\u6301negative index\u7684\u8bed\u8a00\uff0c\u53ef\u4ee5\u4e0d\u9700\u8981\u7ef4\u62a4top, \u76f4\u63a5\u7528<code>stack[-1]</code>\u6765\u8868\u793a\u6808\u9876\u5143\u7d20. \u4f46\u662f\u4e3a\u4e86\u66f4\u597d\u7684\u7406\u89e3stack\u7684\u5b9e\u73b0\uff0c\u6211\u4eec\u8fd8\u662f\u7ef4\u62a4\u4e00\u4e2atop\u6307\u9488.</p> <pre><code>class Stack:\n    def __init__(self, capacity):\n        self.capacity = capacity\n        self.stack = []\n        # top\u6307\u5411last index, \u73b0\u5728\u662f\u7a7a\u7684\uff0c\u6240\u4ee5initialize\u4e3a-1\n        self.top = -1\n\n    def is_empty(self):\n        return self.top == -1\n\n    def is_full(self):\n        return self.top == self.capacity - 1\n\n    def push(self, value):\n        if self.is_full():\n            raise Exception(\"Stack is full\")\n        self.stack.append(value)\n        self.top += 1\n\n    def pop(self):\n        if self.is_empty():\n            raise Exception(\"Stack is empty\")\n        self.top -= 1\n        return self.stack.pop()\n\n    def peek(self):\n        if self.is_empty():\n            raise Exception(\"Stack is empty\")\n        return self.stack[self.top]\n</code></pre>"},{"location":"data_structure/stack/#2","title":"\u65b9\u6cd52: \u94fe\u5f0f\u50a8\u5b58\u7684\u5b9e\u73b0","text":"<pre><code>class Node:\n    def __init__(self, value):\n        self.value = value\n        self.next = None\n\nclass Stack:\n    # \u521d\u59cb\u5316\u7a7a\u6808\n    def __init__(self):\n        self.top = None\n\n    # \u5224\u65ad\u6808\u662f\u5426\u4e3a\u7a7a\n    def is_empty(self):\n        return self.top == None\n\n    # \u5165\u6808\u64cd\u4f5c\n    def push(self, value):\n        cur = Node(value)\n        cur.next = self.top\n        self.top = cur\n\n    # \u51fa\u6808\u64cd\u4f5c\n    def pop(self):\n        if self.is_empty():\n            raise Exception('Stack is empty')\n        else:\n            cur = self.top\n            self.top = self.top.next\n            del cur\n\n    # \u83b7\u53d6\u6808\u9876\u5143\u7d20\n    def peek(self):\n        if self.is_empty():\n            raise Exception('Stack is empty')\n        else:\n            return self.top.value\n</code></pre>"},{"location":"data_structure/stack/#lc-20-valid-parentheses","title":"\u7ecf\u5178\u9898\u76ee: LC. 20 Valid Parentheses","text":"<p>\u5f88\u7ecf\u5178\u7684\u4e00\u9898.</p> <p>Anecdote</p> <p>\u8fd9\u4e2a\u9898\u76ee\u7b2c\u4e00\u6b21\u505a\u8fd8\u662f\u5728\u4e0a\u6d77\u7684\u4e00\u5bb6\u661f\u5df4\u514bon codewars\u7b49\u9e21\u4ed4,\u597d\u50cf\u662f\u6885\u9f99\u9547\u5427\uff0c\u90a3\u65f6\u5019\u53ea\u80fd\u60f3\u51fa\u6765\u66b4\u529b\u89e3\uff0c\u6211\u53d6\u540d\u4e3a<code>while</code>\u7684\u6293\u5a03\u5a03\u5927\u6cd5.</p>"},{"location":"data_structure/stack/#_1","title":"\u76f8\u5173\u9898\u76ee","text":"<ul> <li>LC. 225 Implement Stack using Queues and solution here</li> <li>LC. 227 Basic Calculator II and solution here</li> </ul>"},{"location":"data_structure/stack/#reference","title":"Reference","text":"<ul> <li>\u5317\u822a\u7b97\u6cd5\u901a\u5173\u624b\u518c</li> <li>Book: DSA by Goodrich</li> </ul>"},{"location":"data_structure/tree/","title":"Tree","text":"<p>Tree\u662f\u4e00\u79cd\u975e\u7ebf\u6027\u7684\u6570\u636e\u7ed3\u6784(1 to many), \u548c\u6211\u4eec\u4ee5\u524d\u63a5\u89e6\u7684</p> <p></p> <p>\u5e38\u89c1\u6811\u7684\u5206\u7c7b:</p> name chinese name definition Perfect Binary Tree \u5b8c\u7f8e\u4e8c\u53c9\u6811 Every node except the leaf nodes have two children and every level (last level too) is completely filled. \u6700\u5b8c\u7f8e\u7684. Complete Binary Tree \u5b8c\u5168\u4e8c\u53c9\u6811 \u5728heap\u7684\u65f6\u5019\u63a5\u89e6\u8fc7\u8fd9\u4e2a\u6982\u5ff5\uff0c\u81ea\u4e0a\u800c\u4e0b\uff0c\u81ea\u5de6\u5411\u53f3\u586b\u5145\u7684. Every level except the last level is completely filled and all nodes are left justified (\u5de6\u5bf9\u9f50\uff0cleft -&gt; right). complete binary tree\u6bd4perfect binary tree\u7684\u6761\u4ef6\u6765\u7684relax\u4e00\u70b9. Full/Strictly Binary Tree \u5b8c\u6ee1\u4e8c\u53c9\u6811 Every node except the leaf nodes have two children. \u751a\u81f3\u90fd\u4e0d\u7528\u4ece\u5de6\u5230\u53f3\uff0c\u4ece\u4e0a\u5230\u4e0bfill, \u4f60\u53ea\u8981\u67092 children\u5c31\u597d. \u66f4relax <p>BST (binary search tree)</p>"},{"location":"data_structure/tree/problems/","title":"Tree Problems","text":"<p>Tree\u7684\u9898\u578b\u5206\u6210\u4ee5\u4e0b\u51e0\u7c7b:</p> <ol> <li>Tree Traversal</li> <li>\u7ed3\u6784\u8f6c\u6362\u6811, serialize/deserialize<ul> <li><code>serialize</code>: \u628a\u6811\u8f6c\u6362\u6210\u7ebf\u6027\u7684list</li> <li><code>deserialize</code>: \u628alist\u8f6c\u6362\u6210\u6811</li> </ul> </li> <li>LCA (lowest common ancestor)<ul> <li>??</li> </ul> </li> <li>BST (binary search tree)</li> <li>iterator<ul> <li>\u4e9a\u9ebb\u559c\u6b22\u8003</li> </ul> </li> </ol>"},{"location":"data_structure/tree/problems/#traversal","title":"Traversal","text":"<p>Traversal\u662f\u6700\u57fa\u7840\u7684\u6811\u7684\u9898\u578b, \u5176\u5206\u7c7b\u5927\u4f53\u4e3a:</p> <pre><code>flowchart TD\nroot(Traversal) --&gt; DFS\nroot --&gt; BFS\ndfs_1(\"iterative with stack\")\ndfs_2(\"recursive\")\nbfs_1(\"iterative with queue\")\n\nDFS --&gt; dfs_1 &amp; dfs_2\nBFS --&gt; bfs_1</code></pre> <p>\u5bf9\u4e8eDFS\u6765\u8bf4\uff0c\u65e0\u8bba\u662fiterative\u8fd8\u662frecursive, \u90fd\u9700\u8981somehow go back to the nodes visited before, \u6240\u4ee5\u8981\u4e48\u9700\u8981\u4e00\u4e2aexplicit stack\u6765\u5b58\u50a8 (iterative DFS), \u8981\u4e48\u9700\u8981\u4e00\u4e2arecursive call stack\u6765\u5b58\u50a8 (recursive DFS).</p> number \u7c7b\u578b \u601d\u8def solution 144 Binary Tree Preorder Traversal DFS <code>[root,left,right]</code> solution 94 Binary Tree Inorder Traversal DFS <code>[left,mid,right]</code> solution 145 Binary Tree Postorder Traversal DFS \u955c\u50cf\u4e4b\u672f, <code>[left,right,root]</code> &lt;--&gt; reverse of <code>[root,right,left]</code>. \u4e5f\u5c31\u662fpreorder traversal\u4f46\u662f\u8c03\u6362\u4e00\u4e0b\u5de6\u53f3\u5148\u8bbf\u95ee\u7684\u987a\u5e8f solution 102 Binary Tree Level Order Traversal BFS BFS\u5165\u95e8 solution 107 Binary Tree Level Order Traversal II BFS uno reverse card solution 103 Binary Tree Zigzag Level Order Traversal BFS maintain <code>flip = True</code> and <code>flip = not flip</code> on each level\u5373\u53ef solution 314 Binary Tree Vertical Order Traversal BFS 2D matrix for tree, intuition\u662ftree traversal\u4e2d, \u8def\u8fc7left child, matrix\u5f80\u5de6\u6269\u5c551\uff0c\u8def\u8fc7right child, \u5f80\u53f3\u6269\u5c551\uff0c \u53ef\u4ee5\u901a\u8fc7\u8fd9\u4e2a\u6027\u8d28\u77e5\u9053matrix\u7684span solution <p>Warning</p> <p>\u8fd8\u6709\u4e9badvanced traversal method, \u5982Morris Traversal, \u4f46\u662f\u4e0d\u5e38\u8003, \u4e5f\u4e0d\u662f\u5fc5\u987b\u7684.</p>"},{"location":"data_structure/tree/problems/#serializedeserialize","title":"\u7ed3\u6784\u8f6c\u6362\u6811, serialize/deserialize","text":"number \u7c7b\u578b \u601d\u8def solution 297 Serialize and Deserialize Binary Tree 428 Serialize and Deserialize N-ary Tree 449 Serialize and Deserialize BST 1008 Construct Binary Search Tree from Preorder Traversal 105 Construct Binary Tree from Preorder and Inorder Traversal 106 Construct Binary Tree from Inorder and Postorder Traversal 889 Construct Binary Tree from Preorder and Postorder Traversal 426 Convert Binary Search Tree to Sorted Doubly Linked List"},{"location":"data_structure/tree/problems/#bst","title":"BST","text":"number \u7c7b\u578b \u601d\u8def solution 270 Closest Binary Search Tree Value 450 Delete Node in a BST 98 Validate Binary Search Tree 173 Binary Search Tree Iterator 426 Convert Binary Search Tree to Sorted Doubly Linked List 99 Recover Binary Search Tree 108 Convert Sorted Array to Binary Search Tree 95 Unique Binary Search Trees II 96 Unique Binary Search Trees"},{"location":"data_structure/tree/problems/#lca","title":"LCA","text":"number \u7c7b\u578b \u601d\u8def solution 235 Lowest Common Ancestor of a Binary Search Tree 236 Lowest Common Ancestor of a Binary Tree 1644 Lowest Common Ancestor of a Binary Tree II 1650 Lowest Common Ancestor of a Binary Tree III 1676 Lowest Common Ancestor of a Binary Tree IV 1123 Lowest Common Ancestor of Deepest Leaves"},{"location":"data_structure/tree/problems/#_1","title":"\u4fe1\u606f\u4f20\u9012","text":"number \u7c7b\u578b \u601d\u8def solution 257 Binary Tree Paths 1148 Count Good Nodes in Binary Tree 124 Binary Tree Maximum Path Sum 1120 Maximum Average Subtree 1372 Longest ZigZag Path in a Binary Tree 1123 Lowest Common Ancestor of Deepest Leaves 549 Binary Tree Longest Consecutive Sequence II"},{"location":"leetcode/","title":"Index","text":"<p>Welcome to my Leetcode solution.</p>"},{"location":"leetcode/1-two-sum/","title":"1 two sum","text":"<p>LeetCode\u7b97\u6cd5submit\u65f6\uff0c\u4f1a\u7ed9\u4e00\u4e2a\u6bd4\u8f83\u5927\u7684\u7b97\u4f8b\uff0c\u6765\u7b97runtime\u548cmemory consumption\uff0c\u4e3b\u8981\u662f\u7528\u6765\u533a\u5206\u597d\u7684\u7b97\u6cd5\u548c\u5dee\u7684\u7b97\u6cd5</p>","tags":["Array","Hash Table"]},{"location":"leetcode/1-two-sum/#brute-force","title":"Brute force","text":"<p>\u8fd9\u4e00\u9898\u6211\u4e0b\u610f\u8bc6\u7684\u89e3\u6cd5\u662f, traverse\u8fd9\u4e2alist twice with nested loop, \u7136\u540e\u6839\u636e\u9898\u76ee\u505a\u4e24\u4e2aif\u5224\u65ad: - \u4e24\u4e2aelement\u4e4b\u548c\u7b49\u4e8e\u672c\u8eab - \u4e0d\u80fd\u7528\u540c\u6837\u7684element twice \u4e4b\u540e\u53ea\u9700\u8981break out the nested loop\u5c31\u53ef\u4ee5\u4e86, \u4ee3\u7801\u5982\u4e0b</p> <p><pre><code>\"\"\"\nbrute force intuition\n\"\"\"\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -&gt; List[int]:\n        # define return list\n        result = []\n        # define flag variable to breakout nested loop\n        break_out_flag = False\n        for i, item_x in enumerate(nums):\n            for j, item_y in enumerate(nums):\n                # check for two conditions\n                # 1. sum of two variables equals to target\n                # 2. make sure it's not same elements\n                if item_x + item_y == target and i != j:\n                    result.append(i)\n                    result.append(j)\n\n                    # added a flag variable to break out nested loop\n                    break_out_flag = True\n                    break\n            if break_out_flag:\n                break\n\n        return result\n</code></pre> \u8fd9\u4e00\u9898\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u662f\\(O(n^2)\\), \u56e0\u4e3a<code>nums</code>\u7684size\u662fn\uff0c \u7136\u540enested loop\u6bd4\u8f83\u4e86\u6240\u6709\u7684\u60c5\u51b5\uff0c\u4e5f\u5c31\u662f\\(n \\times n\\).</p> <p>\\(O(n^2)\\): quadratic, every element in a collection needs to be compared to every other element.</p> <p>\u5728jerry\u7684\u63d0\u793a\u4e0b\uff0c\u8fd9\u79cdbrute force\u7684\u89e3\u6cd5\u53ef\u4ee5\u8fdb\u884c\u4e00\u6b21\u5c0f\u4f18\u5316\uff0cnested loop\u4e2d\uff0c\u5047\u8bbe\u7b2c\u4e00\u5708\u9700\u8981\u6bd4\u8f83n\u6b21\uff0c\u90a3\u4e48\u7b2c\u4e8c\u5708\u53ea\u9700\u8981\u6bd4\u8f83n-1\uff0c\u76f4\u5230\u6700\u540e\u4e00\u5708\u4e3a1, \u5982\u4e0b\u56fe:</p> <p><pre><code>\u5047\u8bbenums = [1, 2, 3, 4, 5, 6], target = 8\n\n1+2, 1+3, 1+4, 1+5, 1+6\n2+3, 2+4, 2+5, 2+6\n3+4, 3+5, 3+6\n4+5, 4+6\n5+6\n</code></pre> \u65f6\u95f4\u590d\u6742\u5ea6\u7684\u8ba1\u7b97\uff0c\u4e5f\u5c31\u662f\u7b49\u5dee\u6570\u5217\u6c42\u548c $$ \\begin{align} S_n &amp;= (a_1 + a_n)\\frac{n}{2}\\     &amp;= a_1n + \\frac{n(n-1)d}{2} \\end{align} $$ where d is \u516c\u5dee. \u6240\u4ee5\u4f60\u8ba1\u7b97\u4e00\u4e0b\u65f6\u95f4\u590d\u6742\u5ea6\u8fd8\u662f\\(O(n^2)\\), \u5177\u4f53\u5b9e\u73b0\u5982\u4e0b <pre><code>\"\"\"\n\u6539\u8fdb\u7248brute force\n\"\"\"\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -&gt; List[int]:\n        # define return list\n        result = []\n        # define flag variable to breakout nested loop\n        break_out_flag = False\n\n        for i in range(len(nums)):\n            for j in range(i+1,len(nums),1):\n                if nums[i] + nums[j] == target:\n                    result.append(i)\n                    result.append(j)\n                    break_out_flag = True\n                    break\n            if break_out_flag:\n                break\n\n        return result\n</code></pre></p>","tags":["Array","Hash Table"]},{"location":"leetcode/1-two-sum/#two-pass-hash-table","title":"Two-pass Hash table","text":"<p>\u9898\u5e72: \u5728\u4e00\u4e2aarray\u4e2d\uff0c\u627e\u5230\u4e24\u4e2aelement, \u6ee1\u8db3\u8fd9\u4e24\u4e2aelement\u4e4b\u548c\u7b49\u4e8etarget value, \u7136\u540e\u8f93\u51fa\u8fd9\u4e24\u4e2aelement\u7684index, \u4e14\u8fd9\u4e24\u4e2aelement\u5fc5\u987b\u662f\u4e0d\u540c\u7684element;</p> <p>\u7531\u4e8ebrute force\u89e3\u6cd5\u662ftraverse on array with nested loop, \u4e00\u6b21traverse list\u7684\u590d\u6742\u8bfb\u662f\\(O(n)\\), nested\u5219\\(O(n^2)\\). </p> <p>\u601d\u8def\u5c31\u662f\u6362\u4e00\u4e2adata structure, \u63d0\u9ad8\u6548\u7387, \u90a3\u9996\u5148\u53ef\u4ee5\u5c06\u9898\u5e72\u8f6c\u5316\u4e3a\u4e00\u4e2a\u9700\u8981\u6ee1\u8db3\u7684\u6761\u4ef6, \u6761\u4ef6\u5982\u4e0b:</p> <p>\u5728\u4e00\u4e2a\u6570\u636e\u7ed3\u6784\u4e2d\uff0c\u662f\u5426\u5b58\u5728\u4e0d\u76f8\u540c\u7684\u4e24\u4e2aelement, \u6ee1\u8db3\u8fd9\u4e24\u4e2aelement\u4e4b\u548c\u4e3atarget, \u800c\u4e0d\u8003\u8651collision\u7684\u60c5\u51b5\uff0c\u4ee5\u7a7a\u95f4\u6362\u65f6\u95f4\uff0c\u53ef\u4ee5\u9009\u62e9hash\u6765\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898. </p> <p>\u8fd9\u4e2a\u89e3\u6cd5\u53ebtwo-pass hash table \u4e5f\u5c31\u662ftraverse twice - \u7b2c\u4e00\u4e2atraverse, \u5efa\u7acb\u4e00\u4e2ahash table; - \u7b2c\u4e8c\u4e2atraverse, \u627e\u91cc\u9762\u662f\u5426\u5b58\u5728\u7b26\u5408\u6761\u4ef6\u7684element;</p> <p>\u5177\u4f53\u5b9e\u73b0\u65b9\u6cd5\u5982\u4e0b:</p> <pre><code>\"\"\"\ntwo-pass hash table\n\"\"\"\n\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -&gt; List[int]:\n        # declare a hashmap\n        hashmap = {}\n        # initialize the hashmap with key-value pair\n        \"\"\"\n        Example:\n        nums = [5,1,9,10]\n        saves in the form of {value:index}\n        hashmap = {\n            5: 0,\n            1:1,\n            9:2,\n            10:3\n        }\n        \"\"\"\n        for i in range(len(nums)):\n            # value to be key, index be value\n            hashmap[nums[i]] = i\n\n        for i in range(len(nums)):\n            # calculate the condtion needs to be met\n            condition = target - nums[i]\n            # check both conditions\n            # check \u4e3a\u4e86met condition\u7684\u6761\u4ef6\u662f\u5426\u5b58\u5728\u4e8ehash\u4e2d\uff0c\u4ee5\u53cahash\u662f\u5426\u7b49\u4e8e\u5176\u672c\u8eab\n            if condition in hashmap and hashmap[condition] != i:\n                return [i,hashmap[condition]]\n</code></pre> <p>\u5173\u4e8e\u590d\u6742\u5ea6 - \u65f6\u95f4\u590d\u6742\u5ea6: we traverse twice, so the overall time complexity \\(O(n)\\)  - \u7a7a\u95f4\u590d\u6742\u5ea6: \u9700\u8981\u5b58\u4e00\u4e0bhash, \u90a3\u4e48\u9700\u8981\\(O(n)\\)\u7684\u7a7a\u95f4\u590d\u6742\u5ea6</p>","tags":["Array","Hash Table"]},{"location":"leetcode/1-two-sum/#one-pass-hash-table","title":"One-pass Hash Table","text":"<p>\u56de\u60f3\u4e00\u4e0b\u4e0a\u4e00\u4e2a\u89e3\u6cd5, two-pass hash table: - initialize a hashtable (traverse once) - look for condition (traverse)</p> <p>\u8fd9\u4e24\u6b65\u5408\u5e76\u4e3a\u4e00\u6b65\uff0c\u5c31\u662fone-pass hash table, \u73b0\u5728\u6211\u4eec\u53ef\u4ee5\u5728initialize\u7684\u8fc7\u7a0b\u4e2d\u5c06\u4e24\u4e2a\u5408\u5728\u4e00\u8d77, \u53d8\u4e3a: - \u8fb9initialize \u8fb9look for condition  </p> <pre><code>\"\"\"\none-pass hash table\n\"\"\"\n\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -&gt; List[int]:\n        # declare a hashmap\n        hashmap = {}\n        # initialize the hashmap with key-value pair\n        \"\"\"\n        Example:\n        nums = [5,1,9,10]\n        saves in the form of {value:index}\n        hashmap = {\n            5: 0,\n            1:1,\n            9:2,\n            10:3\n        }\n        \"\"\"\n        for i in range(len(nums)):\n            # calculate the condition needs to be met\n            condition = target - nums[i]\n            # check whether the condtion has been met yet\n            if condition in hashmap:\n                return [i, hashmap[condition]]\n            # initialize \n            hashmap[nums[i]] = i\n</code></pre>","tags":["Array","Hash Table"]},{"location":"leetcode/1-two-sum/#_1","title":"\u7b97\u6cd5\u6bd4\u8f83","text":"Solution \u65f6\u95f4\u590d\u6742\u5ea6 \u7a7a\u95f4\u590d\u6742\u5ea6 - - - - - - -","tags":["Array","Hash Table"]},{"location":"leetcode/100-same-tree/","title":"100 Same Tree","text":"<p>Given the roots of two binary trees <code>p</code> and <code>q</code>, write a function to check if they are the same or not.</p> <p>Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.</p> <p>Example <pre><code>    1\n   / \\\n  2   3\n\nVS \n\n    1\n   / \\\n  3   2\n</code></pre></p> <pre><code>output: False\n</code></pre>","tags":["Tree","Depth-First Search","Breadth-First Search","Binary Tree"]},{"location":"leetcode/100-same-tree/#approach-1-bfs","title":"Approach 1 BFS","text":"<p>If a tree <code>p</code> and a tree <code>q</code> are the same, they must possesses the following two conditions</p> <ul> <li>Condition1: tree <code>p</code> and <code>q</code> has the same structure</li> <li>Condition2: values in p and q are the same.</li> </ul> <p>If order to do that, we need to do some sort of traversal to examine the above two conditions. The takeaway for this problem is illustrated in the box in the diagram below</p> <ul> <li>if two nodes are both <code>None</code>, (still valid but we don't want to append None in the queue, so <code>continue</code>)</li> <li>if one of them not None while the other is None, condition 1 not met.</li> <li>if value is not same, condition 2 not met.</li> </ul> <p>Now, you should have a clearer picture on the thought process. </p> <p></p> <pre><code>class Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -&gt; bool:\n        queue = deque([p,q])\n\n        # pass\n        while queue:\n            a = queue.popleft()\n            b = queue.popleft()\n\n            if a is None and b is None: continue\n            if a is None or b is None: return False\n            if a.val != b.val: return False\n\n            # when gets here, a and b are both TreeNode\n            queue.append(a.left)\n            queue.append(b.left)\n            queue.append(a.right)\n            queue.append(b.right)\n\n        return True\n</code></pre>","tags":["Tree","Depth-First Search","Breadth-First Search","Binary Tree"]},{"location":"leetcode/100-same-tree/#approach-2-recursive","title":"Approach 2 Recursive","text":"<pre><code>class Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -&gt; bool:\n        # recursion base cases\n        # 1. \u4e24\u4e2a\u90fd\u662fnone\n        # 2. \u4e00\u4e2a\u662fnone\u53e6\u4e00\u4e2a\u4e0d\u662fnone\n        # 3. \u4e24\u4e2a\u90fd\u662fvalue, \u4f46\u4e0d\u7b49\n        if p is None and q is None:\n            return True\n        if p is None or q is None:\n            return False\n        if p.val != q.val:\n            return False\n\n        # program\u5982\u679c\u8fd8\u80fd\u6267\u884c\u5230\u8fd9\u91cc\uff0c\u53ea\u6709p.val == q.val\u7684\u60c5\u51b5\u4e86,\u8fd9\u79cd\u60c5\u51b5\u5c31\u7ee7\u7eed\u6316\u4e0b\u53bb, \u4e0dreturn boolean, return function\n\n        # \u4e24\u4e2a\u53ea\u8981\u6709\u4efb\u4f55\u4e00\u4e2a\u8fd4\u56de\u7684\u662ffalse, \u90a3\u5c31\u662ffalse\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right,q.right)\n</code></pre>","tags":["Tree","Depth-First Search","Breadth-First Search","Binary Tree"]},{"location":"leetcode/1004-Max-Consecutive-Ones-III/","title":"1004 Max Consecutive Ones III","text":"","tags":["Array","Binary Search","Sliding Window","Prefix Sum"]},{"location":"leetcode/1004-Max-Consecutive-Ones-III/#approach-1-sliding-window","title":"Approach 1 Sliding Window","text":"<pre><code>class Solution:\n    def longestOnes(self, nums: List[int], k: int) -&gt; int:\n        \"\"\"\n        observation:\n        - binary array of 1s and 0s\n        - its &gt;= 0, so we can sliding window\n        \"\"\"\n        left = 0\n        res = 0 \n        num_of_zeros = 0       \n        for right,num in enumerate(nums):\n            if nums[right] == 0:\n                num_of_zeros += 1\n            while num_of_zeros &gt; k:\n                if nums[left] == 0:\n                    num_of_zeros -= 1\n                left += 1\n            # if reach here, it's all valid answer\n            res = max(res, right - left + 1)\n        return res\n</code></pre>","tags":["Array","Binary Search","Sliding Window","Prefix Sum"]},{"location":"leetcode/101-symmetric-tree/","title":"Problem","text":"<p>Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).</p> <p>Example </p> <pre><code>output: True\n</code></pre>"},{"location":"leetcode/101-symmetric-tree/#thought-process","title":"Thought process","text":"<p>Two tree are the same tree if and only if - same structure - same value</p> <p>For symmetric tree, the equivalent conditions are: - same mirrored structure - same mirrored</p> <p>From the template of the BFS, we just need to rearrange the order we insert the node in. <pre><code>       e\n     /   \\\n    a     b\n   / \\   / \\\n  b   c  d  e\n</code></pre></p> <pre><code># order to compare same tree\nqueue.appendleft(a.left)\nqueue.appendleft(b.left)\nqueue.appendleft(a.right)\nqueue.appendleft(b.right)\n\n# order to compare similar tree\nqueue.appendleft(a.left)\nqueue.appendleft(b.right)\nqueue.appendleft(a.right)\nqueue.appendleft(b.left)\n</code></pre> <p>Note: for symmetry, compare the medial side with the lateral side for those into anatomy!</p>"},{"location":"leetcode/101-symmetric-tree/#code","title":"Code","text":"<pre><code># Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nfrom collections import deque\nclass Solution:\n    def isSymmetric(self, root: Optional[TreeNode]) -&gt; bool:\n        # Option 1: convert the problem from symmertric tree\n        # to \"same\" tree by comparing root.left and root.right\n        # just need to twist the inserting order\n\n\n        p = root.left\n        q = root.right\n\n        queue = deque([p,q])\n\n        while queue:\n            # pop two nodes\n            node_1 = queue.popleft()\n            node_2 = queue.popleft()\n\n            if node_1 is None and node_2 is None: continue\n            if node_1 is None or node_2 is None: return False\n            if node_1.val != node_2.val: return False\n\n            # pass \n            queue.appendleft(node_1.left)\n            queue.appendleft(node_2.right)\n            queue.appendleft(node_1.right)\n            queue.appendleft(node_2.left)\n\n\n\n        return True\n</code></pre>"},{"location":"leetcode/1011-capacity-to-ship-packages-within-D-days/","title":"1011 Capacity To Ship Packages Within D Days","text":"","tags":["Array","Binary Search"]},{"location":"leetcode/1011-capacity-to-ship-packages-within-D-days/#approach-1-binary-search","title":"Approach 1 Binary Search","text":"<p>Binary search \u7ecf\u5178\u9898\u76ee, \u5bf9\u7406\u89e3\u5de6\u53f3\u8fb9\u754c\u66f4\u65b0\u6761\u4ef6\u5f88\u6709\u5e2e\u52a9.</p> <ul> <li><code>left,right\u7684\u9009\u62e9</code> \u81f3\u5c11\u9700\u8981<code>max(weights)</code>, \u4e0d\u7136\u8fc7\u4e0d\u4e86\u4e00\u5929\uff1b\u6700\u591a\u9700\u8981<code>sum(weights)</code>, \u4e00\u5929\u5c31\u642c\u5b8c\u5168\u90e8\u4e86.</li> <li><code>helper function(weights,guess)</code>: \u7528\u6765\u8ba1\u7b97\u5728\u8fd9\u4e2a\u642c\u8fd0\u901f\u5ea6<code>guess</code>\u4e0b\uff0c\u9700\u8981\u591a\u5c11\u5929\u642c\u5b8c, \u6bd4\u8f83tricky, \u9700\u8981\u5206\u7c7b\u8ba8\u8bba<ul> <li>\u5982\u679c\u642c\u5b8c\u4eca\u5929\u8fd8\u6709\u5269\u4f59, \u90a3\u4e48\u6211\u4eec\u5c1d\u8bd5\u660e\u5929\u7ee7\u7eed\u642c, <code>i++</code></li> <li>\u5982\u679c\u642c\u5b8c\u4eca\u5929\u6b63\u597d, \u90a3\u4e48\u6211\u4eec\u5c1d\u8bd5\u660e\u5929\u7ee7\u7eed\u642c, \u6240\u9700\u6d88\u8017\u603b\u5929\u6570+1, \u7136\u540e\u6211\u4eec\u80fd\u91cf\u503creset. i.e. <code>i++</code>, <code>days_needed += 1</code>, <code>remaining = daily_capacity</code></li> <li>\u5982\u679c\u642c\u5b8c\u53d1\u73b0\u80fd\u91cf\u4e0d\u8db3\u4ee5\u642c\u5b8c\uff0c\u90a3\u4e48\u6211\u4eec\u4e0a\u4e00\u6b65\u5c31\u5df2\u7ecf\u8017\u5b8c\u6240\u6709\u80fd\u91cf\u4e86, \u6240\u9700\u6d88\u8017\u603b\u5929\u6570+1, \u7136\u540e\u6211\u4eec\u80fd\u91cf\u503creset\u4ee5\u5d2d\u65b0\u7684\u7cbe\u795e\u9762\u8c8c\u91cd\u65b0\u9762\u5bf9\u65b0\u4e00\u5929\u7684\u5de5\u4f5c. i.e. <code>i++</code>, <code>days_needed += 1</code>, <code>remaining = daily_capacity</code></li> </ul> </li> </ul> <p>\u8fd9\u4e2ahelper function\u6709\u4e00\u4e2aedge case\uff0c\u5c31\u662f\u5728\u7b2c\u4e00\u79cd\u60c5\u51b5\u65f6\uff0c\u6211\u4eec\u5df2\u7ecf\u5230\u4e86\u6700\u540e\u4e00\u4e2a\u8d27\u7269 \u56e0\u4e3a\u4e0d\u7ba1\u4f60\u518d\u6709\u591a\u5c11\u80fd\u91cf\uff0c\u5df2\u7ecf\u6ca1\u8d27\u7269\u7ed9\u4f60\u642c\u8fd0\u4e86, \u6240\u4ee5<code>days_needed += 1</code>, \u6536\u5de5!</p> <p>\u5173\u4e8e\u5de6\u53f3\u8fb9\u754c\u7684\u66f4\u65b0, <code>if days_needed(weights,mid) &lt;= days:</code> \u8bf4\u660e\u6211\u4eec\u642c\u8fd0\u901f\u5ea6\u8fc7\u5feb\u4e86\uff0c\u6211\u4eec\u9700\u8981\u66f4\u6162\u4e00\u70b9\uff0c\u4f46\u6211\u4eec\u7684solution space\u80af\u5b9a\u5728\u8fd9\u534a\u5757\uff0c\u56e0\u4e3a\u4e5f\u5b58\u5728<code>days_needed(weights,mid) == days</code>, \u6240\u4ee5\u6211\u4eec\u91c7\u53d6\u6bd4\u8f83\u4fdd\u5b88\u7684\u66f4\u65b0\u7b56\u7565\uff0c\u4ee5\u9632truncate\u6389\u6700\u4f18\u7684solution <code>right = mid</code>.</p> <p><code>if days_needed(weights,mid) &gt; days</code>: \u8bf4\u660e\u6211\u4eec\u642c\u8fd0\u901f\u5ea6\u8fc7\u6162\u4e86\uff0c\u6211\u4eec\u9700\u8981\u66f4\u5feb\u4e00\u70b9. \u56e0\u4e3a<code>days_needed(weights,mid) &gt; days</code>, \u6211\u4eec\u7684solution space\u5fc5\u7136\u4e0d\u5728\u8fd9\u534a\u5757\uff0c\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u66f4aggressive\u7684\u66f4\u65b0. <code>left = mid + 1</code></p> <pre><code>class Solution:\n    def shipWithinDays(self, weights: List[int], days: int) -&gt; int:\n        # find least weight capacity of the ship\n        left,right = max(weights), sum(weights)\n\n        def days_needed(weights,daily_capacity):\n            days_needed = 0\n            remaining = daily_capacity\n\n            i = 0\n            while i &lt; len(weights):\n                remaining -= weights[i]\n                if remaining &gt; 0:\n                    i += 1\n                    # for edge case, \u867d\u7136\u8fd8\u6709capacity,\u4f46\u662f\u5230\u5934\u4e86+1\u5929\n                    if i == len(weights):\n                        return days_needed + 1\n                elif remaining == 0:\n                    # we just found enough, reset our capacity and move on\n                    days_needed += 1\n                    remaining = daily_capacity\n                    i += 1                    \n                else:\n                    # we can't do today, \u91cd\u5934\u518d\u6765\u4e00\u6b21\n                    days_needed += 1\n                    remaining = daily_capacity\n\n            return days_needed\n\n        while left &lt; right:\n            mid = (left + right)//2\n            if days_needed(weights,mid) &lt;= days:\n                # \u592a\u5feb\u4e86, \u7b54\u6848\u5728\u8fd9\u4e2asolution space\u91cc\uff0cpropogate strategy mild\u4e00\u70b9\n                right = mid\n            else:\n                # \u592a\u6162\u4e86\n                left = mid + 1\n\n        return left\n</code></pre>","tags":["Array","Binary Search"]},{"location":"leetcode/1014-best-sightseeing-pair/","title":"Approach: bottom-up, linear space","text":""},{"location":"leetcode/1014-best-sightseeing-pair/#brute-force-and-intuition","title":"Brute force and intuition","text":"<p>The problem is asking for maxium score of any pair inside an array with constain <code>(i&lt;j)</code>. The brute force would be searching any pair (1 + 2 + 3 + ... + n) \\(\\approx O(n^2)\\) and calculate score (\\(O(1)\\)). </p> <p>It is suggesting that the implemented DP solution won't be \\(O(n^2)\\) like LIS that requires nested loop. So my thought process is to drop some unnecessary operations to minimize the time complexity.  $$ \\begin{align} score &amp;= \\mathrm{values[i] + i + values[j] - j}\\  &amp;= f(i) + f(j)\\ \\end{align} $$ where \\(f(i)\\) is a function of i and \\(f(j)\\) is a function of j only.</p> <p>Therefore, when we are traversing the array, the score of (i,j) depends on both i and j. But if we could keep track of the best index so far, we don't have to compare every single of index i &lt; j.</p> <p>this idea is sort of like how <code>best sum</code> is equal to <code>best prefix sum</code> and <code>best postfix sum</code></p>"},{"location":"leetcode/1014-best-sightseeing-pair/#definion-of-dp","title":"Definion of DP","text":"<ul> <li><code>initialization</code>: all zeros or <code>float(\"-inf\")</code> depending on the constrains given.</li> <li><code>base case</code>: DP[0] = 0</li> <li><code>DP[j]</code>: the maximum score one could get for the pair where it's (nums[i], nums[j])</li> <li><code>state transition function</code>: with keeping tracking of best index, the current step <code>j</code> only depends one particular index <code>x</code> that gives the best condition but not depending on previous DP. $$ \\mathrm{DP[j] = values[j] + j - values[x] - x} $$</li> </ul> <pre><code># O(n), O(n) solution\nclass Solution:\n    def maxScoreSightseeingPair(self, values: List[int]) -&gt; int:\n        # brute force would go through every single pair in the array, O(n^2)\n        # DP[j]: the maximum score you could get for the pair where it's (nums[i], nums[j])\n\n        if len(values) == 2: return values[1] + values[0] + 0 - 1\n\n        # intiialze DP wizhe zeros\n        DP = [0 for _ in range(len(values))]\n\n        # find the prefix i that will give us highest score.\n        best_prefix_i = 0\n\n\n        for j in range(1,len(values)):\n            if values[j-1] + j-1 &gt;= values[best_prefix_i] + best_prefix_i:\n                best_prefix_i = j-1\n            DP[j] = best_prefix_i + values[best_prefix_i] + values[j] - j\n\n        return max(DP)\n</code></pre> <p>with slight opimization,  <pre><code># O(n), O(1) solution\nclass Solution:\n    def maxScoreSightseeingPair(self, values: List[int]) -&gt; int:\n        # brute force would go through every single pair in the array, O(n^2)\n\n        if len(values) == 2: return values[1] + values[0] + 0 - 1\n\n        # find the prefix i that will give us highest score.\n        best_prefix_i = 0\n        global_max = 0\n\n        for j in range(1,len(values)):\n            if values[j-1] + j-1 &gt;= values[best_prefix_i] + best_prefix_i:\n                best_prefix_i = j-1\n            curr_max = best_prefix_i + values[best_prefix_i] + values[j] - j\n            if curr_max &gt; global_max: global_max = curr_max\n\n        return global_max\n</code></pre></p>"},{"location":"leetcode/103-binary-tree-zigzag-level-order-traversal/","title":"103. Binary Tree Zigzag Level Order Traversal","text":"<p>We don't know how to implement BFS in zigzag order but we could start from simpler BFS traversal. </p> <p>For BFS, we are going to need,</p> <ul> <li>queue as an auxillary to temporary hold the node</li> </ul> <p></p> <p>After we figure the regular BFS out for the tree diagram above, we will have <pre><code># BFS\n[\n    [25],\n    [15,50],\n    [10,22,35,70]\n]\n\n# BFS zigzag expected output\n[\n    [25],\n    [50,15],\n    [10,22,35,70]\n]\n</code></pre> From observation, we just need to reverse the even rows to get the output for zigzag.</p>","tags":["Tree","Binary Tree","Breadth-First Search"]},{"location":"leetcode/103-binary-tree-zigzag-level-order-traversal/#approach-1-bfs","title":"Approach 1 BFS","text":"<pre><code># Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nfrom collections import deque\n\nclass Solution:\n    def zigzagLevelOrder(self, root: Optional[TreeNode]) -&gt; List[List[int]]:\n\n        if root is None: return []\n\n        queue = deque([root]) \n        levels = []\n        # if flag is even left to right; if flag odd, right to left\n        reverse_flag = 0 \n\n        while queue:\n            levels.append([])\n\n            for _ in range(len(queue)):\n                node = queue.popleft()\n                levels[-1].append(node.val)\n\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n\n            if reverse_flag % 2 == 1:\n                levels[-1].reverse()\n            reverse_flag += 1\n\n        return levels\n</code></pre>","tags":["Tree","Binary Tree","Breadth-First Search"]},{"location":"leetcode/104-maximum-depth-of-binary-tree/","title":"104 Maximum Depth of Binary Tree","text":"","tags":["Tree","Depth-First Search","Breadth-First Search","Binary Tree"]},{"location":"leetcode/104-maximum-depth-of-binary-tree/#approach-1-dfs-with-recursion","title":"Approach 1 DFS with Recursion","text":"<pre><code>class Solution:\n    def maxDepth(self, root: TreeNode) -&gt; int:\n        if not root:\n            return 0\n        if not root.left and not root.right:\n            return 1\n        left_height = 1 + self.maxDepth(root.left)\n        right_height = 1 + self.maxDepth(root.right)\n        return max(left_height , right_height)\n</code></pre>","tags":["Tree","Depth-First Search","Breadth-First Search","Binary Tree"]},{"location":"leetcode/104-maximum-depth-of-binary-tree/#approach-2-dfs-iteration-stack","title":"Approach 2 DFS (iteration) + stack","text":"","tags":["Tree","Depth-First Search","Breadth-First Search","Binary Tree"]},{"location":"leetcode/104-maximum-depth-of-binary-tree/#approach-3-bfs-iteration-queue","title":"Approach 3 BFS (iteration) + queue","text":"","tags":["Tree","Depth-First Search","Breadth-First Search","Binary Tree"]},{"location":"leetcode/1043-partition-array-for-maximum-sum/","title":"1043 Partition Array for Maximum Sum","text":""},{"location":"leetcode/1043-partition-array-for-maximum-sum/#approach-1-memoization","title":"Approach 1 Memoization","text":"<p>memoization solution, \u5176\u5b9e\u66f4\u503c\u5f97\u5b66\u4e60\u3002\u4e0d\u4ec5memo\u662fdp\u7684\u57fa\u7840\uff0c\u4e24\u4e2a\u662ftransferable\u7684\uff0c\u800c\u4e14\u8fd9\u4e2a\u5206\u89e3\u5b50\u95ee\u9898\u7684tree problem\u601d\u60f3\uff0c\u53ef\u4ee5\u8986\u76d6\u5230\u5f88\u591a\u9898\u578b.</p>"},{"location":"leetcode/1043-partition-array-for-maximum-sum/#approach-2-bottom-up-dp","title":"Approach 2 Bottom Up DP","text":"<p>Dp\u6700\u96be\u7684\u5730\u65b9\u5728\u4e8e\uff0c\u6839\u636e\u4f60\u7684</p> <ul> <li>state definition</li> <li>initial condition</li> <li>state transition function</li> </ul> <p>\u4f1a\u5728iterator, + i, + j - i + 1\u7b49\u5404\u4e2a\u65b9\u9762\u7ed9\u4f60\u5f88\u591atroubles. \u6240\u4ee5\u6211\u4eec\u8fd9\u4e00\u9898\u4f1a\u5c1d\u8bd5, </p> <ul> <li>\u6b63\u5411,\u9006\u5411iterate</li> <li>\u4e0d\u540cdp state\u5b9a\u4e49</li> </ul>"},{"location":"leetcode/1043-partition-array-for-maximum-sum/#approach-21","title":"Approach 2.1","text":"<p>If you look at the example, </p> <pre><code>Input: arr = [1,15,7,9,2,5,10], k = 3\nOutput: 84\nExplanation: arr becomes [15,15,15,9,10,10,10]\n</code></pre> <p>\u901a\u8fc7\u8fd9\u4e2a\u4f8b\u5b50\uff0c\u6211\u4eec\u53ef\u4ee5\u6709, <pre><code>dp[0] = 0\ndp[1] = max(dp[0] + 1*1)  # 2 &lt;-\ndp[2] = max(dp[0] + 15*2, # 30 &lt;-\n            dp[1] + 15*1) # 17\ndp[3] = max(dp[0] + 15*3, # 45 &lt;-\n            dp[1] + 15*2, # 32 \n            dp[2] + 7*1)  # 37\n# alway has max 3 sub problem to compare          \ndp[4] = max(dp[1] + 15*3, # 47\n            dp[2] + 9*2,  # 48\n            dp[3] + 9*1)  # 54 &lt;-\n</code></pre></p> <p>\u770b\u4ee5\u4e0b\u56fe\u89e3,  - <code>dp[i]:</code>    - \u4ee3\u8868\u524di\u4e2a\u6570\u7684\u590d\u5408\u6761\u4ef6\u7684\u6700\u5927\u548c - <code>initial condition:</code>    - <code>dp[0] = 0</code>, \u4e5f\u5c31\u662f\u524d0\u4e2a\u6570\u7684\u6700\u5927\u548c\u662f0, arr\u4e3a\u7a7a\u96c6.   - \u8fd9\u4e2a\u6280\u5de7\u53eb\u505aleft padding, \u4e3b\u8981\u662f\u4e3a\u4e86\u65b9\u4fbf\u8fd0\u7b97 - <code>state transition function:</code>   - <code>dp[i] = max(dp[i-k] + max(arr[i-k+1, i]) * k) for 1 &lt;= k &lt;= min(i,k)</code></p> <p></p> <pre><code>class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -&gt; int:\n        dp = [0 for _ in range(len(arr)+1)]\n        dp[0] = 0\n\n        for i in range(1,len(arr)+1):\n            curr_max = -1\n            for j in range(1,min(i,k)+1):\n                curr_max = max(curr_max,arr[i-j])\n                dp[i] = max(dp[i],dp[i-j] + j * curr_max)\n\n        return dp[-1]\n</code></pre>"},{"location":"leetcode/1043-partition-array-for-maximum-sum/#reference","title":"Reference","text":"<ul> <li>huahua</li> </ul>"},{"location":"leetcode/1046-last-stone-weight/","title":"1046 Last Stone Weight","text":"","tags":["Array","Heap (Priority Queue)"]},{"location":"leetcode/1046-last-stone-weight/#approach-1-max-heap","title":"Approach 1 Max Heap","text":"<pre><code>from heapq import heapify,heappush,heappop\nclass Solution:\n    def lastStoneWeight(self, stones: List[int]) -&gt; int:\n        # O(n * nlogn)\n        # (n)log(n) + (n-1)log(n-1) + ... + (1)log(1)\n        # target characteristics of DS:\n        # 1 reduce the cost to maintain the sorted structure\n        # 2.fast retrivel for maximum \n        # ---&gt; heap \n        # put in negative number to simulate a max heap\n\n        # 1. negagte the stones and heapify the stones\n        # 2. pop the stones, unnegagte them.\n        #    2.1 when equal, we do nothing,\n        #    2.2 when not equal, get the difference of it and put it back\n        # 3. go back to step 1 if it has only one stone left or no stones left\n\n        neg_stones = [-1 * stone for stone in stones]\n        heapify(neg_stones)\n\n        while len(neg_stones) &gt; 1:\n            first = heappop(neg_stones)\n            second = heappop(neg_stones)\n\n            if first != second:\n                # we put it back\n                new_stone = first - second\n                heappush(neg_stones,new_stone)\n\n        if (len(neg_stones)) == 1:\n            return -1 * neg_stones[0]\n        else:\n            return 0\n</code></pre>","tags":["Array","Heap (Priority Queue)"]},{"location":"leetcode/107-binary-tree-level-order-traversal-II/","title":"107 Binary Tree Level Order Traversal II","text":"","tags":["Tree","Breadth-First Search","Binary Tree"]},{"location":"leetcode/107-binary-tree-level-order-traversal-II/#approach-1-bfs","title":"Approach 1 BFS","text":"<p>solve it as regular BFS then we reverse the output by <code>res[::-1]</code> or <code>res.reverse()</code>, as illustrated in the figure below</p> <p></p>","tags":["Tree","Breadth-First Search","Binary Tree"]},{"location":"leetcode/107-binary-tree-level-order-traversal-II/#code","title":"Code","text":"<pre><code>from collections import deque\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def levelOrderBottom(self, root: Optional[TreeNode]) -&gt; List[List[int]]:\n        \"\"\"\n        top to bottom BFS, then UNO reverse card res[::-1]\n        \"\"\"\n        if not root:\n            return root\n\n        queue = deque([root])\n        levels = []\n\n        while queue:\n            level = []\n            for _ in range(len(queue)):\n                curr = queue.pop()\n                level.append(curr.val)\n                if curr.left:\n                    queue.appendleft(curr.left)\n                if curr.right:\n                    queue.appendleft(curr.right)\n            levels.append(level)\n        return levels[::-1] \n</code></pre>","tags":["Tree","Breadth-First Search","Binary Tree"]},{"location":"leetcode/1074-number-of-submatrices-that-sum-to-target/","title":"Intuition","text":"<p>As for brute force solution, we need to iterate every single possible submatrics and sum each submatix to see if it equals to target. This will take \\(O(n^4)\\) time complexity.</p> <p>Now we need to think about a trick to solve it and its prefix-sum.</p>"},{"location":"leetcode/1074-number-of-submatrices-that-sum-to-target/#approach","title":"Approach","text":""},{"location":"leetcode/1074-number-of-submatrices-that-sum-to-target/#prefix-sum-matrix","title":"Prefix Sum matrix\u7684\u6784\u5efa","text":"<p>Prefix sum, \u8fd9\u4e2atrick\u53ef\u4ee5\u51cf\u5c11\u5f88\u591a\u91cd\u590d\u7684\u8ba1\u7b97\uff0c\u5b9a\u4e49\u4e00\u4e2a<code>prefix_sum[i][j]</code>, </p> <p><code>prefix_sum[i][j]</code> = sum of all elements in the submatrix from <code>(0,0)</code> to <code>(i,j)</code> (top left to bottom right)</p> <p>\u751a\u81f3\u5728\u8ba1\u7b97prefix_sum\u65f6\uff0c\u53ef\u4ee5\u7528\u5230\u8fd9\u4e2atrick, </p> \\[ prefix\\_sum[i][j] = matrix[i][j] + prefix\\_sum[i-1][j] + prefix\\_sum[i][j-1] - prefix\\_sum[i-1][j-1] \\]"},{"location":"leetcode/1074-number-of-submatrices-that-sum-to-target/#hashmap","title":"Hashmap\u7684\u6784\u5efa","text":"<p>\u9996\u5148\u8fd8\u662f\u8981\u5ef6\u4f38\u4e00\u4e0b560 subarray sum equals K\u4e2d\u7684prefix sum + hash\u601d\u8deffor array, \u8fd9\u91cc\u662f\u51762D\u5ef6\u4f38.</p> <p>\u5728\u4e00\u4e2a\u77e9\u9635\u5f53\u4e2d\uff0c\u4efb\u4f55\u4e00\u4e2asubmatrix\u90fd\u53ef\u4ee5\u7531\u4e24\u4e2a\u5176\u5b83submatrix\u7684\u5dee\u503c\u6765\u6784\u5efa\u51fa\u6765.</p> <p>\u4e5f\u5c31\u662f\u8bf4\uff0c\u4efb\u4f55\u4e00\u4e2asubmatrix\u7684\u548c\uff0c\u90fd\u53ef\u4ee5\u7531\u5176\u5b83\u4e24\u4e2asubmatrix\u7684\u548c\u7684\u5dee\u503c\u6765\u6784\u5efa\u51fa\u6765. \u8fd9\u4e5f\u662fprefix sum\u7684\u57fa\u672c\u7406\u8bba. \u4f46\u6211\u4eec\u770b\u770b\u8fd9\u4e24\u4e2asubmatix\u6709\u4ec0\u4e48\u8981\u6c42\u5462? </p> <p>For a matrix with (r1,c1) as top left corner and (r2,c2) as bottom right corner, \u6211\u4eec\u53ea\u80fd\u7528, - <code>matrix 1</code>: \u4ee5(0,c1)\u4e3a\u5de6\u4e0a\u89d2\uff0c(r2,c2)\u4e3a\u53f3\u4e0b\u89d2\u7684matrix (\u5927\u7684\u90a3\u4e2a) - <code>matrix 2</code>: \u4ee5(r1-1,c1)\u4e3a\u5de6\u4e0a\u89d2\uff0c(r1,c2)\u4e3a\u53f3\u4e0b\u89d2\u7684matrix (\u5c0f\u7684\u90a3\u4e2a)</p> <pre><code>from collections import defaultdict\nclass Solution:\n    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -&gt; int:\n        # prefix_sum\u77e9\u9635: \u50a8\u5b58\u4ee5(i,j)\u4e3abottom right corner, (0,0)\u4e3atop left corner\u4e3a\u5b9a\u4e49\u7684\u77e9\u9635\u4e4b\u548c\n        # \n\n        ROWS,COLS = len(matrix), len(matrix[0])\n        prefix_sum = [[0 for _ in range(COLS)] for _ in range(ROWS)]\n\n        # O(m*n)\n        for r in range(ROWS):\n            for c in range(COLS):\n                top = prefix_sum[r-1][c] if r &gt; 0 else 0\n                left = prefix_sum[r][c-1] if c &gt; 0 else 0\n                top_left = prefix_sum[r-1][c-1] if c &gt; 0 and r &gt; 0 else 0\n                prefix_sum[r][c] = matrix[r][c] + top + left - top_left\n\n        res = 0\n        for r1 in range(ROWS):\n            for r2 in range(r1,ROWS):\n                # initialize an empty hashmap with base case 0 -&gt; 1\n                # the hashmap count is only valid for matrix with r1, r2 \u9501\u6b7b\u4e86row, \u4f46\u662fcol\u53ef\u4ee5\u53d8\u7684\u60c5\u51b5\n                count = defaultdict(int)\n                count[0] = 1\n                for c in range(COLS):\n                    # cur_sum:\u4ee5(r1,0)\u4e3a\u5de6\u4e0a\u89d2\uff0c(r2,c)\u4e3a\u53f3\u4e0b\u89d2\u7684matrix\u7684\u503c                   \n                    cur_sum = prefix_sum[r2][c] - (\n                        prefix_sum[r1-1][c] if r1 &gt; 0 else 0\n                    )\n                    diff = cur_sum - target\n                    res += count[diff]\n                    # update accumulative sum\n                    count[cur_sum] += 1\n        return res\n</code></pre>"},{"location":"leetcode/11-container-with-most-water/","title":"11 Container with Most Water","text":"<p>\u8d2a\u5fc3 + two pointers\u7684\u9898\u76ee</p>","tags":["Array","Two Pointers","Greedy"]},{"location":"leetcode/11-container-with-most-water/#approach-1-two-pointers-greedy","title":"Approach 1: Two Pointers + Greedy","text":"<p>\u6211\u4eec\u7684\u76ee\u6807\u51fd\u6570\u662f\u83b7\u5f97container\u80fd\u88c5\u6700\u591a\u7684\u6c34\uff0c\u4e5f\u5c31\u662fmaximize volume. \u6211\u4eec\u53ef\u4ee5\u7528\u4e24\u4e2a\u6307\u9488\uff0c\u4e00\u4e2a\u6307\u5411\u5de6\u8fb9\uff0c\u4e00\u4e2a\u6307\u5411\u53f3\u8fb9\uff0c\u7136\u540e\u6211\u4eec\u8ba1\u7b97\u5f53\u524d\u7684volume\uff0c\u7136\u540e\u9009\u62e9\u4e00\u4e2a\u65b9\u5411\u79fb\u52a8\u3002\u9009\u62e9\u79fb\u52a8\u7684\u8fd9\u4e2a\u51b3\u5b9a\uff0c\u5c31\u662f\u8fd9\u4e00\u9898\u7684\u8003\u70b9\uff0c\u8d2a\u5fc3\u7684\u7b56\u7565, \u4f53\u79ef\u8ba1\u7b97\u516c\u5f0f\u5982\u4e0b\uff0c </p> \\[ \\text{volume} = \\text{width} \\times \\text{height} \\] <p>\u968f\u7740\u6211\u4eec\u6307\u9488\u4e0d\u65ad\u5411\u4e2d\u95f4\u5185\u7f29\uff0c\u6211\u4eec\u7684\u5bbd\u5ea6\u90fd\u5728\u53d8\u5c0f\uff0c\u4e3a\u4e86\u4f7f\u6211\u4eec\u7684\u4f53\u79ef\u6709\u53d8\u5927\u7684\u53ef\u80fd\uff0c\u6211\u4eec\u5fc5\u987b\"\u4fee\u8865\"\u6211\u4eec\u8f83\u77ed\u7684\u90a3\u4e00\u4fa7\uff0c\u6240\u4ee5\u8bf4\u6211\u4eec\u7684\u8d2a\u5fc3\u7b56\u7565\u662f\u79fb\u52a8\u8f83\u77ed\u7684\u90a3\u4e00\u4fa7\u6307\u9488\uff0c\u8fd9\u6837\u6211\u4eec\u624d\u6709\u53ef\u80fd\u627e\u5230\u66f4\u5927\u7684\u4f53\u79ef.</p>","tags":["Array","Two Pointers","Greedy"]},{"location":"leetcode/11-container-with-most-water/#code-implementation","title":"Code Implementation","text":"<pre><code>class Solution:\n    def maxArea(self, height: List[int]) -&gt; int:\n        # volume = width * min(height_l,height_r), then we move the min pointer\n        # since width decreases, we have to \"fix\" our shortest stack\n        l, r = 0,len(height)-1\n        best = 0\n\n        while l &lt; r:\n            curr_volume = min(height[l],height[r]) * (r-l)                \n            best = max(best,curr_volume)\n            if height[l] &lt; height[r]:\n                l += 1\n            else:\n                r -= 1\n\n\n        return best\n</code></pre>","tags":["Array","Two Pointers","Greedy"]},{"location":"leetcode/1108-defanging-an-ip-address/","title":"Intuition","text":"<p>\u611f\u89c9\u8fd9\u9898\u7528python\u7684built-in function, <code>string.replace()</code> \u6709\u4e9bcheating.</p>"},{"location":"leetcode/1108-defanging-an-ip-address/#approach","title":"Approach","text":""},{"location":"leetcode/1108-defanging-an-ip-address/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: O(n)</li> </ul> <ul> <li>Space complexity: O(1)</li> </ul>"},{"location":"leetcode/1108-defanging-an-ip-address/#code","title":"Code","text":"<pre><code>class Solution:\n    def defangIPaddr(self, address: str) -&gt; str:\n\n        output = address.replace(\".\",\"[.]\")\n\n        return output\n</code></pre>"},{"location":"leetcode/113-path-sum-II/","title":"Problem","text":"<p>Given the <code>root</code> of a binary tree and an integer <code>targetSum</code>, return all root-to-leaf paths where the sum of the node values in the path equals <code>targetSum</code>. Each path should be returned as a list of the node values, not node references.</p> <p>A root-to-leaf path is a path starting from the root and ending at any leaf node. A leaf is a node with no children.</p>"},{"location":"leetcode/113-path-sum-II/#algorithm","title":"Algorithm","text":"<p>DFS with a stack of tuple that  <pre><code># a tuple carries three information\n(TreeNode(), list(), int)\n\n# explain\n(node, [all the nodes value until this point], currSumTillThisNode)\n</code></pre></p> <ul> <li>initial condition: (root, [], 0)</li> <li>state transition function:</li> <li>for <code>list()</code>, append node.val to ti</li> <li>for <code>int</code>, track the current sum in this particular root-to-leaf path; This is tracked for evaluation with targetSum</li> </ul>"},{"location":"leetcode/113-path-sum-II/#code","title":"Code","text":"<pre><code># Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def pathSum(self, root: Optional[TreeNode], targetSum: int) -&gt; List[List[int]]:\n        # sum of the node values in the path\n        # tuple design: (node, [list so far])\n        # DFS\n        # Time: O(n)\n        # Space:\n\n        if root is None: return []\n\n        stack, res = [(root,[],0)], []\n\n        while stack:\n            node,prevSumPath,prevSum = stack.pop()\n            # spin up a new list\n            currSumPath = prevSumPath.copy()\n            # update information in current time step\n            currSumPath.append(node.val)\n            currSum = prevSum + node.val\n\n            # check if leaf node\n            if node.left is None and node.right is None and currSum == targetSum:\n                res.append(currSumPath)\n\n\n            # check left\n            if node.left:\n                stack.append((node.left, currSumPath,currSum))\n\n            # check right\n            if node.right:\n                stack.append((node.right, currSumPath,currSum))\n\n        return res\n</code></pre>"},{"location":"leetcode/1134-Armstrong%20Number/","title":"1134 Armstrong Number","text":"<p>For simple question, interviewer tends to ask you questions with constraints - solve it without any built in or library funciton</p> <p>\u8fd9\u662f\u953b\u70bc\u4f60solving problem with constraints\u7684\u80fd\u529b;</p> <p>trick: log\u53ef\u4ee5\u7528\u6765\u83b7\u53d6number of digit</p> <p>$$ \\begin{align*} log_{10}1 = 0\\ log_{10}2 = 0.301\\ log_{10}9 = 0.954\\ log_{10}10 = 1\\ log_{10}99 = 1.995\\ log_{10}100 = 2\\ \\dots\\ log_{10}1000 = 3\\</p> <p>\\end{align*} $$</p>"},{"location":"leetcode/1134-Armstrong%20Number/#algorithm","title":"Algorithm","text":"<ul> <li>get the number of digits in <code>n</code> for calculating <code>floor(log10n) + 1</code> </li> <li>call <code>getSumOfKthPowerDigits()</code> by using the digit rolling trick with <code>n%10</code> and <code>n/10</code></li> </ul>"},{"location":"leetcode/1137-N-th-Tribonacci-number/","title":"1137 N-th Tribonacci number","text":"","tags":["Math","Dynamic Programming","Memoization"]},{"location":"leetcode/1137-N-th-Tribonacci-number/#approach-1-dp-bottom-up","title":"Approach 1 DP bottom-up","text":"<p>current state information is dependent on the previous 3 states. </p> <p>Complexity</p> <ul> <li>Time complexity : \\(O(n)\\)</li> <li>Space complexity : \\(O(1)\\)</li> </ul>","tags":["Math","Dynamic Programming","Memoization"]},{"location":"leetcode/1137-N-th-Tribonacci-number/#code-implementation","title":"Code Implementation","text":"<pre><code>class Solution:\n    def tribonacci(self, n: int) -&gt; int:\n        if n == 0: return 0\n        if n == 1 or n == 2: return 1\n\n        prevprev,prev,curr = 0,1,1\n\n        for _ in range(2,n):\n            temp = prevprev + prev + curr            \n            curr,prev,prevprev = temp,curr,prev\n\n        return curr\n</code></pre>","tags":["Math","Dynamic Programming","Memoization"]},{"location":"leetcode/1137-N-th-Tribonacci-number/#approach-2-memoization","title":"Approach 2 Memoization","text":"<pre><code>class Solution:\n    # initialize the lookup table\n    cache = {0:0,1:1,2:1}\n\n    def tribonacci(self, n: int) -&gt; int:\n        # base case\n        if n in self.cache:\n            return self.cache[n]\n\n        self.cache[n] = self.tribonacci(n-1) + self.tribonacci(n-2) + self.tribonacci(n-3)\n\n        return self.cache[n]\n</code></pre>","tags":["Math","Dynamic Programming","Memoization"]},{"location":"leetcode/1150-check-if-a-number-is-majority-element-in-a-sorted-array/","title":"Intuition","text":"<p>Since list is sorted, binary search comes to my mind. This is a variation of binary search problem.</p>"},{"location":"leetcode/1150-check-if-a-number-is-majority-element-in-a-sorted-array/#approach","title":"Approach","text":"<ul> <li>use binary search to find target<ul> <li>if not found, <code>return False</code> </li> <li>if found<ul> <li>create two pointers <code>midToLeft</code> and <code>midToRight</code></li> <li>moves these pointers to the left and tight until reaches the end of the array or <code>nums[midToLeft] != target</code>.</li> <li>calculate the total length and compare with half of the array</li> </ul> </li> </ul> </li> </ul>"},{"location":"leetcode/1150-check-if-a-number-is-majority-element-in-a-sorted-array/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: <code>O(logn)</code></li> </ul> <ul> <li>Space complexity: <code>O(1)</code></li> </ul>"},{"location":"leetcode/1150-check-if-a-number-is-majority-element-in-a-sorted-array/#code","title":"Code","text":"<pre><code>class Solution:\n    def isMajorityElement(self, nums: List[int], target: int) -&gt; bool:\n        # intuition: binary search to find target; if found, radiates out from mid to find its length\n\n        left = 0\n        right = len(nums) - 1\n\n\n        while left &lt;= right:\n            mid = left + (right - left)//2\n\n            # target found!\n            if nums[mid] == target:\n\n                midToLeft = mid\n                midToRight = mid\n\n                # move pointer to left and right till boundary or target not found\n                while midToLeft - 1 != -1 and nums[midToLeft-1] == target:\n                    midToLeft -= 1                    \n\n                while midToRight + 1 != len(nums) and nums[midToRight+1] == target:\n                    midToRight += 1\n\n\n                return (midToRight - midToLeft + 1) &gt; len(nums)//2\n\n\n            if nums[mid] &gt; target:\n                # search space to the left\n                right = mid -1\n            elif nums[mid] &lt; target:\n                # search space to the right\n                left = mid + 1\n\n        # target not found\n        return False        \n</code></pre>"},{"location":"leetcode/1171-remove-zero-sum-consecutive-nodes-from-linked-list/","title":"1171 Remove Zero Sum Consecutive Nodes from Linked List","text":"<p>Take home from this question</p> <ul> <li>how to enumerate subsequence in a linked list using two pointers and while loop </li> <li>how to use dummy head node to simplify the boundary condition</li> </ul>","tags":["Linked List","Hash Table"]},{"location":"leetcode/1171-remove-zero-sum-consecutive-nodes-from-linked-list/#approach-1-brute-force","title":"Approach 1 Brute Force","text":"<p>Brute force solution will be enumerating all possible subsequence and check if the sum of those subsequence is equal to 0. If it is, then we remove the subsequence from the list. In order to enumerate subsequence in a linked list, we have to</p> <ul> <li>initialize a dummy head node and point it to the head of the linked list</li> <li>initialize a left and right pointer, where left is the start of the subsequence and right is the end of the subsequence. It's left hand exclusive ,right hand inclusive <code>(left, right]</code></li> </ul> <p>Effect of dummy head node</p> <p>\u6ca1\u6709dummy head node, \u6211\u4eec\u9700\u8981\u8003\u8651boundary\u7684\u7279\u6b8a\u60c5\u51b5\u4ee5\u53cainterior nodes\u7684\u60c5\u51b5, \u6709\u4e86dummy head node, \u6211\u4eec\u53ef\u4ee5\u7edf\u4e00\u5904\u7406\u6240\u6709\u7684\u60c5\u51b5 as interior nodes. In the context of insertion and deletion in linked list, it's always easier to have a dummy head node. \u800c\u8fd9\u4e00\u9898\u662fenumerating subsequence + deletion, \u6240\u4ee5dummy head node\u4e5f\u662fhighly suggested.</p> <p>\u5982\u4e0b\u56fe\u6240\u793a, <code>left</code> pointer points at dummy head node, <code>right</code> pointer points at the first node of the linked list. </p> <p></p> <p>enumerate\u7ed3\u679c\u5982\u4e0b</p> <ul> <li>first round: [1], [1,2], [1,2,-3], [1,2,-3,3], [1,2,-3,3,1]</li> <li>second round: [2], [2,-3], [2,-3,3], [2,-3,3,1]</li> <li>...\u4ee5\u7b2c\u4e09\u4e2a\u5143\u7d20\u5f00\u59cb</li> </ul>","tags":["Linked List","Hash Table"]},{"location":"leetcode/1171-remove-zero-sum-consecutive-nodes-from-linked-list/#code-implementation","title":"Code Implementation","text":"<pre><code># Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def removeZeroSumSublists(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:\n        # all subarray's sum that equal to zero\n        dummy = ListNode(0,head)\n        left = dummy\n\n        # O(n^2) (start,end]\n        while left is not None:\n            # reset the prefix\n            prefix_sum = 0\n            right = left.next\n\n            while right is not None:\n                prefix_sum += right.val\n                # delete consecutive sequence that sum up to 0\n                if prefix_sum == 0:\n                    left.next = right.next\n                right = right.next\n            # move to next start\n            left = left.next\n        return dummy.next\n</code></pre>","tags":["Linked List","Hash Table"]},{"location":"leetcode/1171-remove-zero-sum-consecutive-nodes-from-linked-list/#approach-2-prefix-sum-hash-table","title":"Approach 2 Prefix Sum Hash Table","text":"<p>\u5982\u4e0b\u56fe\uff0c\u5982\u679c\u6211\u4eec\u8ba1\u7b97prefix sum,</p> <p></p> prefix sum 1 5 8 5 10 16 node value 1\ufe0f 4 3 -3 5 6 <p>\u6211\u4eec\u53d1\u73b0\u6709\u4e24\u4e2aprefix sum\u662f\u76f8\u540c\u7684\uff0c\u90a3\u4e48\u8fd9\u4e24\u4e2aprefix sum\u4e4b\u95f4\u7684subsequence sum up to 0.</p> <p></p> <p>\u6709\u4e86\u8fd9\u4e2a\u53d1\u73b0\uff0c\u6211\u4eec\u53ef\u4ee5\u628afind subsequence sum up to 0\u7684\u95ee\u9898\u8f6c\u5316\u4e3afind duplicate prefix sum\u7684\u95ee\u9898\u3002\u6211\u4eec\u53ef\u4ee5\u7528hash table\u6765\u5b58\u50a8prefix sum\u4ee5\u53ca\u5bf9\u5e94\u7684node\u3002\u4e3a\u4ec0\u4e48\u4f18\u5148\u9009\u62e9hash table</p> <ul> <li>\u5929\u7136\u7684deduplication of prefix sum as key space is unique</li> <li>\u8fd9\u6837\u6211\u4eec\u5c31\u53ef\u4ee5\u5728O(1)\u7684\u65f6\u95f4\u5185\u627e\u5230duplicate prefix sum\u5bf9\u5e94\u7684node\u3002\u4e0d\u9700\u8981traverse it again.</li> </ul> <p>\u5bf9\u4e8elinked list\uff0c <pre><code>nums = [1,4,-3,1,2,5,6]\n\nprefix_map = {\n    0: dummy,\n    1: ListNode(1),\n    5: ListNode(2), #\u539f\u6765\u662f5: ListNode(4), \u4f46\u88ab\u8986\u76d6\u4e86\n    2: listNode(-3),\n    3: ListNode(1),\n    10: ListNode(5), \n    16: ListNode(6),\n}\n</code></pre></p>","tags":["Linked List","Hash Table"]},{"location":"leetcode/1171-remove-zero-sum-consecutive-nodes-from-linked-list/#code-implementation-two-pass","title":"Code Implementation (two pass)","text":"<pre><code># Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def removeZeroSumSublists(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:\n        dummy = ListNode(0,head)\n        curr = dummy\n        # initialize     \n        prefix_sum = 0\n        prefix_sum_to_node = {0:curr}\n\n        # initial compute for pre-fix sum\n        while curr is not None:\n            prefix_sum += curr.val            \n            # \u5982\u679c\u5df2\u7ecf\u5728\u91cc\u9762\u4e86\uff0c\u6211\u4eec\u53ea\u8bb0\u5f55\u6700\u65b0\u7684\u90a3\u4e2aprefix sum\n            prefix_sum_to_node[prefix_sum] = curr\n            curr = curr.next\n\n        prefix_sum = 0\n        curr = dummy\n\n        # delete zero sum consecutive sequences\n        while curr is not None:\n            # \u8ba1\u7b97target prefix sum, \u518d\u53bb\u627e\u600e\u6837\u80fd\u5230\u8fbe\u8fd9\u4e2aprefix sum\u7684node\n            prefix_sum += curr.val\n            # curr: last node before the zero sum sequence\n            # prefix_sum_to_node[prefix_sum].next: first node after the zero sum sequence\n            curr.next = prefix_sum_to_node[prefix_sum].next\n            curr = curr.next\n\n        return dummy.next\n</code></pre>","tags":["Linked List","Hash Table"]},{"location":"leetcode/1171-remove-zero-sum-consecutive-nodes-from-linked-list/#code-implementation-one-pass","title":"Code Implementation (one pass)","text":"<p>\u6211\u7684\u5927\u8111\u65e0\u6cd5\u601d\u8003\u4e86.</p> <pre><code>class Solution:\n    def removeZeroSumSublists(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:\n        front = ListNode(0, head)\n        current = front\n        prefix_sum = 0\n        prefix_sum_to_node = {}\n        while current is not None:\n            # Add current's value to the prefix sum\n            prefix_sum += current.val\n\n            # If prefix_sum is already in the hashmap,\n            # we have found a zero-sum sequence:\n            if prefix_sum in prefix_sum_to_node:\n                prev = prefix_sum_to_node[prefix_sum]\n                current = prev.next\n\n                # Delete zero sum nodes from hashmap\n                # to prevent incorrect deletions from linked list\n                p = prefix_sum + current.val\n                while p != prefix_sum:\n                    del prefix_sum_to_node[p]\n                    current = current.next\n                    p += current.val\n\n                # Make connection from the node before \n                # the zero sum sequence to the node after\n                prev.next = current.next\n            else:\n                # Add new prefix_sum to hashmap\n                prefix_sum_to_node[prefix_sum] = current\n\n            # Progress to next element in list\n            current = current.next\n\n        return front.next\n</code></pre>","tags":["Linked List","Hash Table"]},{"location":"leetcode/118-pascal-triangle/","title":"Readme","text":"<p>\u8fd9\u4e00\u9898\u8f93\u5165\u4e3ainteger <code>numRows</code> and \u8f93\u51fa\u4e3a\u4e00\u4e2anested\u6570\u7ec4<code>[[1],[1,1],....]</code>\uff0c\u8f93\u51fa\u7684\u6570\u7ec4\u4e2d\uff0c\u5305\u542b\u7740\u4e00\u4e2a\u4e2a\u5c0f\u6570\u7ec4\uff0c\u6bcf\u4e2a\u5c0f\u6570\u7ec4\u90fd\u5305\u542b\u4e86\u4e09\u89d2\u5f62\u6bcf\u4e00\u884c\u4e2d\u7684\u4fe1\u606f.</p> <p></p> <p>\u6768\u8f89\u4e09\u89d2\u5f62, dynamic programming\u7684\u5165\u95e8\u7ea7\u9898\u76ee\uff0c\u8fd9\u4e00\u9898\u601d\u8def\u7528dp framework \u975e\u5e38\u7b80\u5355: - <code>base cases</code>: current state information\u4e0d\u4f9d\u8d56\u4e8eprevious layers - <code>recurrence cases</code>: \u4e5f\u5c31\u662fcurrent state\u7684\u6570\u636e\u4f9d\u8d56\u4e8eprevious layers</p> <p>\u9898\u76ee\u7684constraints\u4e3a  $$ 1\\leq n\\leq 30 $$</p> <p>\u8fd9\u6837\u7684\u8bdd\u6211\u4eec\u628a\u524d\u51e0\u5217\u5217\u4e00\u4e0b\u5c31\u6e05\u6670\u4e86 <pre><code>n = 1 --&gt; [[1]] // base cases\nn = 2 --&gt; [[1],[1,1]] // base cases\nn = 3 --&gt; [[1],[1,2,1]] // recurrence cases\nn = 4 --&gt; [[1],[1,2,1],[1,3,3,1]] // recurrence cases\nn = 5 --&gt; [[1],[1,2,1],[1,3,3,1],[1,4,6,4,1]] // recurrence cases\n</code></pre></p>"},{"location":"leetcode/118-pascal-triangle/#code","title":"Code","text":"<pre><code>class Solution:\n    def generate(self, numRows: int) -&gt; List[List[int]]:\n        # \u6768\u8f89\u4e09\u89d2\u5f62 binomial coeffient \u7c7b\u578b;\n\n        # edge cases\n        if numRows == 1: return [[1]]\n        if numRows == 2: return [[1],[1,1]]\n\n        # recurrence cases\n        triangle = [[1],[1,1]]\n        # starting from row 3\n        for i in range(3,numRows+1): # +1 \u662f\u56e0\u4e3aright hand exclusive in python\n            # initialze the array of size \n            row = [None] * i # \u6bcf\u4e00\u884c\u90fd\u6709rownumber\u6570\u91cf\u7684elements\n\n            # add the 1st element\n            row[0] = 1\n            for j in range(1,i-1):\n                row[j] = triangle[-1][j-1] + triangle[-1][j]\n\n            # add the last element\n            row[i-1] = 1\n\n            # append to the result list\n            triangle.append(row)  \n\n        return triangle\n</code></pre>"},{"location":"leetcode/1180-count-substrings-with-only-one-distinct-letter/","title":"\u539f\u6765\u601d\u8def","text":"<p>\u6211\u6700\u5148\u7684\u601d\u8def\u662f: - \u5148\u6839\u636estring, change of variable\u4e3a\u6761\u4ef6\uff0csplit into substrings, \u7136\u540eappend\u5230\u4e00\u4e2alist - \u7136\u540e\u5206\u522b\u6c42\u7b49\u52a0\u6570\u5217</p> <p>\u4f46\u53ef\u4ee5\u4e24\u6b65\u5e76\u4e00\u6b65</p>"},{"location":"leetcode/1180-count-substrings-with-only-one-distinct-letter/#_2","title":"\u6539\u5584\u903b\u8f91","text":"<p>\u5173\u4e8eboundary\u603b\u662f\u641e\u4e0d\u6e05\u695a\uff0c\u601d\u8def\u90fd\u662f\u5bf9\u7684, \u73b0\u5728\u77e5\u9053\u4e86\uff0c\u5bf9\u4e8eout of index\u8fd9\u79cd\u5224\u5b9a\u6761\u4ef6\u7684\u51e0\u4e2atrick</p> <ul> <li>\u76f4\u63a5traverse right\u6307\u9488, \u800c\u4e0d\u662f\u7528<code>while</code>\u5199\u90a3\u4e48\u591a\u5224\u5b9a</li> <li><code>for right in range(len(s)+1)</code>, \u591a\u4e00\u4e2aindex</li> <li><code>if right == len(s) or s[left] != s[right]</code> \u7531\u4e8epython\u6267\u884cexpression\u662f\u53ea\u8981\u524d\u9762\u7684pass\u4e86\uff0c\u7136\u540e\u5c31\u4e0d\u68c0\u67e5\u540e\u9762\u4e86, \u4e3a\u4e86\u907f\u514dindex out of range error, \u53ea\u80fd\u8fd9\u4e48\u505a;</li> </ul>"},{"location":"leetcode/1186-maximum-subarray-sum-with-one-deletion/","title":"Approach 1: Bottom up constant space","text":""},{"location":"leetcode/1186-maximum-subarray-sum-with-one-deletion/#dp","title":"DP\u5b9a\u4e49,\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b\u548c\u521d\u59cb\u5316","text":"<ul> <li> <p><code>DP[0][i]</code>: maximum subarray ending on <code>arr[i]</code>. \u4e5f\u5c31\u662f\u4e00\u5b9a\u4e0d\u5220. \u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b\u5982\u4e0b: $$ \\begin{align} \\rm{}DP[0][i] &amp;= max(DP[0][i-1] + arr[i],arr[i])\\ \\rm{}DP[0][0] &amp;= arr[0] \\end{align} $$ \u8fd9\u4e2a\u5f88\u597d\u7406\u89e3\uff0c\u6ca1\u4ec0\u4e48\u53ef\u8bf4\u7684,\u5c31\u662fmaximum subarray\u4e2d\u7684\u5b9a\u4e49</p> </li> <li> <p><code>DP[1][i]</code>: maximum subarray ending on <code>arr[i]</code>, but have a right to delete last element <code>arr[i]</code>.\u4e5f\u5c31\u662f\u4f60\u53ef\u4ee5\u5220\uff0c\u4e5f\u53ef\u4ee5\u4e0d\u5220\uff0c\u4f46\u4f60\u5982\u679c\u5220\u5fc5\u987b\u5220\u9664\u6700\u540e\u4e00\u4e2a, \u4e5f\u5c31\u662f<code>arr[i]</code>. \u90a3\u4e48\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b\u5982\u4e0b $$ \\begin{align} \\rm{DP}[1][i] &amp;= max(\\rm{DP}[1][i-1] + arr[i],arr[i],\\rm{DP}[0][i-1])\\</p> </li> </ul> <p>\\rm{}DP[1][0] &amp;= arr[0] \\end{align} $$ \u8fd9\u4e2a\u7406\u89e3\u6bd4\u8f83\u8d39\u8111\u7b4b\uff0c\u4f46\u6211\u6765\u89e3\u91ca\u4e00\u4e0b, - <code>DP[1][i-1] + arr[i]</code>: \u6211\u5220\u9664\u524d\u9762\u7684\u4efb\u4f55\u4e00\u4e2a\u70b9\u4e86. - <code>arr[i]</code> : \u5220\u6389\u524d\u9762\u5168\u90e8\u7684\u4e86,\u7531\u4e8e<code>DP[1][i-1]</code>\u4e3a\u8d1f\u6570,\u53ea\u662f\u7d2f\u8d58. - <code>DP[0][i-1]</code>: reset\u524d\u9762\u7684\u5220\u9664\uff0c\u6211\u73b0\u5728\u78b0\u5230\u8d1f\u6570\u7684global min\u4e86\uff0c\u6211\u8981\u5220<code>arr[i]</code>\u4e86!</p>"},{"location":"leetcode/1186-maximum-subarray-sum-with-one-deletion/#code","title":"code","text":"<pre><code>class Solution:\n    def maximumSum(self, arr: List[int]) -&gt; int:\n        # DP[0][i]: maximum subarray ending on arr[i].\n        # DP[1][i]: maximum subarray ending on arr[i], optionally have the right to drop the arr[i].\n\n\n        # declare DP and initialization\n        DP = [[0 for _ in range(len(arr))] for _ in range(2)]\n        DP[0][0] = arr[0]\n        DP[1][0] = arr[0]\n\n\n        for i in range(1,len(arr)):\n            # kadane' algorithm\n            DP[0][i] = max(DP[0][i-1] + arr[i], arr[i])\n            # \u53ef\u4ee5\u820d\u5f03arr[i]\u8fd9\u4e00element \n            DP[1][i] = max(DP[1][i-1] + arr[i], arr[i], DP[0][i-1])\n\n        return max(DP[1])\n</code></pre>"},{"location":"leetcode/1186-maximum-subarray-sum-with-one-deletion/#approach-2-jerrys-approach","title":"Approach 2: Jerry's approach","text":"<p>Jerry\u5b9a\u4e49\u7684\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b\u548c\u6211\u4e00\u6a21\u4e00\u6837\uff0c\u4f46DP\u7684\u5b9a\u4e49\u548c\u521d\u59cb\u5316\u6709slight difference, \u8fd9\u4e2a\u533a\u522b\u5b9e\u9645\u4e0a\u5c31\u6765\u81ea\u4e8e\u521d\u59cb\u5316\u5bf9\u4e8eDP\u5b9a\u4e49\u7684\u5f71\u54cd.</p> <p>DP\u5b9a\u4e49\u9700\u8981: - \u521d\u59cb\u6761\u4ef6 - \u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b</p> <p>\u8fd9\u4e24\u4e2a\u7f3a\u4e00\u4e0d\u53ef\uff0c\u770b\u8fd9\u4e2a\u4f8b\u5b50jerry\u5b9a\u4e49\u7684DP\u5982\u4e0b:</p> <ul> <li> <p><code>DP[0][i]</code>: maximum subarray ending on <code>arr[i]</code>. \u4e5f\u5c31\u662f\u4e00\u5b9a\u4e0d\u5220. \u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b\u5982\u4e0b: $$ \\begin{align} \\rm{}DP[0][i] &amp;= max(DP[0][i-1] + arr[i],arr[i])\\ \\rm{}DP[0][0] &amp;= arr[0] \\end{align} $$ \u8fd9\u4e2a\u548c\u6211\u7684\u5b9a\u4e49\u4e00\u6837.</p> </li> <li> <p><code>DP[1][i]</code>: maximum subarray ending on <code>arr[i]</code>, but must delete the last element <code>arr[i]</code>.\u4e5f\u5c31\u662f\u4f60\u53ef\u4ee5\u5220\uff0c\u4e5f\u53ef\u4ee5\u4e0d\u5220\uff0c\u4f46\u4f60\u5982\u679c\u5220\u5fc5\u987b\u5220\u9664\u6700\u540e\u4e00\u4e2a, \u4e5f\u5c31\u662f<code>arr[i]</code>. \u90a3\u4e48\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b\u5982\u4e0b $$ \\begin{align} \\rm{DP}[1][i] &amp;= max(\\rm{DP}[1][i-1] + arr[i],arr[i],\\rm{DP}[0][i-1])\\</p> </li> </ul> <p>\\rm{}DP[1][0] &amp;= 0 \\end{align} $$ \u53ef\u4ee5\u770b\u5230equation (8) and (4)\u662f\u552f\u4e00\u7684\u533a\u522b\uff0c\u4f46\u8fd9\u4e2ainitial condition\u76f4\u63a5\u9020\u6210\u4e86: - \u6211\u7684\u5b9a\u4e49: \u53ef\u4ee5\u5220\u9664\uff0c\u53ef\u4ee5\u4e0d\u5220\u9664, \u4f46\u5982\u679c\u5220\u9664\u4e00\u5b9a\u5220\u9664<code>arr[i]</code> - Jerry's \u5b9a\u4e49: \u4e00\u5b9a\u5220\u9664\u4e00\u4e2a\u70b9, no matter what.</p> <p>Takehome is DP\u7684\u5b9a\u4e49\u4e0d\u4ec5\u662fstate-transition function\u8fd8\u548c\u521d\u59cb\u6761\u4ef6\u76f8\u5173\u3002</p> <p>\u63d0\u9192\u4e86\u6211\u4eec\u4ee5\u540e\u5728\u8bbe\u8ba1DP\u65f6\u5019\uff0c\u4e0d\u4ec5\u4ec5\u8981\u82b1\u65f6\u95f4\u548c\u5fc3\u601d\u601d\u8003\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b\uff0c\u521d\u59cb\u72b6\u6001\u4e5f\u8981\u82b1\u5fc3\u601d\u8003\u8651. Jerry\u4ee3\u7801\u5982\u4e0b:</p> <pre><code># Jerry's code \nclass Solution:\n    def maximumSum(self, arr: List[int]) -&gt; int:\n        # DP[0][i]: maximum subarray ending on arr[i].\n        # DP[1][i]: maximum subarray ending on arr[i], optionally have the right to drop the arr[i].\n\n        if len(arr) == 1: return arr[0]        \n\n        # declare DP and initialization\n        DP = [[0 for _ in range(len(arr))] for _ in range(2)]\n        DP[0][0] = arr[0]\n        DP[1][0] = 0\n\n        max_so_far = arr[0]\n\n        for i in range(1,len(arr)):\n            # \u53ef\u4ee5\u820d\u5f03arr[i]\u8fd9\u4e00element \n            DP[1][i] = max(DP[1][i-1] + arr[i], arr[i], DP[0][i-1])\n            DP[0][i] = max(DP[0][i-1] + arr[i], arr[i])\n            max_so_far = max(max_so_far,DP[0][i],DP[1][i])\n\n        # return max(max(DP[1]),max(DP[0]))\n        return max_so_far\n</code></pre> <p>\u91cd\u70b9\u770bjerry\u7684initial conditions, \u867d\u7136DP[1][0]\u662f\u5f3a\u5236\u5220\u9664\u4e86\u7b2c\u4e00\u4e2anode\u7684\u60c5\u51b5\uff0c\u4f46\u662fmax_so_far\u8003\u8651\u4e86\u5fc5\u987b\u662f\u975e\u7a7asubarray\u7684\u524d\u63d0\u6761\u4ef6</p> <pre><code>        DP[0][0] = arr[0]\n        DP[1][0] = 0\n        max_so_far = arr[0]\n</code></pre>"},{"location":"leetcode/119-pascal-triangle-II/","title":"119 Pascal's triangle II","text":"<p>Pascal triangle is a triangle where all numbers are the sum of the two numbers above it. </p> <pre><code>              h\n    1         0\n   1 1        1\n  1 2 1       2\n 1 3 3 1      3\n</code></pre> <p>\u5176\u5b9e\u50a8\u5b58\u5728\u8ba1\u7b97\u673a\u91cc\uff0c\u662f\u4e00\u4e2aupper triangle\u4e3a0\u7684\u77e9\u9635, \u5982\u4e0b\u56fe,</p> <p></p> <p>\u6bcf\u4e00\u5c42\u7684\u6570\u636e\uff0c\u90fd\u53ea\u4f9d\u8d56\u4e8e\u4e0a\u4e00\u5c42\u7684\u6570\u636e.</p> <p>Follow-up: Could you optimize your algorithm to use only O(rowIndex) extra space?</p>","tags":["Array","Dynamic Programming"]},{"location":"leetcode/119-pascal-triangle-II/#approach-1-dp","title":"Approach 1: DP","text":"<p>\u4e4b\u524d\u8bf4\u8fc7\uff0c\u53ef\u4ee5\u7528\u4e00\u4e2a2d array\u6765\u5b58\u50a8\u8fd9\u4e2atriangle, \u800c\u4e14\u8fd9\u4e9b\u6570\u636e\u90fd\u5b58\u5728lower triangle, \u90a3\u4e48\u6211\u4eec\u5148\u627e\u7279\u6b8a\u60c5\u51b5\uff0c\u4ec0\u4e48\u65f6\u5019\u8fd9\u4e2aarray\u4e3a1?</p> <ul> <li>\u7b2c\u4e00\u5217 <code>j == 0</code></li> <li>\u4e3b\u5bf9\u89d2\u7ebf <code>i == j</code></li> <li>\u7b2c\u4e00\u884c <code>i == 0</code></li> </ul> <p>\u8fd9\u5c31\u662f\u6211\u4eec\u7684\u521d\u59cb\u6761\u4ef6\u3002\u66f4\u65b0\u6761\u4ef6\u5f88\u7b80\u5355\uff0c\u53ea\u4f9d\u8d56\u4e8e\u4e0a\u4e00\u884c\u7684\u4fe1\u606f. \u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u5199\u51fa\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b:</p> \\[ dp[i][j] =  \\left\\{ \\begin{array}{ll}       1 \\quad \\text{if i = 0 or j = 0 or i == j}\\\\       dp[i-1][j-1] + dp[i-1][j] \\quad \\text{otherwise} \\\\ \\end{array}  \\right. \\] <p>\u505a\u4e00\u4e0bspace optimization, \u7531\u4e8e\u6bcf\u4e00\u884c\u53ea\u4f9d\u8d56\u4e8e\u4e0a\u4e00\u884c\uff0c\u53ef\u4ee5\u521b\u5efa\u4e24\u4e2arolling\u6570\u7ec4\uff0c\u4e00\u4e2a<code>prev</code>\u5b58\u4e0a\u4e00\u884c\u7684\uff0c\u4e00\u4e2a<code>res</code>\u5b58\u5f53\u524d\u884c\u7684, \u7531\u4e8eupdate\u90fd\u662f\u4eceprev to res, \u4ece\u5de6\u5230\u53f3.</p>","tags":["Array","Dynamic Programming"]},{"location":"leetcode/119-pascal-triangle-II/#code-implementation","title":"Code Implementation","text":"<pre><code>class Solution:\n    def getRow(self, rowIndex: int) -&gt; List[int]:\n        # 0 &lt;= rowIndex &lt;= 33\n        # edge cases\n        if rowIndex == 0: return [1]\n        if rowIndex == 1: return [1,1]\n\n        # initial condition\n        prev = [1,1]\n\n        # top --&gt; down\n        for i in range(2,rowIndex+1):\n            res = [None] * (i+1)\n            # head\n            res[0] = 1\n            # left --&gt; right\n            for j in range(1,i):\n                res[j] = prev[j-1] + prev[j]\n            # tail\n            res[i] = 1\n\n            # update prev pointer\n            prev = res\n\n        return res\n</code></pre>","tags":["Array","Dynamic Programming"]},{"location":"leetcode/119-pascal-triangle-II/#approach-2-recursion","title":"Approach 2: Recursion","text":"<p>python\u5199\u8fd9\u4e2a\u89e3\u6cd5TLE\u4e86</p> <pre><code>class Solution:\n    def getRow(self, rowIndex: int) -&gt; List[int]:\n        # base case\n        res = []\n        # \u8fd9\u4e00\u884c\u7684, iterate over all columns\n        for i in range(rowIndex + 1):\n            res.append(self.getNum(rowIndex,i))\n        return res\n\n    def getNum(self,row,col):\n        # triangle\u7684\u6bcf\u4e00\u884c\u7b2c\u4e00\u4e2a\u548c\u6700\u540e\u4e00\u4e2a\u90fd\u662f0\n        if row == 0 or col == 0 or row == col:\n            return 1\n\n        return self.getNum(row-1,col-1) + self.getNum(row-1,col)\n</code></pre>","tags":["Array","Dynamic Programming"]},{"location":"leetcode/1191-k-concatenation-maximum-sum/","title":"1191 k concatenation maximum sum","text":"<p>sss</p>"},{"location":"leetcode/121-best-time-to-buy-and-sell-stock/","title":"Approach 1 sliding window","text":"<p>sliding window\u7c7b\u578b\u9898\u76ee\u505a\u7684\u7b2c\u4e00\u9898, \u5b9e\u9645\u4e0asliding window\u5c31\u662ftwo pointer\u7684\u4e00\u4e2a\u53d8\u79cd\uff0c\u5982\u4f55\u5de7\u5999\u7684\u8fd0\u7528pointer\u6765\u8ba9one-pass traversal\u6765\u83b7\u53d6multi-pass traversal\u4e00\u6837\u7684\u4fe1\u606f(\u505a\u5230\u540c\u6837\u7684\u4e8b\u60c5)</p>"},{"location":"leetcode/121-best-time-to-buy-and-sell-stock/#intuition","title":"Intuition","text":""},{"location":"leetcode/121-best-time-to-buy-and-sell-stock/#algorithm","title":"Algorithm","text":"<ul> <li>\u5148\u8bbe\u7f6e\u4e00\u4e2apointer\u6307\u5411\u76ee\u524darray\u4e2d\u7684\u6700\u5c0f\u503c\uff0c\u540c\u65f6\u8bbe\u7f6e\u4e00\u4e2amax_profit variable\u6765\u50a8\u5b58\u6700\u5927\u6536\u76ca\u503c</li> <li>traverse the array\u4e00\u904d, \u6309\u4ee5\u4e0border\u505a\u4e8b\u60c5:</li> <li>\u5982\u679c\u6709\u66f4\u4f4e\u7684\u4ef7\u683c, pointer\u6307\u5411\u90a3\u4e2a\u503c, \u4e0b\u4e00\u4e2aiteration</li> <li>\u5982\u679c\u6ca1\u6709\u66f4\u4f4e\u7684\u4ef7\u683c\uff0c\u4f46\u8ba1\u7b97current day price - min value\u7684\u503c\u8d85\u8fc7max_profit, update max_profit</li> <li>\u90fd\u4e0d\u6ee1\u8db3\uff0cdo nothing, \u4e0b\u4e00\u4e2aieration</li> </ul>"},{"location":"leetcode/121-best-time-to-buy-and-sell-stock/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: \\(O(n)\\) one pass solution</li> </ul> <ul> <li>Space complexity: \\(O(1)\\)</li> </ul>"},{"location":"leetcode/121-best-time-to-buy-and-sell-stock/#code","title":"Code","text":"<pre><code>class Solution:\n    def maxProfit(self, prices: List[int]) -&gt; int:\n        # sliding window approach O(n) in time, O(1) in space\n\n        # two pointer \n        min_price = float('inf')\n        max_difference = 0\n\n        # not gonna buy on last day\n        for i in range(len(prices)):\n            if prices[i] &lt; min_price:\n                min_price = prices[i]\n            elif prices[i] - min_price &gt; max_difference:\n                max_difference = prices[i] - min_price\n\n        return max_difference\n</code></pre>"},{"location":"leetcode/1229-meeting-scheduler/","title":"1229 Meeting Scheduler","text":"<p>\u9996\u5148\u5148\u7406\u89e3\u8fd9\u4e00\u9898\uff0c\u8fd9\u4fe9\u4eba\u6709\u7a7a\u7684\u65f6\u95f4\u6bb5<code>list1</code> and <code>list2</code>\u662f\u8f93\u5165, \u6211\u4eec\u8981\u627e\u4ed6\u4eecoverlapping\u7684\u65f6\u95f4\u6bb5\u4e2d\uff0c\u8db3\u591f\u4ed6\u4fe9\u8ba8\u8bba\u7684\u65f6\u95f4\u6bb5\u3002\u8fd9\u4e2a\u65f6\u95f4\u6bb5\u7684\u957f\u5ea6\u81f3\u5c11\u662f<code>duration</code>. \u5982\u679c\u6709\u591a\u4e2a\u65f6\u95f4\u6bb5\u6ee1\u8db3\u6761\u4ef6\uff0c\u6211\u4eec\u8fd4\u56de\u6700\u65e9\u7684\u90a3\u4e2a\u3002\u5982\u4e0b\u56fe\uff0c</p> <p></p> <p>\u7b2c\u4e00\u53cd\u5e94\u5c31\u662fline sweep, \u628a\u6240\u6709\u65f6\u95f4\u70b9\u653e\u8fdb\u4e00\u4e2alist, \u6392\u5e8f\u540e\u51c6\u5907\u8fdb\u884cline sweep.</p>","tags":["Array","Two Pointers","Sorting"]},{"location":"leetcode/1229-meeting-scheduler/#approach-1-sweep-line","title":"Approach 1 Sweep Line","text":"<p>\u5bf9\u4e8esweep line, \u6211\u4eec\u53ea\u9700\u8981\u6784\u5efa\u51fa\u80fd\u591f\u63cf\u8ff0\u7cfb\u7edf\u5185\u6240\u6709\u72b6\u6001\u7684cost function\u5373\u53ef\uff0c\u5047\u8bbe</p> <ul> <li>person 1\u6709\u7a7a\u65f6\u4e3a+1</li> <li>person 2\u6709\u7a7a\u65f6\u4e3a+2</li> </ul> <p>\u8fd9\u6837\u6211\u4eec\u53ef\u4ee5\u628afinite\u7684\u56db\u79cd\u72b6\u6001\u7ed9\u63cf\u8ff0\u51fa\u6765</p> <ul> <li>person 1\u6709\u7a7a\uff0cperson 2\u6709\u7a7a, <code>cost == 3</code></li> <li>person 1\u6709\u7a7a, person 2\u6ca1\u7a7a, <code>cost == 1</code></li> <li>person 1\u6ca1\u7a7a, person 2\u6709\u7a7a, <code>cost == 2</code></li> <li>person 1\u6ca1\u7a7a, person 2\u6ca1\u7a7a, <code>cost == 0</code></li> </ul> <p>\u6211\u4eec\u628a<code>slots1</code> and <code>slots2</code> flatten\u6210\u4e00\u4e2alist of tuples, \u7136\u540esort by time. \u8fd9\u6837\u6211\u4eec\u5c31\u53ef\u4ee5\u7528sweep line\u7684\u65b9\u6cd5\u6765\u627e\u5230\u6240\u6709\u7684interval where both people are available. \u6709\u4e24\u4e2a\u5173\u952e\u65f6\u95f4\u70b9:</p> <ul> <li>curr_sum == 3 and prev_sum != 3, \u8fd9\u4e2a\u65f6\u5019\u6211\u4eec\u53ef\u4ee5\u5f00\u59cb\u4e00\u4e2a\u65b0\u7684interval</li> <li>curr_sum != 3 and prev_sum == 3, \u8fd9\u4e2a\u65f6\u5019\u6211\u4eec\u53ef\u4ee5\u7ed3\u675f\u4e00\u4e2ainterval</li> </ul> <p>\u6839\u636e\u8fd9\u4e2a\u5c31\u80fd\u5224\u5b9a\u51fa\u6765\u600e\u4e48\u63d2\u5165\u4e86, \u5982\u4e0b\u56fe\u6240\u793a\uff0c\u4f60\u770b\u770b<code>\u5347\u52303</code>\u548c<code>\u4ece3\u964d\u5230\u975e3</code>\u7684jump discontinuity.</p> <p></p> <pre><code>class Solution:\n    def minAvailableDuration(self, slots1: List[List[int]], slots2: List[List[int]], duration: int) -&gt; List[int]:\n        # brute force, O(m*n)\n        \"\"\"\n        1.\n        assign\n            person 1 as +1\n            person 2 as +2\n            no person available as 0\n            person1 and 2 are both available + 3\n        1. find intervals that both people are available\n        [[10,15],[60,70]]\n        2. see the first one has it's length greater than duration\n        \"\"\"\n        times = []\n        for start,end in slots1:\n            times.append((start,1))\n            times.append((end,-1))\n\n        for start,end in slots2:\n            times.append((start,2))\n            times.append((end,-2))\n        # sort by time aescendingly\n        times.sort(key = lambda x:x[0])\n\n        intervals = []\n        curr_sum = 0\n        prev_time = -1\n\n        for time,cost in times:\n            # update prev\n            prev_sum = curr_sum            \n            # update new ones\n            curr_sum += cost\n\n            if prev_sum != 3 and curr_sum == 3:\n                # both are available, going into it\n                intervals.append([time])\n            elif prev_sum == 3 and curr_sum != 3:\n                # ending the availability\n                intervals[-1].append(time)            \n            prev_time = time\n\n        if not intervals:\n            return []\n        else:\n            for start,end in intervals:\n                if end - start &gt;= duration:\n                    return [start,start + duration]\n\n        return []\n</code></pre> <p>\u770b\u4e86\u5927\u795e top 0.3% xil899, \u6211\u53d1\u73b0\u6211\u7684\u7b54\u6848\u5b9e\u5728\u592aredundant\u4e86\uff0c\u4ed6\u7684\u7b54\u6848\u66f4\u7b80\u6d01\uff0c\u4f18\u5316\u601d\u8def\u5982\u4e0b</p> <ul> <li>\u6211\u4eec\u53ea\u5173\u5fc3\u4e24\u4e2a\u4eba\u90fd\u6709\u7a7a\u7684\u65f6\u95f4\u6bb5, \u6240\u4ee5cost function\u90fd\u53ef\u4ee5\u8d4b\u503c\u4e3a1\uff0c-1 for both person 1 and person2. \u8fd9\u6837\u6211\u4eec\u80fd\u63cf\u8ff0\u4e09\u4e2a\u72b6\u6001: 2 for \u90fd\u6709\u7a7a\uff0c 1 for only one person has time, 0 for both don't have time. \u4f46\u8fd9\u4e00\u6b65\u65e0\u6240\u8c13\uff0c\u53ef\u4ee5\u968f\u4fbf\u8d4b\u503c\u5176\u5b9e\u3002</li> <li>\u6211\u4eec\u53ea\u9700\u8981\u5224\u5b9a\u7b2c\u4e8c\u4e2ajump discontinuity(\u4e0a\u4e00\u65f6\u6b65\uff0c\u4e24\u4eba\u90fd\u7528\u7a7a\u3002\u5f53\u524d\u6b65\u65e0\u6240\u8c13). \u540c\u65f6\u878d\u5408\u4e00\u4e0b\u903b\u8f91\uff0c\u5224\u5b9a\u4e00\u4e0b\u65f6\u5e38\u662f\u5426\u6ee1\u8db3\u6761\u4ef6\u5373\u53ef\u3002</li> </ul> <p>complexity</p> <p>time complexity is \\(O((m+n)\\log (m+n))\\), space complexity is \\(O(m+n)\\)</p> <pre><code>class Solution:\n    def minAvailableDuration(self, slots1: List[List[int]], slots2: List[List[int]], duration: int) -&gt; List[int]:\n        times = []\n        # \u4e0d\u9700\u8981\u533a\u522b\u4e24\u4e2a\u4eba\u4e2d\u53ea\u6709\u4e00\u4e2a\u6709\u7a7a\u7684\u72b6\u6001\n        for start,end in slots1:\n            times.append((start,1))\n            times.append((end,-1))\n\n        for start,end in slots2:\n            times.append((start,1))\n            times.append((end,-1))\n        times.sort()\n\n        # \u6211\u4eec\u53ea\u9700\u8981\u5728\u79bb\u5f00\u65f6\u8fdb\u884c\u6dfb\u52a0\u5373\u53ef, prev_status != 2, prev_status == 2\n        prev_time,prev_status = 0,0\n        for time,status in times:\n            if prev_status == 2 and time - prev_time &gt;= duration:\n                return [prev_time,prev_time + duration]\n            # update status\n            prev_status += status\n            prev_time = time\n\n        return []\n</code></pre>","tags":["Array","Two Pointers","Sorting"]},{"location":"leetcode/1229-meeting-scheduler/#approach-2-two-pointers","title":"Approach 2 Two Pointers","text":"","tags":["Array","Two Pointers","Sorting"]},{"location":"leetcode/1229-meeting-scheduler/#approach-3-heap","title":"Approach 3 Heap","text":"","tags":["Array","Two Pointers","Sorting"]},{"location":"leetcode/1248-count-number-of-nice-subarrays/","title":"1248 Count Number of Nice Subarrays","text":"","tags":["Array","Hash Table","Sliding Window","Math"]},{"location":"leetcode/1248-count-number-of-nice-subarrays/#approach-1-prefix-sum","title":"Approach 1 Prefix Sum","text":"<p>\u7528\u5f52\u5316\u7684\u601d\u60f3\uff0c\u8f6c\u79fb\u6210subarray sum equal to k\u7684\u95ee\u9898, \u4e5f\u5c31\u662f560 subarray sum equal to k\u7684\u95ee\u9898</p> <pre><code>class Solution:\n    def numberOfSubarrays(self, nums: List[int], k: int) -&gt; int:\n        \"\"\"\n        - nice if there are k odd numbers on it\n        we can convert it to\n        [1,1,2,1,1] to [1,1,0,1,1]\n        [2,4,6] to [0,0,0]\n        it became a problem of subarry sum equal to k\n        \"\"\"\n        nums = [1 if num % 2 == 1 else 0 for num in nums]\n\n        hashtable = collections.defaultdict(int)\n        hashtable[0] = 1\n\n        total = 0\n        prefix = 0\n        for i,num in enumerate(nums):\n            prefix += num\n            target = prefix - k\n            if target in hashtable:\n                total += hashtable[target]\n            # add the current prefix frequency by 1            \n            hashtable[prefix] += 1\n\n        return total\n</code></pre>","tags":["Array","Hash Table","Sliding Window","Math"]},{"location":"leetcode/125-valid-palindrome/","title":"Intuition","text":"<p>\u770b\u89c1palindrome\u4e0b\u610f\u8bc6\u53cd\u5e94\u7528two pointer method\u4e86.</p>"},{"location":"leetcode/125-valid-palindrome/#approach","title":"Approach","text":""},{"location":"leetcode/125-valid-palindrome/#complexity","title":"Complexity","text":"<ul> <li>Time complexity:</li> </ul> <ul> <li>Space complexity:</li> </ul>"},{"location":"leetcode/125-valid-palindrome/#code","title":"Code","text":"<pre><code>class Solution:\n    def isPalindrome(self, s: str) -&gt; bool:\n        # step 1: removing all non-alphanumerical chars and convert upper to lower cases\n\n        clean_s = \"\"\n\n        # get the alphanumerical char into the clean_s\n        for char in s:\n            if char.isalnum():\n                clean_s += char\n            else:\n                # it's not\n                continue\n\n        # convert it all to lower cases\n        clean_s = clean_s.lower()\n\n        head = 0\n        tail = len(clean_s) - 1\n\n        # two pointer, opposite direction problem\n        res = False\n        while tail &gt; head:\n            # check \n            if clean_s[head] != clean_s[tail]:\n                return res\n            # advance two pointers by one\n            head += 1\n            tail -= 1\n\n        res = True\n        return True\n</code></pre>"},{"location":"leetcode/1272-remove-interval/","title":"1272 Remove Interval","text":"<p>Interval\u4e09\u5144\u5f1f\u7684\u8001\u4e09. \u5173\u952e\u662f\u5404\u79cd\u8fb9\u754c\u70e6\u6b7b\u6211\u4e86. \u6211\u4e00\u5f00\u59cb\u7684\u601d\u8def\u662f\u5206\u7c7b\u8ba8\u8bba\uff0c\u4f46\u88ab\u5404\u79cd\u8fb9\u754c\u641e\u5f97\u5934\u5927\u3002\u5982\u4e0bsolid line for intervals, dashed line for toBeRemoved interval. </p> <pre><code>case 1 partial removal (left)\n--\n ----\ncase 2 partial removal (right)\n   --\n----\ncase 3 total removal;\n --\n----\ncase 4 cut you in half!\n-------\n   --\ncase 5 nothing happens\n----\n        --\nor \n    ----\n--\n</code></pre> <p>\u5b9e\u9645\u4e0a\u53ef\u4ee5\u518d\u6574\u7406\u4e00\u4e0b\u6240\u6709\u7684\u8fd9\u4e9b\u53ef\u80fd\u6027\uff0c\u5982\u4e0b\u8868</p> case_# overlap? append left? append right? 1 \u2705 \u2705 \u274c 2 \u2705 \u274c \u2705 3 \u2705 \u274c \u274c 4 \u2705 \u2705 \u2705 5 \u274c N/A N/A <p>Tip</p> <p>append left, append right\u4ee3\u8868\u7740\u4f60interval\u88ab\u5207\u5272\u4e4b\u540e\uff0c\u662f\u5426\u8fd8\u5269\u4e0b\u5de6\u8fb9(\u9760\u8fd1start)\u548c\u53f3\u8fb9(\u9760\u8fd1end)\u7684\u90e8\u5206\u3002\u5982\u679c\u4efb\u610f\u90e8\u5206\u6709\uff0c\u5c31\u4ee5\u5148\u5de6\u540e\u53f3\u7684\u987a\u5e8fappend\u5230res\u91cc\u9762\u3002</p> <p>\u5224\u5b9a\u903b\u8f91\u662f,</p> <ul> <li>\u5148\u5224\u65ad\u662f\u5426\u6709overlap<ul> <li>\u65e0overlap, \u76f4\u63a5append</li> <li>\u6709overlap, \u518d\u5224\u65ad\u662f\u5426\u6709\u5de6\u53f3overlap, \u6709\u4e24\u4e2aif\u8bed\u53e5\u63cf\u8ff0\u56db\u79cd\u53ef\u80fd\u6027<ul> <li>\u6709\u5de6overlap, append left</li> <li>\u6709\u53f3overlap, append right</li> <li>\u6709\u5de6\u53f3overlap, append left and right</li> <li>\u65e0\u5de6\u53f3overlap, append nothing</li> </ul> </li> </ul> </li> </ul>","tags":["Array"]},{"location":"leetcode/1272-remove-interval/#approach-1","title":"Approach 1","text":"<pre><code>class Solution:\n    def removeInterval(self, intervals: List[List[int]], toBeRemoved: List[int]) -&gt; List[List[int]]:\n        res = []\n        remove_start,remove_end = toBeRemoved\n\n        for start,end in intervals:\n            # no overlaps at all\n            if start &gt;= remove_end or end &lt;= remove_start:\n                res.append([start,end])\n            else:\n                # keep left? strictly less than\n                if start &lt; remove_start:\n                    res.append([start,remove_start])\n                # keep right? strictly greater than\n                if end &gt; remove_end:\n                    res.append([remove_end,end])\n\n        return res\n</code></pre>","tags":["Array"]},{"location":"leetcode/128-longest-consecutive-sequence/","title":"128 Longest Consecutive Sequence","text":"<p>We will talk about three approaches:</p> <ul> <li>brute force solution \\(O(n^2)\\) in time, \\(O(n)\\) in space</li> <li>only look for head of the sequence \\(O(n)\\) in time, \\(O(n)\\) in space</li> <li>union find, \u4e5f\u80fd\u505a\u5230\\(O(n)\\) in time, \u4f46\u9700\u8981a lot more code. \u4ee5\u540e\u518d\u6765\u770b\u770b\u5427.</li> </ul>","tags":["Array","Hash Table","Union Find"]},{"location":"leetcode/128-longest-consecutive-sequence/#approach-1-brute-force-solution","title":"Approach 1: Brute Force Solution","text":"<p>This is the first solution came to my mind when i saw it. The outer loop is executed at most n times while the inner loop is executed at most n times. So, the time complexity is O(n^2). The space complexity is O(n) because we are using a set to store the numbers.</p> <p>Since we have to traverse the <code>nums</code>, the only thing left for optimize is the inner while loop. </p> <p>If you have a sequence like  <pre><code>nums = [100, 4, 200, 1, 3, 2]\n</code></pre> For the same sequence <code>[1, 2, 3 ,4]</code>, we will check 4 times, which is unnecessary. We only need to check the first number of the sequence, and how do we do that? Please see approach 2.</p> <pre><code>class Solution:\n    def longestConsecutive(self, nums: List[int]) -&gt; int:\n        # 1st pass: get them into the set()\n        # 2nd pass: iterate over nums and create a while loop to check the hashmap\n        # O(n) in time, O(n) in space\n        count = set(nums)\n\n        best_length = 0\n        for num in count:\n            curr = num\n            curr_length = 0\n            while curr in count:                            \n                curr_length += 1\n                curr += 1\n            best_length = max(best_length,curr_length)\n\n        return best_length\n</code></pre>","tags":["Array","Hash Table","Union Find"]},{"location":"leetcode/128-longest-consecutive-sequence/#approach-2-on-in-time-and-space","title":"Approach 2: O(n) in time and space","text":"<p>\u6211\u4eec\u77e5\u9053\u6211\u4eec\u7684\u76ee\u6807\u662f\u627e\u5230\u6bcf\u4e00\u4e2asequence\u7684\u5934\u90e8\uff0c\u90a3\u4e48\u5934\u90e8\u6709\u4ec0\u4e48\u533a\u522b\u5462? \u5934\u90e8\u7684\u524d\u4e00\u4e2a\u6570\u5b57\u4e0d\u5728set\u91cc\u9762, \u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u7528\u8fd9\u4e2a\u7279\u6027\u6765\u4f18\u5316\u6211\u4eec\u7684\u7b97\u6cd5\u3002</p> <pre><code># counting sequence from head\nclass Solution:\n    def longestConsecutive(self, nums: List[int]) -&gt; int:\n        # 1st pass: get them into the set()\n        # 2nd pass: iterate over nums and create a while loop to check the hashmap\n        # O(n) in time, O(n) in space\n        count = set(nums)\n\n        best_length = 0\n        for num in count:\n            if num -1 not in count:\n                curr = num\n                curr_length = 0\n                while curr in count:                            \n                    curr_length += 1\n                    curr += 1\n                best_length = max(best_length,curr_length)\n\n        return best_length\n</code></pre> <p>Note</p> <p>\u540c\u7406\uff0cfor sequence, \u51b3\u5b9a\u5c3e\u90e8\u53ef\u4ee5\u7528\u5c3e\u90e8\u7684\u4e0b\u4e00\u4e2a\u6570\u5b57\u4e0d\u5728set\u91cc\u9762\u6765\u5224\u65ad\u3002\u4f46\u4eba\u4eec\u66f4\u503e\u5411\u4e8e\u4ece\u5934\u90e8\u5f00\u59cb\u8ba1\u7b97\uff0c\u56e0\u4e3aleft -&gt; right is common in a lot of cultures.</p>","tags":["Array","Hash Table","Union Find"]},{"location":"leetcode/128-longest-consecutive-sequence/#approach-3-union-find","title":"Approach 3 Union Find","text":"","tags":["Array","Hash Table","Union Find"]},{"location":"leetcode/1288-remove-covered-intervals/","title":"1288 Remove Covered Intervals","text":"<p>\u7b54\u9898\u601d\u8def,</p> <ul> <li>brute force, O(n^2), traverse all possible pairs of interval</li> <li>sort + greedy, O(nlogn)</li> <li>sort but space optimized</li> </ul> <p>\u6700\u4f18\u89e3\u4e3a\\(O(n\\log n)\\) in time, O(1) in space. \u8fd9\u4e00\u9898\u5b58\u5728\u4e24\u4e2a\u96be\u70b9,</p> <ul> <li>\u5982\u4f55\u51b3\u5b9a\u6392\u5e8f\u987a\u5e8f</li> <li>\u4e3a\u4f55\u53ea\u9700\u8981\u6bd4\u8f83\u6392\u5e8f\u540e\u6700\u8fd1\u7684\u4e00\u4e2anon-overlapping interval?</li> </ul>","tags":["Array","Sorting"]},{"location":"leetcode/1288-remove-covered-intervals/#approach-1-brute-force","title":"Approach 1: Brute Force","text":"<p>\u7565</p>","tags":["Array","Sorting"]},{"location":"leetcode/1288-remove-covered-intervals/#approach-2-sort-greedy","title":"Approach 2: Sort + Greedy","text":"<p>\u60f3\u8c61\u4e00\u4e0b\uff0c\u6211\u4eec\u6709\u4e00\u5806\u53ef\u80fd\u6709\u88abcover\u60c5\u51b5\u7684interval, \u6211\u4eec\u8981\u79fb\u9664\u6389\u6240\u6709\u88abcover\u7684interval, \u7559\u4e0b\u7684\u5c31\u662f\u6ca1\u6709\u88abcover\u7684interval. \u88abcover\u5f88\u597d\u7406\u89e3\uff0c\u5c31\u5982\u4e0b\u56fe\u7684\u66b4\u9ca4\u9f99\u548c\u9ca4\u9c7c\u738b,</p> <p></p> <p>\u4f60\u8981\u5254\u9664\u6240\u6709\u7684\u9ca4\u9c7c\u738b\u7684\u60c5\u51b5\uff0c\u5c31\u662f\u5927\u9c7c\u5403\u5c0f\u9c7c\u3002\u9996\u5148\uff0cintervals\u7684\u9898\u76ee\u7684\u7b2c\u4e00\u601d\u8def\u662f\u6392\u5e8f\uff0c\u90a3\u600e\u4e48\u6837\u6392\u5e8f\u5462\uff0c\u516b\u79cd\u53ef\u80fd\u6027,</p> <ul> <li><code>case 1</code>: sort by start_time aescendingly, then by end_time aescendingly</li> <li><code>case 2</code>: sort by start_time aescendingly, then by end_time descendingly</li> <li>sort by start_time descendingly, then by end_time aescendingly (\u4e0d\u7b26\u5408)</li> <li>sort by start_time descendingly, then by end_time descendingly (\u4e0d\u7b26\u5408)</li> <li>sort by end_time aescendingly, then by start_time aescendingly (\u4e0d\u7b26\u5408)</li> <li>sort by end_time aescendingly, then by start_time descendingly (\u4e0d\u7b26\u5408)</li> <li><code>case 3</code>: sort by end_time descendingly, then by start_time aescendingly </li> <li><code>case 4</code>: sort by end_time descendingly, then by start_time descendingly </li> </ul> <p>\u4e3a\u4ec0\u4e48\u5269\u4e0b\u51e0\u4e2acase\u4e0d\u7b26\u5408\u5462? \u56e0\u4e3a\u6211\u4eec\u5e0c\u671b\u80fd\u5c3d\u53ef\u80fd\u7684\u628a\u8fd9\u4e9b\u9c7c\u62c9\u5f00. </p> <ul> <li>sort first by start_time aescendingly, \u53ef\u4ee5\u628a\u9c7c\u7684\u8d77\u70b9\u62c9\u5f00\uff0c\u4fdd\u8bc1\u524d\u9762\u7684\u9c7c\u90fd\u6709\u53ef\u80fd\u5403\u6389\u540e\u9762\u7684\u9c7c, \u800c\u4e0d\u4f1a\u88ab\u5403</li> <li>soft first by end_time descendingly, \u53ef\u4ee5\u628a\u9c7c\u7684\u7ec8\u70b9\u62c9\u5f00\uff0c\u4fdd\u8bc1\u524d\u9762\u7684\u9c7c\u90fd\u6709\u53ef\u80fd\u5403\u6389\u540e\u9762\u7684\u9c7c, \u800c\u4e0d\u4f1a\u88ab\u5403</li> </ul> <p>\u5982\u679c\u53cd\u4e00\u53cd\uff0csort first by start_time descendingly, \u524d\u9762\u7684\u9c7c\u53cd\u800c\u5b58\u5728\u88ab\u5403\u6389\u7684\u53ef\u80fd. \u5f53\u7136\uff0c\u6211\u4eec\u4e5f\u53ef\u4ee5\u53cd\u7740\u8ba1\u7b97\uff0c\u8ba1\u7b97\u88ab\u5403\u6389\u7684\u9c7c\u7684\u6570\u91cf<code>x</code>, \u7136\u540e<code>n - x</code>\u5f97\u5230\u6ca1\u88ab\u5403\u7684\u60c5\u51b5\u3002Anyways, \u6211\u4eec\u5148\u770b\u770b\u6211filter\u540e\u7684\u56db\u79cd\u60c5\u51b5</p> <p>\u6211\u4eec\u8981\u4fdd\u8bc1\u7684\u662f\uff0c\u7b2c\u4e00\u6761\u9c7c\u662f\u8981\u653e\u5165non-overlapping list\u7684\uff0c\u90a3\u662f\u4e00\u5b9a\u4e0d\u4f1a\u88ab\u5403\u6389\u7684\u90a3\u4e00\u6761\u9c7c\u3002\u6240\u4ee5\u6211\u4eec\u4e3a\u4e86\u5224\u65ad\u7528\u4ec0\u4e48\u6392\u5e8f\uff0c\u6211\u4eec\u5148\u679a\u4e3e\u4e00\u4e0b\u56db\u79cd\u60c5\u51b5\u7136\u540e\u8bd5\u56fecontradict\u4e00\u4e0b\uff0c\u770b\u770b\u54ea\u79cd\u60c5\u51b5\u662f\u4e0d\u884c\u7684\u3002</p> <p>Case 1 \u663e\u7136\u4e0d\u884c\uff0c\u5982\u679c\u7b2c\u4e00\u6761\u9c7c\u548c\u7b2c\u4e8c\u6761\u9c7c\u8d77\u70b9\u76f8\u540c\uff0c\u53c8\u6309\u9c7c\u7ec8\u70b9\u5347\u5e8f\uff0c\u90a3\u4e48\u7b2c\u4e00\u6761\u9c7c\u4e00\u5b9a\u4f1a\u88ab\u5403\u6389\u3002</p> <pre><code>case 1 aesc,asec \u53cd\u4f8b\n\n|----|\n|-------|\n</code></pre> <p>\u770bcase 2, \u4f3c\u4e4e\u6682\u65f6\u627e\u4e0d\u5230\u53cd\u4f8b\u3002\u6211\u7b2c\u4e00\u6761\u9c7c\u4e0d\u4ec5\u8d77\u70b9\u66f4\u9760\u5de6\uff0c\u6211\u7ec8\u70b9\u8fd8\u66f4\u9760\u53f3\u8fb9\u3002\u6700\u574f\u60c5\u51b5\u662f\u662f\u6709\u8bb8\u591a\u6761duplicate\u9c7c\uff0c\u90a3\u4e5f\u4e0d\u7528\u62c5\u5fc3\uff0c\u56e0\u4e3a\u53ea\u6709\u7b2c\u4e00\u6761\u80fd\u8fdb\u6765\u3002\u540e\u9762\u90fd\u4f1a\u88ab\u8fd9\u7b2c\u4e00\u6761\u9c7c\u5403\u6389</p> <pre><code>case 2 aesc,desc\n|-------|\n|----|\n</code></pre> <p>\u770bcase 3, \u6211\u7684\u7b2c\u4e00\u6761\u9c7c\uff0c\u9c7c\u5c3e\u5df4\u66f4\u9760\u53f3\uff0c\u6211\u7684\u7ec8\u70b9\u8fd8\u66f4\u9760\u5de6\u3002\u8fd9\u4e5f\u662f\u65e0\u654c\u7684\u5927\u9c7c\uff0c\u4e0d\u4f1a\u88ab\u5403\u6389\u7684\uff01\u76ee\u6d4bcase 2 and 3\u90fd\u53ef\u4ee5.</p> <pre><code>case 3 end time desc, start time aesc\n  |---------|\n    |-------|\n|----|\n</code></pre> <p>\u770bcase 4,  \u6211\u7684\u7b2c\u4e00\u6761\u9c7c\uff0c\u9c7c\u5c3e\u5df4\u66f4\u9760\u53f3\uff0c\u6211\u7684\u8d77\u70b9\u4e5f\u66f4\u9760\u53f3\uff0c\u6ca1\u529e\u6cd5\u6ee1\u8db3\u6211\u4e0d\u88ab\u5403\u554a!</p> <pre><code>case 4 desc,desc \u53cd\u4f8b\n    |-------|\n  |---------|\n|----|\n</code></pre> <p>\u7efc\u4e0a\uff0c\u6211\u4eec\u9009\u62e9case 2 or case 3\u90fd\u53ef. \u76ee\u524d\u9009\u62e9case 2, sort by start_time aescendingly, then by end_time descendingly.</p> <p>\u4e3a\u4ec0\u4e48\u53ea\u5173\u5fc3\u4e0a\u4e00\u6761\u9c7c?</p> <p>\u4e0a\u4e00\u6761\u9c7c\u662f\u6700\u8fd1\u7684\u4e00\u6761\u5927\u9c7c. \u518d\u4e4b\u524d\u7684\u9c7c\uff0c\u6700\u591a\u548c\u5b83\u6709overlap, \u4e0d\u5b58\u5728\u4e92\u76f8cover\u7684\u5173\u7cfb\u3002\u4e3a\u4ec0\u4e48\u6211\u4eec\u4e0d\u5173\u5fc3\u4ee5\u524d\u7684\u9c7c\u5462? \u56e0\u4e3a\u6211\u4eeccase 2\u7684\u6392\u5e8f\u65b9\u5f0f\uff0c\u5df2\u7ecf\u5c3d\u91cf\u628a\u5927\u9c7c\u653e\u5728\u524d\u9762\u4e86(sort by start ascendingly if tie, sort desc), \u5982\u679c\u8fd9\u6837\u8fd8\u88ab\u5403\u6389, \u53ea\u6709\u53ef\u80fd\u662f\u5982\u4e0b\u7684\u53ef\u80fd <pre><code>|-------|\n|----|\nor\n|-------|\n  |----|\n</code></pre> \u518d\u5f80\u524d\u7684, \u5982\u679c\u5b58\u5728\u4e00\u79cd\u53ef\u80fd\u6027\uff0c\u7b2c\u4e09\u6761\u9c7c\u4e0d\u88ab\u7b2c\u4e8c\u6761\u9c7c\u5403\u6389\uff0c\u53cd\u800c\u88ab\u7b2c\u4e00\u6761\u9c7c\u5403\u6389\u7684\u8bdd\uff0c\u90a3\u5c31\u53ea\u80fd\u662f\u5982\u4e0b\u56fe\u7684\u60c5\u51b5\u3002\u8fd9\u79cd\u60c5\u51b5\u662f\u4e0d\u5b58\u5728\u7684\uff0c\u56e0\u4e3a\u8fd9\u6837\u7684\u8bdd\uff0c\u7b2c\u4e8c\u6761\u9c7c\u5728\u5224\u5b9a\u7684\u65f6\u5019\uff0c\u5c31\u4f1a\u88ab\u7b2c\u4e00\u6761\u9c7c\u5403\u6389\u3002\u6240\u4ee5\u8fd9\u79cd\u60c5\u51b5\u4e0d\u6210\u7acb <pre><code>|-------------| \n    |-------|\n    |----|\n</code></pre> \u7edd\u5927\u591a\u6570\u7684\u60c5\u51b5\u662f\u8fd9\u6837\u7684, <pre><code>|---------| \n    |-------|\n    |----|\n</code></pre> \u6700\u8fd1\u7684\u8fd9\u6761\u5927\u9c7c\uff0c\u5de6\u8fb9\u80af\u5b9a\u7b26\u5408cover\u6761\u4ef6\uff0c\u56e0\u4e3a\u5347\u5e8f\uff0c\u4f46\u8fd9\u6761\u9c7c\u7684\u53f3\u8fb9\uff0c\u80af\u5b9a\u6ee1\u8db3\u6bd4\u524d\u9762\u7684\u9c7c\u66f4\u9760\u53f3\u7684\u6761\u4ef6\uff0c\u6240\u4ee5\u624d\u4e0d\u4f1a\u88ab\u5403\u6389\uff0c\u6240\u4ee5last fish is the king of the pond. \u8fd9\u5c31\u662f\u4e3a\u4ec0\u4e48\u8d2a\u5fc3\u80fd\u6210\u7acb\uff0c\u4e14\u53ef\u4ee5\u5728sort\u540e\u5ffd\u7565\u524d\u9762\u7684\u9c7c\u7684\u6bd4\u8f83\u7684\u60c5\u51b5.</p> <p>\u9488\u5bf9case 2 and case 3, \u6211\u4eec\u8fdb\u884c\u5206\u7c7b\u8ba8\u8bba\u770b\u770b\u4ee3\u7801\u5b9e\u73b0</p>","tags":["Array","Sorting"]},{"location":"leetcode/1288-remove-covered-intervals/#case-2-sort-by-start_time-aescendingly-then-by-end_time-descendingly","title":"Case 2: sort by start_time aescendingly, then by end_time descendingly","text":"<p>Solution</p> <p>\u5229\u7528case 2 asec,desc <pre><code>class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -&gt; int:\n        # \u5927\u9c7c\u5403\u5c0f\u9c7c: \u5c0f\u7684interval, \u5982\u679c\u88abcover\u6389\u5c31\u4f1a\u5403\u6389\u4e86\uff0c\u6240\u4ee5\u5269\u4e0b\u7684\u90fd\u662f\u5927\u9c7c.\n\n        # sort by start_time aescendingly, then by end_time descendingly\n        intervals.sort(key=lambda x:(x[0],-x[1]))\n\n        # greedy\n        res = [intervals[0]]\n        for start,end in intervals[1:]:\n            # check last non-covered interval, \u5f88\u6700\u8fd1\u7684\u4e00\u6761\u5927\u9c7c\u8fdb\u884c\u6bd4\u8d5b\n            prev_start,prev_end = res[-1]\n\n            if start &gt;= prev_start and end &lt;= prev_end:\n                # covered! we can't do that!!\n                continue            \n            res.append([start,end])\n\n        return len(res)\n</code></pre> Then we can simplify out logic by</p> <ul> <li>replace <code>if start &gt;= prev_start and end &lt;= prev_end:</code> with <code>if end &lt;= prev_end:</code> \u6211\u4eec\u5df2\u7ecf\u6309start_time\u5347\u5e8f\u6392\u5217\u4e86\uff0c\u6240\u4ee5prev_start &lt;= start\u662f\u6052\u6210\u7acb\u7684</li> <li>\u6211\u4eec\u53ea\u5173\u5fc3last element, \u6700\u540e\u6c42\u7684\u662f\u957f\u5ea6\u3002\u6240\u4ee5\u7ef4\u62a4\u4e00\u4e2alast element\u548ccounter\u5c31\u597d\u4e86.</li> </ul> <pre><code>class Solution:\ndef removeCoveredIntervals(self, intervals: List[List[int]]) -&gt; int:\n    # \u5927\u9c7c\u5403\u5c0f\u9c7c: \u5c0f\u7684interval, \u5982\u679c\u88abcover\u6389\u5c31\u4f1a\u5403\u6389\u4e86\uff0c\u6240\u4ee5\u5269\u4e0b\u7684\u90fd\u662f\u5927\u9c7c.\n\n    # sort by start_time aescendingly, then by end_time descendingly\n    intervals.sort(key=lambda x:(x[0],-x[1]))\n\n    # greedy\n    last = intervals[0]\n    counter = 1\n    for start,end in intervals[1:]:\n        # check last non-covered interval, \u5f88\u6700\u8fd1\u7684\u4e00\u6761\u5927\u9c7c\u8fdb\u884c\u6bd4\u8d5b\n        prev_start,prev_end = last\n\n        if end &lt;= prev_end:\n            # covered! we can't do that!!\n            continue            \n        # now, i am the new king!\n        last = [start,end]\n        counter += 1\n\n    return counter\n</code></pre>","tags":["Array","Sorting"]},{"location":"leetcode/1288-remove-covered-intervals/#case-3-sort-by-end_time-descendingly-then-by-start_time-aescendingly","title":"Case 3: sort by end_time descendingly, then by start_time aescendingly","text":"<p>\u540c\u7406\uff0c\u5269\u4e0b\u7684\u51e0\u4e2acase\u4ee3\u7801\u5982\u4e0b</p> <p>case 3</p> <pre><code>class Solution:\ndef removeCoveredIntervals(self, intervals: List[List[int]]) -&gt; int:        \n    intervals.sort(key=lambda x:(-x[1],x[0]))\n\n    # greedy\n    res = [intervals[0]]\n    for start,end in intervals[1:]:\n        # check last non-covered interval, \u5f88\u6700\u8fd1\u7684\u4e00\u6761\u5927\u9c7c\u8fdb\u884c\u6bd4\u8d5b\n        prev_start,prev_end = res[-1]\n\n        if start &gt;= prev_start:\n            # covered! we can't do that!!\n            continue            \n        res.append([start,end])\n\n    return len(res)\n</code></pre>","tags":["Array","Sorting"]},{"location":"leetcode/1288-remove-covered-intervals/#approach-3-coveredinterval","title":"Approach 3: \u8ba1\u7b97\u88abcovered\u7684interval\u6570\u91cf","text":"<p>conjugate\u5373\u53ef\uff0ci.e. \u8ba1\u7b97\u4e0d\u88abcover\u7684interval\u6570\u91cf\uff0c\u7136\u540e\u7528<code>n - x</code>\u5373\u53ef\u3002</p>","tags":["Array","Sorting"]},{"location":"leetcode/1289-minimum-falling-path-sum-II/","title":"1289 Minimum Falling Path Sum II","text":"","tags":["Array","Matrix","Dynamic Programming"]},{"location":"leetcode/1289-minimum-falling-path-sum-II/#approach-1-bottom-up","title":"Approach 1: bottom-up","text":"<p>This is a constrained problem when you can't fall directly down to the same column. Therefore, the optimal path would be falling the last row's minimum value except for the same column. Brute force it will be O(N^3) time complexity. </p> <p>Complexity</p> <ul> <li>Time complexity: \\(O(N^3)\\)</li> <li>Space complexity: \\(O(N)\\)</li> </ul> <pre><code>class Solution:\n    def minFallingPathSum(self, grid: List[List[int]]) -&gt; int:\n        n = len(grid)\n        # initialize\n        prev = grid[0]\n\n        def helper(i,arr):\n            \"\"\"get min of array except for index i\n            \"\"\"\n            res = float('inf')\n            for j,item in enumerate(arr):\n                if j == i:\n                    continue\n                res = min(res,item)\n            return res\n\n        for i in range(1,n):\n            curr = [0 for _ in range(n)]\n            for j in range(n):\n                curr[j] = grid[i][j] + helper(j,prev)\n\n            prev = curr.copy()\n        return min(prev)                \n</code></pre>","tags":["Array","Matrix","Dynamic Programming"]},{"location":"leetcode/1289-minimum-falling-path-sum-II/#approach-2-optimized","title":"Approach 2 Optimized","text":"<p>\u6211\u4eec\u53d1\u73b0\uff0c\u5bf9\u4e8e\u6bcf\u4e00\u884c\uff0c\u6211\u4eec\u53ea\u9700\u8981\u627e\u5230\u6700\u5c0f\u7684\u4e24\u4e2a\u5143\u7d20\uff0c\u7136\u540e\u66f4\u65b0\u4e0b\u4e00\u884c\u7684\u503c\u3002\u8fd9\u6837\u6211\u4eec\u53ef\u4ee5\u5c06\u65f6\u95f4\u590d\u6742\u5ea6\u964d\u4f4e\u5230\\(O(N^2)\\)\u3002</p> <p>Complexity</p> <ul> <li>Time complexity: \\(O(N^2)\\)</li> <li>Space complexity: \\(O(n)\\)</li> </ul>","tags":["Array","Matrix","Dynamic Programming"]},{"location":"leetcode/1289-minimum-falling-path-sum-II/#code-implementation","title":"Code Implementation","text":"<pre><code>class Solution:\n    def minFallingPathSum(self, grid: List[List[int]]) -&gt; int:\n        n = len(grid)\n        if n == 1:\n            return grid[0][0]\n\n        # initialize\n        prev = grid[0]\n        curr = [0 for _ in range(n)]\n\n        def helper(arr):\n            \"\"\"get two smallest element of an arr and its index\n            it returns like [(smallest,idx),(second_smallest,idx)]\n            \"\"\"\n            smallest,smallest_i = float('inf'),None\n            sec_smallest,sec_i = float('inf'),None\n\n            for i,val in enumerate(arr):\n                if val &lt; smallest:\n                    sec_smallest,sec_i = smallest,smallest_i\n                    smallest,smallest_i = val,i\n                elif val &lt; sec_smallest:\n                    sec_smallest,sec_i = val,i\n            return [(smallest,smallest_i),(sec_smallest,sec_i)]\n\n        for i in range(1,n):            \n            lookup = helper(prev)\n            for j in range(n):\n                if j != lookup[0][1]:\n                    curr[j] = lookup[0][0] + grid[i][j]\n                else:\n                    curr[j] = lookup[1][0] + grid[i][j]\n            prev = curr.copy()\n        return min(curr)                \n</code></pre> <p>\u8fd9\u91cc\u8fd8\u53ef\u4ee5\u8fdb\u884c\u4f18\u5316\uff0c\u5176\u5b9e\u6211\u4eec\u90fd\u4e0dcare\u5177\u4f53\u7684index\uff0c\u53ea\u9700\u8981\u77e5\u9053\u6700\u5c0f\u7684\u4e24\u4e2a\u503c\u5373\u53ef\u3002\u56e0\u6b64\u6211\u4eec\u53ef\u4ee5\u4e0a\u4e00\u884c\u6700\u5c0f\u7684\u4e24\u4e2a\u503c\u5373\u53ef\u3002</p> <p>Complexity</p> <ul> <li>Time complexity: \\(O(N^2)\\)</li> <li>Space complexity: \\(O(1)\\)</li> </ul> <pre><code>class Solution:\n    def minFallingPathSum(self, grid: List[List[int]]) -&gt; int:\n        n = len(grid)\n        if n == 1:\n            return grid[0][0]\n\n\n        def get_two_smallest(arr):\n            \"\"\"get two smallest element of an arr and its index\n            it returns like [(smallest,idx),(second_smallest,idx)]\n            \"\"\"\n            smallest,smallest_i = float('inf'),None\n            sec_smallest,sec_i = float('inf'),None\n\n            for i,val in enumerate(arr):\n                if val &lt; smallest:\n                    sec_smallest,sec_i = smallest,smallest_i\n                    smallest,smallest_i = val,i\n                elif val &lt; sec_smallest:\n                    sec_smallest,sec_i = val,i\n            return [(smallest,smallest_i),(sec_smallest,sec_i)]\n        # initialize\n        prev = get_two_smallest(grid[0])\n\n        for i in range(1,n):            \n            smallest,smallest_i = float('inf'),None\n            sec_smallest,sec_i = float('inf'),None\n            for j in range(n):\n                if j != prev[0][1]:\n                    candidate = prev[0][0] + grid[i][j]\n                else:\n                    candidate = prev[1][0] + grid[i][j]\n\n                if candidate &lt; smallest:\n                    sec_smallest,sec_i = smallest,smallest_i\n                    smallest,smallest_i = candidate,j\n                elif candidate &lt; sec_smallest:\n                    sec_smallest,sec_i = candidate,j\n\n            prev = [(smallest,smallest_i),(sec_smallest,sec_i)]\n        return prev[0][0]\n</code></pre>","tags":["Array","Matrix","Dynamic Programming"]},{"location":"leetcode/129-sum-root-to-leaf-numbers/","title":"129 Sum Root to Leaf Numbers","text":"","tags":["Tree","Depth-first Search","Binary Tree"]},{"location":"leetcode/129-sum-root-to-leaf-numbers/#approach-1-iterative-dfs","title":"Approach 1 Iterative DFS","text":"<pre><code>class Solution:\n    def sumNumbers(self, root: Optional[TreeNode]) -&gt; int:\n        \"\"\"\n        obvervation:\n        - dfs, since it's unable to determine when is the leaf node reached        \n        - path to sum\u7cfb\u5217\u95ee\u9898\n\n        edge cases:\n        - leading zeros at root for example\n        \"\"\"\n        res = []        \n        curr = root\n        stack = [(curr,'')]\n        res = 0\n        while stack:\n            node, root_to_curr = stack.pop()\n\n            root_to_curr += str(node.val)\n\n            if not node.left and not node.right:\n                res += int(root_to_curr)\n\n            if node.left:\n                stack.append((node.left,root_to_curr))\n            if node.right:\n                stack.append((node.right,root_to_curr))\n        return res\n</code></pre> <p>\u6709\u51e0\u4e2a\u5c0f\u4f18\u5316:</p> <ul> <li>string costs more space than int, so we can use int to represent the path</li> <li>string concatenation is expensive</li> </ul> - string int \u7d2f\u52a0 <code>root_to_curr += str(node.val)</code> <code>curr_val = 10*curr_val + node.val</code> <pre><code>class Solution:\n    def sumNumbers(self, root: Optional[TreeNode]) -&gt; int:\n        \"\"\"\n        obvervation:\n        - dfs, since it's unable to determine when is the leaf node reached        \n        - path to sum\u7cfb\u5217\u95ee\u9898\n\n        edge cases:\n        - leading zeros at root for example\n        \"\"\"\n        res = []        \n        curr = root\n        stack = [(curr,0)]\n        res = 0\n        while stack:\n            node, curr_val = stack.pop()\n\n            curr_val = 10*curr_val + node.val\n\n            if not node.left and not node.right:\n                res += curr_val\n\n            if node.right:\n                stack.append((node.right,curr_val))\n            if node.left:\n                stack.append((node.left,curr_val))\n\n        return res\n</code></pre>","tags":["Tree","Depth-first Search","Binary Tree"]},{"location":"leetcode/13-roman-to-integer/","title":"Readme","text":""},{"location":"leetcode/13-roman-to-integer/#approach-1-brute-force","title":"Approach 1: Brute force","text":""},{"location":"leetcode/13-roman-to-integer/#intuition","title":"Intuition","text":"<p>Roman to Integer\u8fd9\u4e00\u9898, \u7b2c\u4e00\u6b21\u63a5\u89e6\u7f57\u9a6c\u6570\u5b57\u65f6\uff0c\u662f\u5c0f\u65f6\u5019\u73a9\u771f\u4e09\u56fd\u65e0\u53cc4\u65f6\u5019\uff0c\u5c31\u77e5\u9053\u771f\u4e09\u56fd\u65e0\u53ccIV.  \u7531\u6b64\u77e5\u9053\u7f57\u9a6c\u6570\u5b57, \u5982\u4e0b |Symbol|Value| |-|-| |I|1| |V|5| |X|10| |L|50| |C|100| |D|500| |M|1000|</p> <p>\u9664\u6b64\u4e4b\u5916\uff0c\u5c06\u7f57\u9a6c\u6570\u5b57\u7684\u51e0\u4e2a\u7279\u6b8a\u7528\u6cd5\uff0c\u603b\u7ed3\u5f52\u7eb3\u5982\u4e0b |Symbol|Value| |-|-| |IV|4| |IX|9| |XL|40| |XC|90| |CD|400| |CM|900|</p> <p>\u8fd9\u6837\u7684\u8bdd\uff0c\u8fd9\u9053\u9898\u5c31\u53ef\u4ee5\u8bbe\u8ba1\u6210\u4e09\u6b65 - \u8bbe\u7acb\u4e24\u4e2ahash table, \u4e00\u4e2a\u5b58\u88681\uff0c\u53e6\u4e00\u4e2a\u5b58\u88682 - \u5faa\u73af\uff0c\u5148\u68c0\u7d22\u662f\u5426\u5b58\u5728\u7279\u6b8a\u7528\u6cd5,\u5982IV\u7b49\uff0c\u4e00\u65e6\u627e\u5230\u5c06first occurence of certain key\u66ff\u6362\u4e3a<code>\"\"</code>,\u5982\u4e0b<code>string.replace(\"IV\",\"\",1)</code> - \u5faa\u73af\u68c0\u7d22\u662f\u5426\u5b58\u5728\u5176\u5b83\u5e38\u6570\u9879\u76f4\u5230\u4e3a\u7ed3\u675f</p> <p>\u4ee3\u7801\u5982\u4e0b, <pre><code>class Solution:\n    def romanToInt(self, s: str) -&gt; int:\n        # declare of output integer\n        output = 0\n        # declare of two hashmap\n        hashmap_basic = {\n            'I': 1,\n            'V': 5,\n            'X': 10,\n            'L': 50,\n            'C': 100,\n            'D': 500,\n            'M': 1000\n        }\n        hashmap_derived = {\n            'IV': 4,\n            'IX': 9,\n            'XL': 40,\n            'XC': 90,\n            'CD': 400,\n            'CM': 900\n        }\n\n        # better use while\n        for item in hashmap_derived.keys():\n            # check if any key in it\n            if item in s:\n                output += hashmap_derived[item]\n                s = s.replace(item,\"\",1)\n\n        # check basic dictionary\n        while s is not '':\n            for item in hashmap_basic.keys():\n                if item in s:\n                    output += hashmap_basic[item]\n                    s = s.replace(item,\"\",1)\n\n        return output\n</code></pre></p> <p>\u590d\u6742\u5ea6\u6765\u8bf4\uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\u4e3a\\(O(1)\\), \u65f6\u95f4\u590d\u6742\u5ea6</p>"},{"location":"leetcode/13-roman-to-integer/#approach-2-brute-force","title":"Approach 2: brute force \u7b80\u5355\u4f18\u5316","text":"<p>jerry\u63d0\u793a\u6211\uff0c\u7b2c\u4e8c\u6b65\u4e2dfor loop nested in while loop\u662f\u5f88\u591a\u4f59\u7684\uff0c\u800c\u4e14<code>s.replace()</code> \u5728python\u4e2d\u8ba1\u7b97\u4e5f\u6bd4\u8f83\u6162, \u53ef\u4ee5\u76f4\u63a5iterate string.</p> <p>\u7531\u6b64\u66f4\u6539\u4ee3\u7801\u5982\u4e0b:</p> <pre><code>class Solution:\n    def romanToInt(self, s: str) -&gt; int:\n        # declare of output integer\n        output = 0\n        # declare of two hashmap\n        hashmap_basic = {\n            'I': 1,\n            'V': 5,\n            'X': 10,\n            'L': 50,\n            'C': 100,\n            'D': 500,\n            'M': 1000\n        }\n        hashmap_derived = {\n            'IV': 4,\n            'IX': 9,\n            'XL': 40,\n            'XC': 90,\n            'CD': 400,\n            'CM': 900\n        }\n\n        # better use while\n        for item in hashmap_derived.keys():\n            # check if any key in it\n            if item in s:\n                output += hashmap_derived[item]\n                s = s.replace(item,\"\",1)\n\n        # \u7531\u4e8e\u4e0d\u5b58\u5728\u7279\u4f8b\u4e86\uff0c\u76f4\u63a5iterate string\u5c31\u597d\n        for c in s:\n            output += hashmap_basic[c]\n\n        return output\n</code></pre>"},{"location":"leetcode/1351-count-negative-numbers-in-a-sorted-matrix/","title":"1351 Count Negative Numbers in a Sorted Matrix","text":"<p>\u7528\u4ee5\u4e0bcombination\u65f6\u5019:</p> <ul> <li><code>while left &lt;= right</code></li> <li><code>left = mid + 1 if nums[mid] &gt;= 0</code></li> <li><code>right = mid - 1 if nums[mid] &lt; 0</code></li> </ul> <p>\u79bb\u5f00while loop\u540e\uff0c\u6211\u4eec\u62e5\u6709\u7684\u6761\u4ef6\u662f:</p> <ul> <li>left = right + 1</li> <li>Case 1: \u6570\u7ec4\u4e2d\u6709\u5c0f\u4e8e0\u7684\u6570\uff0c\u90a3\u4e48left\u6307\u5411\u7684\u662f\u7b2c\u4e00\u4e2a\u5c0f\u4e8e0\u7684\u6570</li> <li>Case 2: \u6570\u7ec4\u4e2d\u6ca1\u6709\u5c0f\u4e8e0\u7684\u6570\uff0c\u4e5f\u5c31\u662f\u5168\u662f\u6b63\u6574\u6570\u3002\u90a3\u4e48left\u6307\u5411\u7684\u662f\u6570\u7ec4\u7684\u957f\u5ea6</li> </ul> <p></p> <pre><code>class Solution:\n    def countNegatives(self, grid: List[List[int]]) -&gt; int:\n        # 4,3,2,-1\n        def helper(nums):\n            res = 0\n            n = len(nums)\n            left,right = 0,n-1\n\n            while left &lt;= right:\n                mid = (left + right)//2\n                if nums[mid] &gt;= 0:\n                    # condition not satisfied\n                    left = mid + 1\n                else:\n                    right = mid - 1\n\n            # nums[left] being the either the 1st element that smaller than 0\n            # or the array is full of positive numbers and we at the end\n            if left == n:\n                return 0\n            else:\n                return n - left\n\n        res = 0\n        for row in grid:\n            res += helper(row)\n        return res\n</code></pre>","tags":["Array","Matrix","Binary Search"]},{"location":"leetcode/136-single-number/","title":"136 Single Number","text":"","tags":[1]},{"location":"leetcode/136-single-number/#approach-1-bit-manipulation","title":"Approach 1 bit manipulation","text":"<p>XOR has two properties:</p> <ul> <li><code>a^a = 0</code></li> <li><code>a^0 = a</code></li> </ul> <p>\u4e3e\u4e2a\u4f8b\u5b50</p> <p>$$ \\begin{align} LHS &amp;= a \\oplus b \\oplus c \\oplus a \\oplus c \\ &amp;= \\left(a \\oplus a\\right) \\oplus b \\oplus \\left(c \\oplus c\\right)\\ &amp;= 0 \\oplus b \\oplus 0\\ &amp;= b \\end{align} $$ where \\(\\oplus\\) is XOR, XOR has commutative property (\u4ea4\u6362\u5f8b)</p> <p>\u8fd9\u4e2a\u65b9\u6cd5\u53ef\u4ee5\u5f88\u65b9\u4fbf\u7684\u627e\u5230unique value, \u518d\u4e3e\u4e2a\u4f8b\u5b50\uff0c\u4e00\u4e2a\u6570\u5217<code>he = [2,2,3,1,3]</code>, convert it to binary and do the following</p> <p>$$ \\begin{align}     10\\     10\\     11\\     01\\     11\\     ----\\     01 \\end{align} $$ \u4e24\u4e24\u76f4\u63a5\u8fdb\u884cexclusive or, solution in binary is <code>01</code> convert back, it's 1</p> <p>Complexity</p> <p>Time complexity \\(O(n)\\), one-pass solution Space complexity \\(O(1)\\)</p>","tags":[1]},{"location":"leetcode/136-single-number/#code","title":"Code","text":"<pre><code>class Solution:\n    def singleNumber(self, nums: List[int]) -&gt; int:\n        a = 0\n        for num in nums:\n            a = a^num\n\n        return a\n</code></pre>","tags":[1]},{"location":"leetcode/1365-how-many-numbers-are-smaller-than-the-current-number/","title":"1365 How Many Numbers Are Smaller Than the Current Number","text":"","tags":["Array","Hash Table","Sorting","Counting"]},{"location":"leetcode/1365-how-many-numbers-are-smaller-than-the-current-number/#approach-1-brute-force","title":"Approach 1 Brute Force","text":"<pre><code>class Solution:\n    def smallerNumbersThanCurrent(self, nums: List[int]) -&gt; List[int]:\n        # find how many numbers are strictly smaller than this number\n        # brute force would be O(n^2)\n        res = []\n        n = len(nums)\n        for i in range(n):\n            temp = 0\n            for j in range(n):\n                if i == j:\n                    continue\n                if nums[j] &lt; nums[i]:\n                    temp += 1            \n            res.append(temp)\n\n        return res\n</code></pre>","tags":["Array","Hash Table","Sorting","Counting"]},{"location":"leetcode/1365-how-many-numbers-are-smaller-than-the-current-number/#approach-2-sorting-binary-search","title":"Approach 2 Sorting + Binary Search","text":"<p>\u53d1\u73b0\u7b54\u6848\u5c31\u5728\u6392\u5e8f\u540e\u7684\u6570\u7ec4\u4e2d\uff0c\u6240\u4ee5\u53ef\u4ee5\u5148\u6392\u5e8f\uff0c\u7136\u540e\u7528binary search\u627e\u5230\u6bcf\u4e2a\u6570\u5b57\u7684index, \u7a0d\u5fae\u5feb\u4e00\u4e9b\\(O(n\\log n)\\)</p> <pre><code>from bisect import bisect_left\nclass Solution:\n    def smallerNumbersThanCurrent(self, nums: List[int]) -&gt; List[int]:\n        # for 8, find the index where 8 need to insert to the right like [1,2,2,3,]\n        # [1,2,2,3,8]\n        # 8, [1,2,2,3] --&gt; 4\n        # 1, 0\n        # 2. 1\n\n        lookup = sorted(nums)\n        res = []\n        for num in nums:\n            index = bisect_left(lookup,num)\n            res.append(index)\n        return res\n</code></pre>","tags":["Array","Hash Table","Sorting","Counting"]},{"location":"leetcode/14-longest-common-prefix/","title":"Approach 1: Horizontal scanning","text":""},{"location":"leetcode/14-longest-common-prefix/#intuition","title":"Intuition","text":"<p>\u5047\u8bbe\u6709\u4e00\u4e2alist\u91cc\u9762\u6709\u5f88\u591a\u4e0d\u540c\u7684strings, \u8981\u627e\u51fa\u5176\u4e2d\u7684common pre-fix, \u6211\u4eec\u8bbe\u8ba1\u4e00\u4e2a\u51fd\u6570\\(P(0,1,2,\\dots,n-1)\\) \u5176\u4e2d 0, 1, 2,\\(\\dots\\)\u4e3a\u5176\u4e2d\u6240\u6709\u7684string\u7684index, \u6211\u4eec\u7684\u76ee\u6807\u662f\u627e\u5230: $$ P(0,1,\\dots,n-1) $$ \u53ef\u4ee5\u5c06\u8fd9\u4e2a\u95ee\u9898\u8f6c\u5316\u4e3a $$ P(0,1,\\dots,n-1) = P(\\dots P(P(P(0,1),2),3)\\dots,n-1) $$</p>"},{"location":"leetcode/14-longest-common-prefix/#algorithm","title":"Algorithm","text":"<ul> <li>create a function <code>twoStrCommonPrefix()</code> that takes input of two strings and output the common prefix between the two, AKA \u8d1f\u8d23\\(P(1,2)\\)</li> <li>traverse the whole list <code>strs</code> and call the function <code>twoStrCommonPrefix</code> n -1\u6b21, valla </li> </ul>"},{"location":"leetcode/14-longest-common-prefix/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: \\(O(S)\\) where S is the total number of chars inside the list <code>strs</code> </li> </ul> <ul> <li>Space complexity: \\(O(1)\\)</li> </ul>"},{"location":"leetcode/14-longest-common-prefix/#code","title":"Code","text":"<pre><code>class Solution:\n    def twoStrCommonPrefix(self,s,t):\n        # s: input string 1\n        # t: input string 2\n        # res [str]: common prefix between two strings\n        res = \"\"\n\n        # determine the min length between two characters\n        min_length = min(len(s),len(t))\n\n        # iterate the smaller string\n        for i in range(min_length):\n            # \u5224\u65ad\u4fe9\u5b57\u7b26\u662f\u5426\u76f8\u7b49\n            if s[i] == t[i]:\n                # \u76f8\u7b49\u5219\u7d2f\u52a0\u5165res\n                res += s[i]\n            else:\n                # \u4e0d\u76f8\u7b49\u76f4\u63a5return res\u4e3acommon prefix \n                return res\n\n        return res\n\n    def longestCommonPrefix(self, strs: List[str]) -&gt; str:\n        # horizontal scanning appraoch\n\n        # edge cases\n        if len(strs) == 0:\n            return \"\"\n\n\n        res = strs[0]\n        for i in range(len(strs)-1):\n            # \u6bd4\u8f83\u4fe9\u76f8\u90bb\u7684string\n            res = self.twoStrCommonPrefix(res,strs[i+1])\n\n\n        return res\n</code></pre>"},{"location":"leetcode/14-longest-common-prefix/#approach-2-vertical-scanning","title":"Approach 2: Vertical scanning","text":""},{"location":"leetcode/14-longest-common-prefix/#intuition_1","title":"Intuition","text":""},{"location":"leetcode/14-longest-common-prefix/#complexity_1","title":"Complexity","text":"<p>Vertical scanning\u5728\u7b97\u6cd5\u590d\u6742\u5ea6\u4e0a\uff0c\u5e76\u6ca1\u6709\u4ec0\u4e48\u4f18\u5316, \u4f46\u5b9e\u9645performance\u6709\u5f88\u5927\u7684\u63d0\u5347, \u7531\u4e8ehorizontal scanning\u6c38\u8fdc\u662fworst case scenerio (traverse all the strings inside the list), \u800chorizontal scanning\u5e76\u4e0d\u4e00\u5b9a\u603b\u662fworst case.</p> <ul> <li>Time complexity: \\(O(S)\\) where S is the total number of chars inside the list <code>strs</code> </li> </ul> <ul> <li>Space complexity: \\(O(1)\\)</li> </ul>"},{"location":"leetcode/14-longest-common-prefix/#code_1","title":"Code","text":"<pre><code>class Solution:\n    def longestCommonPrefix(self, strs: List[str]) -&gt; str:\n        # vertical scan Solution\n\n        # if no common prefix, then \"\"\n        res = \"\"\n\n        # iterate i time where i equals number of chars in the str\n        # i \u4e3a\u6bd4\u8f83\u7b2c\u51e0\u4e2acharacter\n        for i in range(len(strs[0])):\n            # traverse str\n            for str in strs:\n                # \u5224\u65ad\u662f\u5426index out of range OR \u4e0d\u76f8\u7b49\n                if i == len(str) or str[i] != strs[0][i]:\n                    return res\n\n            # \u7d2f\u52a0\u5165string\n            res += strs[0][i]\n\n        return res\n</code></pre>"},{"location":"leetcode/141-linked-list-cycle/","title":"141 Linked List Cycle","text":"<p>Follow up: can you solve it using O(1) (i.e. constant) memory?</p>","tags":["Linked List","Hash Table","Two Pointers"]},{"location":"leetcode/141-linked-list-cycle/#approach-1-floyds-turtle-and-hare","title":"Approach 1: Floyd's turtle and hare","text":"<p>Classic cycle detection problem in linked list, could be solved by floyd's turtle and hare. </p> <p>Floyd's turtle and hare falls in the category of</p> <ul> <li>two pointers, </li> <li>same direction</li> <li>two pointers moving at different speed (default is double)</li> </ul> <p>Floyd's Turtle and Hare</p> <p>\u662f\u4e00\u79cd\u901a\u7528\u89e3for cycle detection in linked list. \u7528\u4e24\u4e2a\u6307\u9488\uff0c\u4e00\u4e2a\u5feb\u4e00\u4e2a\u6162\uff0c\u5982\u679c\u6709cycle\uff0c\u5feb\u7684\u603b\u4f1a\u8ffd\u4e0a\u6162\u7684.</p> <pre><code>class Solution:\n    def hasCycle(self, head: Optional[ListNode]) -&gt; bool:\n\n        if not head: return False\n\n        slow = head\n        fast = head\n\n        while fast and fast.next:\n            fast = fast.next.next\n            slow = slow.next\n\n            if fast == slow:\n                return True\n\n        return False\n</code></pre>","tags":["Linked List","Hash Table","Two Pointers"]},{"location":"leetcode/142-linked-list-cycle-II/","title":"Problem","text":"<p>Given the <code>head</code> of a linked list, return the node where the cycle begins. If there is no cycle, return <code>null</code>.</p> <p>There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the <code>next</code> pointer. Internally, <code>pos</code> is used to denote the index of the node that tail's <code>next</code> pointer is connected to (0-indexed). It is <code>-1</code> if there is no cycle. Note that <code>pos</code> is not passed as a parameter.</p> <p>Do not modify the linked list.</p> <p>Example 1:</p> <p></p> <pre><code>Input: head = [3,2,0,-4], pos = 1\nOutput: tail connects to node index 1\nExplanation: There is a cycle in the linked list, where tail connects to the second node.\n</code></pre>"},{"location":"leetcode/142-linked-list-cycle-II/#intuition","title":"Intuition","text":"<p>Recall the floyd's hare and turtle for cycle detection as illustrated in the figure below. If we label the length, we have the following</p> symbol description \\(L\\) length of the cycle \\(x\\) the distance from the <code>head</code> to the start of the cycle \\(y\\) the distance from the start of the cycle to the position they met <p></p> <p>If the hare is moving at a speed two-times faster than the hare, they will meet with each other at an arbitrary location inside the cycle. Now two things happen: - bugs bunny starts to nap - a dragon appears and starts to move at the same speed as the turtle from the <code>head</code></p> <p></p> <p>Then the dragon and the hare will meet up at the start of the cycle. But how? Please see the proof section.</p> <p></p>"},{"location":"leetcode/142-linked-list-cycle-II/#math-proof","title":"Math proof","text":"<p>Let's assume  $$ \\begin{align} d_{1} = x + y + n_1\\times L \\ d_{2} = x + y + n_2\\times L \\end{align} $$ where \\(d_{1}\\) and \\(d_{2}\\) are the distance covered by the turtle and the hare, respectively, and \\(n_1\\) and \\(n_2\\) are the distance number of cycles taken by the turtle and hare, respectively.</p> <p>Since we know that the speed of hare is two times faster than the turtle and they start their racing at the <code>head</code> simultaneously. Then the distance traveled by the hare will be exactly two-times the distance traveled by the turtle, which means $$ \\begin{align} 2d_1 = d_2 \\end{align} $$</p> <p>Then we substitute equations 1 and 2 into 2, $$ \\begin{align}     2d_1 &amp;= d_2 \\     2x + 2y + 2n_1L &amp;= x + y + n_2L \\     x + y + (2n_1 - n_2)L &amp;= 0 \\     x &amp;= (n_2 - 2n_1)L - y \\geq 0 \\end{align} $$ where \\(n_2,n_1 \\in Z\\)</p> <p>From equations 7, we know \\(L&gt;y\\) and \\(x&gt;0\\), then we have</p> <p>$$ k = n_2 - 2n_1 \\geq 1 $$ where k is \u5927\u4e8e\u7b49\u4e8e1\u7684\u6b63\u6574\u6570.</p> <p>Let's do some trick with the equation 7 $$ \\begin{align}     x &amp;= kL - y \\     x &amp;= \\left(k-1\\right)L + \\left(L - y\\right) \\ \\end{align} $$ where \\(k-1\\geq0\\)</p> <p>As we know, \\(x\\) is defined as the distance from the <code>head</code> to the start of the cycle. If dragon and turtle moving at the same speed, this means that the dragon will - dragon travels \\(x = \\left(k-1\\right)L + \\left(L - y\\right)\\) to get to the start of the linked list</p> <p>Let's look at the turtle, if we generalize when the turtle will travel from A (turtle met bug bunnys) to B (the start of the cycle), then $$ s_{turtle} = NL + (L-y) $$ where \\(N\\geq0\\) and \\(N\\in Z\\) </p> <p>You realize that distance traveled by turtle \\(s_{turtle}\\) and dragon \\(x\\) is the same.Then dragon and the turtle will meet at the start of the cycle.</p> <p></p>"},{"location":"leetcode/142-linked-list-cycle-II/#solution","title":"Solution","text":""},{"location":"leetcode/142-linked-list-cycle-II/#optimal","title":"Optimal","text":"<pre><code>class Solution:\n    def detectCycle(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:\n        slow = head\n        fast = head\n\n        while fast and fast.next:\n            slow, fast = slow.next, fast.next.next\n\n            if slow == fast:\n                curr = head\n                while curr != slow:\n                    curr, slow = curr.next, slow.next\n\n                return curr\n\n\n        # no cycle at all\n        return None\n</code></pre>"},{"location":"leetcode/142-linked-list-cycle-II/#brute-force","title":"Brute force","text":"<pre><code># Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def detectCycle(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:\n        hashset = set()\n\n        curr = head\n\n        while curr:\n            if curr not in hashset:\n                hashset.add(curr)\n            else:\n                return curr\n            curr = curr.next\n\n        return None\n</code></pre>"},{"location":"leetcode/143-reorder-list/","title":"143 Reorder List","text":"<p>You are given the head of a singly linked-list. The list can be represented as:</p> <p>L0 \u2192 L1 \u2192 \u2026 \u2192 Ln - 1 \u2192 Ln Reorder the list to be on the following form:</p> <p>L0 \u2192 Ln \u2192 L1 \u2192 Ln - 1 \u2192 L2 \u2192 Ln - 2 \u2192 \u2026</p> <p>You may not modify the values in the list's nodes. Only nodes themselves may be changed.</p>","tags":["Linked List","Two Pointers","Stack","Recursion"]},{"location":"leetcode/143-reorder-list/#approach-1-two-pointers","title":"Approach 1 Two Pointers","text":"<p>\u6839\u636e\u9898\u76ee\u8981\u6c42\uff0c\u4e00\u5934\u4e00\u5c3e\u4f9d\u6b21\u8fde\u63a5\uff0c\u90a3\u5176\u5b9e\u5f88\u81ea\u7136\u60f3\u5230two pointers on both ends, \u7136\u540e\u505a\u4e00\u4e9bnode manipulation. \u4f46\u7531\u4e8e\u9898\u76ee\u7ed9\u5b9a\u7684\u662fsingly linked list, \u6240\u4ee5\u6211\u4eec\u6ca1\u529e\u6cd5traverse backward, \u90a3\u5c31\u5fc5\u987b\u8981\u7528\u70b9hacky way\u8ba9\u6211\u4eec\u53ef\u4ee5traverse backwards, \u56e0\u6b64\u6211\u7684\u601d\u8def\u6e90\u81ea\u4e8e\u4e3a\u4e86\u521b\u9020, \u4e00\u4e2a\u53ef\u4ee5traverse backwards\u7684\u7ed3\u6784\uff0c\u601d\u8def\u5982\u4e0b</p> <ul> <li>reverse second half of the linked list, \u601d\u8def\u548c234 Palindrome Linked List\u4e00\u6837<ul> <li>two pointers to find mid point (same direction, fast and slow)</li> <li>implement the REVERSE THE LINKED LIST</li> </ul> </li> <li>reverse the 2nd half of the linked list</li> <li>two pointer techniques to rearrange until they meet</li> </ul> <p>\u6ce8\u610f\u4e8b\u9879</p> <p>meeting condition\u8981\u5206\u7c7b\u8ba8\u8bba\uff0c</p> <ul> <li>\u5982\u679c\u662f\u5947\u6570\u4e2anode\uff0c<code>left is right</code></li> <li>\u5982\u679c\u5076\u6570\u4e2anode\uff0c<code>left.next is right</code></li> </ul> <pre><code># Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def reorderList(self, head: Optional[ListNode]) -&gt; None:\n        \"\"\"\n        Do not return anything, modify head in-place instead.\n        1. thinking two pointers, on either ends. \u4e3a\u4e86\u5229\u7528two pointers in singly linked list\n        , we have to do something since it can't traverse backward\n        Steps:\n        1. reverse second half of the linked list\n            1.1 two pointers (same direction, fast and slow to find mid point)\n            1.2 implement the REVERSE THE LINKED LIST MEME\n        2. two pointer techniques\n        \"\"\"        \n\n        # 1.1 find mid point\n        mid = self.get_mid(head)\n        # 1.2 reverse\n        right = self.reverse(mid)        \n        left = head\n\n\n        while (left is not right) and (left.next is not right):\n            l_next = left.next\n            r_next = right.next\n\n            left.next = right\n            right.next = l_next\n\n            # update pointers\n            left = l_next\n            right = r_next\n\n        return head    \n\n    def get_mid(self,head):\n        \"\"\"\n        return the middle node of the linkedlist list given head of LL\n        \"\"\"\n        if not head or not head.next:\n            return head\n\n        slow = head\n        fast = head\n\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n\n        return slow\n\n    def reverse(self,head):\n        if not head or not head.next:\n            return head\n\n        curr,prev = head,None\n        while curr:\n            temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = temp\n\n        return prev\n</code></pre>","tags":["Linked List","Two Pointers","Stack","Recursion"]},{"location":"leetcode/143-reorder-list/#approach-2-stack","title":"Approach 2 Stack","text":"<p>\u5404\u79cdreverse\u7684\u60c5\u51b5\uff0c\u80fd\u60f3\u5230stack\uff0c\u56e0\u4e3astack\u662f\u5148\u8fdb\u540e\u51fa\uff0c\u6240\u4ee5\u53ef\u4ee5\u7528stack\u6765\u5b58\u50a8node\uff0c\u7136\u540epop\u51fa\u6765\uff0c\u8fd9\u6837\u5c31\u53ef\u4ee5\u5b9e\u73b0reverse\u7684\u6548\u679c\u3002</p> <pre><code># Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def reorderList(self, head: Optional[ListNode]) -&gt; None:\n        \"\"\"\n        Do not return anything, modify head in-place instead.\n        \"\"\"\n        stack = []\n        curr = head\n        while curr:\n            stack.append(curr)\n            curr = curr.next\n\n        start = head\n        while start:\n            end = stack.pop()\n            if start is end:\n                # odd case\n                start.next = None\n                break\n            elif start.next is end:\n                # even case\n                start.next = end\n                end.next = None\n                break\n\n\n            temp = start.next\n            start.next = end\n            end.next = temp\n            # update\n            start = temp\n\n            # if start is not None and start.next == end:\n            #     start.next = None\n            #     break\n\n        return head\n</code></pre> <p>\u7f51\u53cbopendrum\u7528\u4e86\u53e6\u4e00\u79cd\u5224\u5b9a\u65b9\u6cd5\uff0c\u6211\u4e5f\u5b66\u4e9b\u4e86\u4e00\u4e0b\uff0c\u8fd9\u79cd\u65b9\u6cd5\u66f4\u7b80\u6d01\uff0c\u4e0d\u7528\u5206\u7c7b\u8ba8\u8bba\uff0c\u76f4\u63a5\u5224\u65adstart.next is end\u5373\u53ef\u3002\u5b83\u7684\u5224\u5b9a\u5728\u672b\u5c3e(\u6211\u8fd8\u662f\u6ca1\u7406\u89e3\u4e3a\u4ec0\u4e48<code>start is not None</code>)</p> <pre><code># Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def reorderList(self, head: Optional[ListNode]) -&gt; None:\n        \"\"\"\n        Do not return anything, modify head in-place instead.\n        \"\"\"\n        stack = []\n        curr = head\n        while curr:\n            stack.append(curr)\n            curr = curr.next\n\n        start = head\n        while start:\n            end = stack.pop()\n            temp = start.next\n            start.next = end\n            end.next = temp\n            # update\n            start = temp\n\n            if start is not None and start.next == end:\n                # start.next == end for odd case\n                # what about start is not None???\n                start.next = None\n                break\n\n        return head\n</code></pre>","tags":["Linked List","Two Pointers","Stack","Recursion"]},{"location":"leetcode/146-lru-cache/","title":"Problem","text":"<p>Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.</p> <p>Implement the LRUCache class:</p> <ul> <li><code>LRUCache(int capacity)</code> Initialize the LRU cache with positive size capacity.</li> <li><code>int get(int key)</code> Return the value of the key if the key exists, otherwise return -1.</li> <li><code>void put(int key, int value)</code> Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key. The functions get and put must each run in O(1) average time complexity.</li> </ul>"},{"location":"leetcode/146-lru-cache/#example1","title":"Example1","text":"<pre><code>Input\n[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"]\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\nOutput\n[null, null, null, 1, null, -1, null, -1, 3, 4]\n\nExplanation\nLRUCache lRUCache = new LRUCache(2);\nlRUCache.put(1, 1); // cache is {1=1}\nlRUCache.put(2, 2); // cache is {1=1, 2=2}\nlRUCache.get(1);    // return 1\nlRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}\nlRUCache.get(2);    // returns -1 (not found)\nlRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}\nlRUCache.get(1);    // return -1 (not found)\nlRUCache.get(3);    // return 3\nlRUCache.get(4);    // return 4\n</code></pre>"},{"location":"leetcode/146-lru-cache/#approach","title":"Approach","text":"<p>\u5b9e\u73b0LRU, \u5f80\u5f80\u662f\u901a\u8fc7HashMap + doubly linked list</p> <p>\u6211\u4eec\u53ef\u4ee5break down\u6bcf\u4e00\u4e2a\u9700\u6c42: - <code>LRUCache(int capacity)</code>: constructor for the cache, \u6709\u4e00\u5b9a\u7684\u5927\u5c0f\u9650\u5236; - <code>int get(int key)</code> search for an key, if yes, return it if no, return -1. \u9996\u5148\u60f3\u5230\u7684\u5c31\u662flinear search, binary search and hash, \u65e2\u7136\u9898\u76ee\u91cc\u8981\u6c42\u4e86O(1), it's a dead give-away that we need to use hash.</p> <ul> <li><code>void put(int key, int value)</code> Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key. \u8fd9\u4e2a\u6bd4\u8f83\u590d\u6742\uff0c\u6211\u4eec\u5206\u4e09\u79cd\u60c5\u51b5\u8ba8\u8bba:</li> <li>if key exists in key-space, we update it if necessary<ul> <li>\u6211\u4eec\u53ef\u4ee5\u7b80\u5316\u6210<code>remove</code> the node, then <code>insert</code> the node</li> </ul> </li> <li>if key doesn't exist in key-space, add it<ul> <li>just <code>insert</code> the node. \u53ef\u4ee5\u548c\u4e0a\u4e00\u6b65\u5e76\u6210\u4e00\u6b65\uff1b</li> </ul> </li> <li>if it's over capacity, we remove the least recently used (LRU)<ul> <li>\u7ed9\u6211\u4eec\u4e00\u4e2a\u6982\u5ff5\u662f\u8981\u6309\u7167\u6709\u65e0access\u8fc7\uff0c\u6765\u6392\u5e8f\uff0c\u89e3\u51b3\u601d\u8def\u662f\u6bcf\u4e00\u6b21call methods <code>get()</code> and <code>put()</code>, \u53ea\u8981\u8fd0\u884c\u6210\u529f\uff0c\u6211\u4eec\u90fd\u628a\u5b83\u632a\u5230\u94fe\u8868\u4e00\u7aef</li> </ul> </li> </ul> <p>The functions get and put must each run in O(1) average time complexity.</p>"},{"location":"leetcode/146-lru-cache/#solution","title":"Solution","text":"<pre><code>class Node:\n    def __init__(self,key,value):\n        self.key = key\n        self.value = value\n        self.prev = None\n        self.next = None\n\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.cache = {}\n\n        self.right = Node(0,0)\n        self.left = Node(0,0)\n        self.left.next = self.right\n        self.right.prev = self.left\n\n\n    def remove(self,node):\n        node.prev.next = node.next\n        node.next.prev = node.prev\n        # will node be automatically collected?\n\n    # insert the right hand side\n    def insert(self,node):\n        prev = self.right.prev\n        nxt = self.right\n\n        prev.next = node\n        nxt.prev = node\n        node.next = nxt\n        node.prev = prev\n\n    def get(self, key: int) -&gt; int:\n        if key in self.cache:\n            # it's in key space\n            # update the least usage (remove and insert)\n            self.remove(self.cache[key])\n            self.insert(self.cache[key])\n\n            return self.cache[key].value\n\n        # not found\n        return -1\n\n\n    def put(self, key: int, value: int) -&gt; None:\n        # it it's in key space\n        # it's not in key space\n        # it's over capacity\n        if key in self.cache:\n            self.remove(self.cache[key])\n\n        # create a new node\n        node = Node(key,value)\n        # put it in the hash\n        self.cache[key] = node\n        # insert the node to the right-mose\n        self.insert(node) # you could use self.insert(self.cache[key]), they both points to the same node\n\n        # delete the least recently used, insert the new node\n        if len(self.cache) &gt; self.capacity:\n            # delete lru, evict space on the hash\n            lru = self.left.next\n            self.remove(lru)\n            del self.cache[lru.key]\n\n# Your LRUCache object will be instantiated and called as such:\n# obj = LRUCache(capacity)\n# param_1 = obj.get(key)\n# obj.put(key,value)\n</code></pre>"},{"location":"leetcode/146-lru-cache/#reference","title":"Reference","text":"<ul> <li>\u8003\u535a</li> <li>neetcode</li> </ul>"},{"location":"leetcode/1463-cherry-pickup-II/","title":"1463 Cherry Pickup II","text":"<p>\u8fd9\u9898\u4f5c\u4e3a\u6e7e\u533a\u4e09\u4fd7(\u91c7\u6458, hiking, \u72fc\u4eba\u6740)\uff0c\u662f\u76f8\u5f53\u6709\u610f\u601d\u76842\u7ef4DP\u7684\u9898\u76ee. \u8fd9\u4e00\u9898\u6211\u4eec\u4f1a\u63a2\u7d22, </p> <ul> <li>\u4e0d\u540c\u7684DP\u7684\u72b6\u6001\u5b9a\u4e49, \u5bfc\u81f4\u7684\u89e3\u6cd5\u4e0d\u540c. i.e. \u4ece\u4e0a\u5f80\u4e0b\u8d70\u548c\u4ece\u4e0b\u5f80\u4e0a\u8d70\u7684\u533a\u522b.</li> </ul>","tags":["Array","Matrix","Dynamic Programming"]},{"location":"leetcode/1463-cherry-pickup-II/#approach-1-dp","title":"Approach 1 DP","text":"<p>\u8fd9\u4e00\u9898\u7684\u65e2\u7136\u662f\u6c42\u6700\u5927\u80fd\u62ff\u5230\u591a\u5c11cherries, \u90a3\u5c31\u662f\u4f18\u5316\u95ee\u9898\uff0c\u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u5c1d\u8bd5\u7528DP\u6765\u89e3\u51b3\uff0c\u90a3\u4e48\u5148\u770b\u770b, </p> <ul> <li><code>optimal substructure</code>: \u6700\u540e\u76ee\u6807\u662f\u8d70\u5230\u6700\u540e\u4e00\u884cn\u7684\u6700\u4f18\u89e3\uff0c\u53ef\u4ee5\u901a\u8fc7\u6c42n-1\u884c\u7684\u6700\u4f18\u89e3\uff0c\u518dincrement by one step\u7684\u6700\u4f18\u89e3\u6765\u5f97\u5230. \u8fd9\u4e5f\u5c31\u662f\u7b2c\u4e00\u4e2a\u5b50\u95ee\u9898. \u540c\u7406\uff0c\u53ef\u4ee5\u9012\u63a8\u5230\u7b2c\u4e00\u884c</li> <li><code>overlapping subproblems</code>: \u8fd9\u4e2a\u95ee\u9898\u53ef\u4ee5\u5206\u89e3\u4e3a, </li> <li>\u6c42\u89e3n-1\u884c\u7684\u6700\u4f18\u89e3</li> <li>\u6c42\u89e3n-2\u884c\u7684\u6700\u4f18\u89e3</li> <li>...</li> <li>\u7b2c\u4e00\u884c\u7684\u521d\u59cb\u6761\u4ef6</li> <li>\u5176\u4e2d\u6bcf\u4e00\u6b65\u90fd\u9700\u8981\u6c42\u89e3\u6c42base\u7684\u5b50\u95ee\u9898\uff0c\u4e5f\u5c31\u662f\u7b2c\u4e8c\u884c\u7684\u6700\u4f18\u89e3\uff0c\u6240\u4ee5\u662f\u6709\u91cd\u53e0\u7684\u5b50\u95ee\u9898\u7684.</li> </ul> <p>Note</p> <ul> <li>Time complexity: \\(O(rc^2)\\)</li> <li>Space complexity: \\(O(rc^2)\\)</li> </ul> <p>\u4efb\u4f55dp\u95ee\u9898\u90fd\u662f\u4e00\u4e2adecision tree, \u5047\u8bbe\u6211\u4eec\u53ea\u770b\u4e00\u4e2a\u673a\u5668\u4eba\uff0c\u5982\u4e0b\u56fe,</p> <p></p> <p>\u4e5f\u5c31\u662f\u6bcf\u4e00\u5c42node,\u6700\u591a\u6709\u4e09\u4e2achildren, \u4e00\u5171\u6709r\u5c42\uff0c\u6240\u4ee5\u65f6\u95f4\u590d\u6742\u5ea6\u662f\\(O(3^r)\\). \u4f46\u8fd9\u4e00\u9898\u662f\u4e24\u4e2a\u673a\u5668\u4eba\uff0c\u6240\u4ee5\u8fd9\u4e2adecision tree\u66f4\u590d\u6742\uff0c\u6bcf\u4e00\u4e2anode\u67099\u4e2achilding, \u5206\u522b\u5bf9\u5e94\u7740, state\\(s_{ij}\\) $$ \\begin{equation}     s_{ij} \\quad i,j \\in [\u5de6\u4e0a,\u4e0a\u65b9\uff0c\u53f3\u4e0a] \\end{equation} $$ where \\(i\\) and \\(j\\) are the position of the two robots. \u5bf9\u4e8e\u6bcf\u4e00\u4e2a\u683c\u5b50\u7684\u72b6\u6001\uff0c\u603b\u8ba1\u9700\u89819\u4e2a\u6765\u63cf\u8ff0\u3002\u6240\u4ee5\u9700\u8981\\(O(9^r)\\)\u7684\u65f6\u95f4\u590d\u6742\u5ea6, \u5982\u679c\u7528decision tree.</p> <p>Tip</p> <p>\u5176\u5b9e\u548cideal gas law\u4e2d\\(PV = nRT\\)\u4e2d\u4f60\u53ea\u9700\u8981\u4e24\u4e2a\u53d8\u91cf\uff0cP\u548cV (intrinsic state variables)\u6765\u63cf\u8ff0\u4e00\u4e2a\u6c14\u4f53\u7684\u72b6\u6001\u4e00\u6837\uff0c\u8fd9\u91cc\u4e5f\u9700\u8981\u63cf\u8ff0\u4e00\u4e2a\u683c\u5b50\u7684\u72b6\u6001\uff0c\u53ea\u9700\u8981\u4e24\u4e2a\u53d8\u91cf\uff0c\\(i\\)\u548c\\(j\\)\u6765\u63cf\u8ff0\u4e00\u4e2a\u683c\u5b50\u7684\u72b6\u6001. \u4f46\u533a\u522b\u662fpressure\u548cvolume\u662fscalar, \u800c\u8fd9\u91cc\u7684\\(i\\)\u548c\\(j\\)\u662fvector\u7f62\u4e86, \u6240\u4ee5\u9700\u89819\u4e2a\u6765\u63cf\u8ff0\u4e00\u4e2a\u683c\u5b50\u7684\u72b6\u6001.</p> <p>\u90a3\u5982\u679c\u6211\u4eec\u628a\u6574\u4f53\u72b6\u6001\u63cf\u8ff0\u7684\u8bdd\uff0c\u9700\u8981<code>(y,x1,x2)</code> \u6765\u63cf\u8ff0\u4e00\u4e2a\u72b6\u6001\uff0c\u5176\u4e2d<code>y</code>\u662f\u884c\u6570\uff0c<code>x1</code>\u548c<code>x2</code>\u662f\u4e24\u4e2a\u673a\u5668\u4eba\u7684\u4f4d\u7f6e\u6765\u679a\u4e3e\u6240\u6709\u7684\u72b6\u6001, \u8fd9\u5176\u5b9e\u5c31\u662f\u4e00\u4e2a\u4e09\u7ef4\u77e9\u9635. \u6240\u4ee5\u4f60\u9700\u8981\\(O(rc^2)\\)\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u6765\u50a8\u5b58\u4f60\u76843D matrix.  \u6cbb\u6108\u66f4\u65b0\u8fd9\u4e2a\u72b6\u6001\uff0c\u4f60\u9700\u8981\u4e0a\u4e00\u4e2arow\u7684\u81f3\u591a9\u4e2alattice\u7684\u503c\u6765\u8fdb\u884c\u66f4\u65b0. \u6240\u4ee5\u603b\u8ba1\u4f60\u9700\u8981, \\(O(9rc^2)\\) time complexity\u6765\u66f4\u65b0\u4f60\u7684\u72b6\u6001. \u603b\u7ed3\u4e00\u4e0b,</p> <ul> <li>time complexity \\(O(9rc^2)\\)\u7684\u66f4\u65b0\u4f60\u7684\u5168\u90e8\u72b6\u6001</li> <li>space complexity \\(O(rc^2)\\)\u6765\u50a8\u5b58\u4f60\u7684\u72b6\u6001</li> </ul> <p>\u4fe1\u606f\u6d41\u52a8\u5982\u4e0b\u56fe, </p> <p></p>","tags":["Array","Matrix","Dynamic Programming"]},{"location":"leetcode/1463-cherry-pickup-II/#dpinformation-propagation","title":"DP\u7684information propagation\u65b9\u5411","text":"<p>\u73b0\u5728\u6211\u4eec\u6709\u4e86\u4e00\u4e2a3D\u7684\u72b6\u6001\u77e9\u9635\uff0c\u6211\u4eec\u9700\u8981\u8003\u8651\u7684\u662f\uff0c\u6211\u4eec\u7684\u4fe1\u606f\u662f\u5982\u4f55\u4f20\u64ad\u7684. \u4e5f\u5c31\u662f\u6211\u4eec\u7684DP\u7684\u65b9\u5411\u662f\u5982\u4f55\u7684, \u6709\u4e24\u79cd\u53ef\u80fd\uff0c</p> <ul> <li><code>\u4ece\u4e0a\u5f80\u4e0b</code>: initial condition\u5f88\u660e\u786e, \u53ea\u6709<code>dp[0][0][c-1]</code>\u548c<code>dp[0][c-1][0]</code>\u662f\u6709\u503c\u7684\uff0c\u5176\u4ed6\u7684\u90fd\u662f0.</li> <li><code>\u4ece\u4e0b\u5f80\u4e0a</code>: \u53cd\u7740\u63a8\uff0c\u5df2\u77e5\u7ed3\u679c\u5f80\u4e0a\u63a8.</li> </ul> <p>\u8fd9\u4e00\u9898\u6211\u4eec\u9009\u62e9<code>\u4ece\u4e0b\u5f80\u4e0a</code>\u7684\u65b9\u5411\uff0c\u56e0\u4e3a\u4ece\u4e0a\u5f80\u4e0b\u63a8\u7684\u8bdd\uff0c\u6700\u540e\u6211\u4eec\u673a\u5668\u4eba\u53ef\u4ee5end up\u5728\u4efb\u4f55\u4e00\u4e2a\u4f4d\u7f6e\uff0c\u4e5f\u5c31\u662f</p> method description solution \u4ece\u4e0a\u5f80\u4e0b \u4e24\u4e2a\u673a\u5668\u4eba\uff0c\u4e00\u4e2a\u7ad9\u5728\u5de6\u4e0a<code>grid[0][0]</code>, \u53e6\u4e00\u4e2a\u7ad9\u5728\u53f3\u4e0a<code>dp[0][c-1]</code>\uff0c\u90a3\u4e48initial condition\u662f<code>dp[0][0][c-1] = grid[0][c-1] + grid[0][0]</code> \u7531\u4e8e\u673a\u5668\u4eba\u53ef\u4ee5\u5230\u4efb\u4f55\u4e00\u4e2a\u4f4d\u7f6e\uff0c\u6240\u4ee5\u8bf4\u4f60\u7684\u6700\u5927\u503c\u662farbitrary in the last slice of the 3d array, \u4e5f\u5c31\u5728\u4e00\u4e2a2\u7ef4matrix\u91cc\uff0c<code>dp[c-1][x1][x2]</code>, \u8fd9\u4e2a\u4e8c\u7ef4\u7a7a\u95f4\u5927\u5c0f\u4e3a\\(c^2\\) \u4ece\u4e0b\u5f80\u4e0a \u7531\u4e8e\u673a\u5668\u4eba\u53ef\u4ee5\u5728\u4efb\u4f55\u4f4d\u7f6e\uff0c\u6240\u4ee5\u4f60\u53ea\u9700\u8981\u7528\u66b4\u529b\u679a\u4e3e<code>O(cc)</code>\u79cd\u53ef\u80fd\u6027\u5373\u53ef \u7531\u4e8e\u4fe9\u673a\u5668\u4eba\u4e00\u5b9a\u5728\u5de6\u4e0a\u548c\u53f3\u4e0a\uff0c\u7b54\u6848\u5fc5\u7136\u5728<code>dp[0][0][c-1]</code> <p>\u73b0\u5728\u5f00\u59cbdp\u4e09\u4ef6\u5957\u5427. \u7531\u6b64\u6211\u4eec\u53ef\u4ee5\u770b\u5230\uff0c\u7528<code>\u4ece\u4e0b\u5f80\u4e0a</code>\u7684\u65b9\u5411\uff0c\u5c31\u4e0d\u9700\u8981\u6c42\u4e86\uff0c\u56e0\u4e3a\u6211\u4eec\u7684\u7b54\u6848\u4e00\u5b9a\u5728<code>dp[0][0][c-1]</code>\u8fd9\u4e2a\u4f4d\u7f6e\uff0c\u6240\u4ee5\u6211\u4eec\u9009\u62e9\u8fd9\u4e2a\u65b9\u6cd5\u6765\u6c42\u4e00\u904d.</p> <p>\u6211\u4eec\u6765\u770b\u4e00\u4e2a,<code>\u4ece\u4e0a\u5f80\u4e0b</code>\u7684\u4f8b\u5b50, \u6211\u4eec\u770b\u4e00\u4e0b\u4e00\u4e2agrid of 5x7\u7684information propagation\u4f1a\u5728\u4e00\u4e2a7x7x5\u76843d\u77e9\u9635\u91cc,\u4e0d\u65ad\u5411\u4e0b\u66f4\u65b0, \u5982\u4e0b\u56fe\u6240\u793a</p> <p></p> <p>\u7ea2\u8272\u7684cell\u4ee3\u8868\u7740\u4e0a\u4e00\u5c42\u7684\u6700\u4f18\u89e3\uff0c\u7eff\u8272\u7684cell\u4ee3\u8868\u6b63\u5728\u6c42\u7684\u6700\u4f18\u89e3\uff0c\u7eff\u8272\u7684cell\u7684\u503c\u662f\u7531\u4e0a\u4e00\u5c42\u7684\u6700\u4f18\u89e3 + \u5f53\u524d\u683c\u5b50\u7684\u503c\u6765\u7684. \u6362\u53e5\u8bdd\u8bf4\uff0c\u4f60\u5f53\u524d\u7684<code>dp[i][x_1][x_2]</code>\uff0c\u8981\u5230\u8fbe\u8fd9\u91cc\uff0c \u81f3\u591a\u53ea\u67099\u79cd\u53ef\u80fd\u6027\uff0c\u4e5f\u5c31\u662f\u4f60\u7684\u4e0a\u4e00\u5c42\u7684\u6700\u4f18\u89e3\u76849\u4e2alattice\u7684\u503c.</p>","tags":["Array","Matrix","Dynamic Programming"]},{"location":"leetcode/1463-cherry-pickup-II/#dp","title":"DP\u4e09\u4ef6\u5957","text":"","tags":["Array","Matrix","Dynamic Programming"]},{"location":"leetcode/1463-cherry-pickup-II/#dp_1","title":"DP\u72b6\u6001\u5b9a\u4e49","text":"<p>\\(dp[y][x_1][x_2]\\):</p> <ul> <li>the maximum number of cherries that can be picked up when the first robot is at \\(grid[y][x_1]\\) and the second robot is at \\(grid[y][x_2]\\) where \\(y &lt; len(grid) = r\\) and \\(x_1,x_2 &lt; len(grid[0]) = c\\)</li> </ul>","tags":["Array","Matrix","Dynamic Programming"]},{"location":"leetcode/1463-cherry-pickup-II/#dpinitial-condition","title":"DP\u7684initial condition","text":"<p>\u7531\u4e8e\u662f\u4ece\u4e0b\u5f80\u4e0apropagate, \u6240\u4ee5\u4ece\u6700\u540e\u4e00\u884c<code>r-1</code>\u5f00\u59cb</p> \\[ \\begin{equation} dp[r-1][x_1][x_2] = \\begin{cases}     grid[r-1][x_1] + grid[r-1][x_1] \\quad \\text{if }x_1 \\neq x_2\\\\     grid[r-1][x_1] \\quad \\text{if }x_1 = x_2 \\end{cases} \\end{equation} \\]","tags":["Array","Matrix","Dynamic Programming"]},{"location":"leetcode/1463-cherry-pickup-II/#dp_2","title":"DP\u7684\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b","text":"\\[ \\begin{equation} dp[y][x_1][x_2] = \\begin{cases}     max\\left(dp[y+1][x_1+i][x_2+j]\\right) + grid[y][x_1] + grid[y][x_1] \\quad \\text{if }x_1 \\neq x_2 \\\\     max\\left(dp[y+1][x_1+i][x_2+j]\\right) grid[y][x_1] \\quad \\text{if }x_1 = x_2 \\end{cases} \\end{equation} \\] <p>where \\(max\\left(dp[y+1][x_1+i][x_2+j]\\right)\\) is the cartesian product of 9 states of two robots, and \\(i\\in[-1,0,1]\\) and \\(j\\in[-1,0,1]\\)</p> <p>\u63a5\u4e0b\u6765\u5c31\u662f\u628a\u8fd9\u4e2a\u4ee3\u7801\u5199\u51fa\u6765\u5373\u53ef.</p>","tags":["Array","Matrix","Dynamic Programming"]},{"location":"leetcode/1463-cherry-pickup-II/#code-implementation","title":"Code Implementation","text":"<pre><code>class Solution:\n    def cherryPickup(self, grid: List[List[int]]) -&gt; int:\n        # dp[r][x1][x2]        \n        r,c = len(grid),len(grid[0])\n\n        # space O(r*c^2)\n        dp = [[[0 for _ in range(c)] for _ in range(c)] for _ in range(r)]\n\n        # initial condition, cartesian product of r-1,x1,x2\n        for i in range(c):\n            for j in range(c):\n                dp[r-1][i][j] = grid[r-1][i] + grid[r-1][j] if i != j else grid[r-1][i]\n\n        for y in range(r-2,-1,-1):\n            for x_1 in range(c):\n                for x_2 in range(c):\n                    temp = []\n                    for i in range(-1,2,1):\n                        for j in range(-1,2,1):\n                            if 0 &lt;= x_1 + i &lt; c and 0 &lt;= x_2 + j &lt; c:\n                                temp.append(dp[y+1][x_1+i][x_2+j])\n\n                    curr_max = max(temp)\n                    # update\n                    dp[y][x_1][x_2] = grid[y][x_1] + grid[y][x_2] if x_1 != x_2 else grid[y][x_1]\n                    dp[y][x_1][x_2] += curr_max\n\n\n        return dp[0][0][c-1]\n</code></pre>","tags":["Array","Matrix","Dynamic Programming"]},{"location":"leetcode/1463-cherry-pickup-II/#approach-2-dp-space-optimized","title":"Approach 2 DP, space optimized","text":"<p>\u6211\u4eec\u53d1\u73b0\uff0c\u5176\u5b9e\u6211\u4eec\u7684\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b\u4e2d\uff0c\u6211\u4eec\u53ea\u9700\u8981\u4e0a\u4e00\u5c42\u7684\u72b6\u6001\u6765\u66f4\u65b0\u5f53\u524d\u7684\u72b6\u6001\uff0c\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u4f18\u5316\u6211\u4eec\u7684\u7a7a\u95f4\u590d\u6742\u5ea6\uff0c\u53ea\u9700\u8981\u4e00\u4e2arolling 2D\u7684\u77e9\u9635\u5373\u53ef.</p> <p>Note</p> <ul> <li>Time complexity: \\(O(rc^2)\\)</li> <li>Space complexity: \\(O(c^2)\\)</li> </ul>","tags":["Array","Matrix","Dynamic Programming"]},{"location":"leetcode/1463-cherry-pickup-II/#reference","title":"Reference","text":"<ul> <li>\u82b1\u82b1\u9171, \u4f9d\u7136\u7b80\u7ec3</li> </ul>","tags":["Array","Matrix","Dynamic Programming"]},{"location":"leetcode/1464-maximum-product-of-two-elements-in-an-array/","title":"1464 Maximum Product of Two Elements in an Array","text":"<ul> <li>sorting</li> <li>heap(optimal)</li> <li>one pass solution(optimal)<ul> <li>tracking for top two biggest numbers</li> </ul> </li> </ul>","tags":["Array","Sorting","Heap (Priority Queue)"]},{"location":"leetcode/1464-maximum-product-of-two-elements-in-an-array/#approach-1-sorting","title":"Approach 1 Sorting","text":"<pre><code>class Solution:\n    def maxProduct(self, nums: List[int]) -&gt; int:\n        # nums[i] &gt; 0 so no negative, maximum product will be the product of top two elements\n        # goal: i != j, and max of (nums[i]-1) * (nums[j]-1). return this value\n\n        nums.sort(reverse=True)\n        return (nums[0] - 1) * (nums[1] - 1)     \n</code></pre>","tags":["Array","Sorting","Heap (Priority Queue)"]},{"location":"leetcode/1464-maximum-product-of-two-elements-in-an-array/#approach-2-heap","title":"Approach 2 Heap","text":"<p>hacky way to use min heap as max heap in python</p> <pre><code>class Solution:\n    def maxProduct(self, nums: List[int]) -&gt; int:\n        # build a max heap on top of nums, and heapify it with O(n)\n        neg_nums = [-1 * num for num in nums]\n        heapq.heapify(neg_nums)\n\n        big = heapq.heappop(neg_nums) + 1\n        second_big = heapq.heappop(neg_nums) + 1\n\n        return big * second_big\n</code></pre>","tags":["Array","Sorting","Heap (Priority Queue)"]},{"location":"leetcode/1464-maximum-product-of-two-elements-in-an-array/#approach-3-one-pass","title":"Approach 3 One Pass","text":"<p>track the encounter of top two biggest numbers with one pass solution.</p> <pre><code>class Solution:\n    def maxProduct(self, nums: List[int]) -&gt; int:\n        # nums[i] &gt;= 1\n        big,second_big = 0,0\n        for num in nums:\n            if num &gt;= big:\n                second_big = big\n                big = num\n            else:\n                second_big = max(second_big,num)\n\n        return (big - 1) * (second_big - 1)\n</code></pre>","tags":["Array","Sorting","Heap (Priority Queue)"]},{"location":"leetcode/1469-find-all-the-lonely-nodes/","title":"1469 Find All The Lonely Nodes","text":"<p>\u51e0\u79cd\u505a\u6cd5:</p> <ul> <li>iterative pre-order DFS with DFS</li> <li>recursive DFS</li> </ul>","tags":["Tree","Depth-first Search","Breadth-first Search","Binary Tree"]},{"location":"leetcode/1469-find-all-the-lonely-nodes/#approach-1-iterative-pre-order-dfs","title":"Approach 1 Iterative Pre-order DFS","text":"<pre><code>class Solution:\n    def getLonelyNodes(self, root: Optional[TreeNode]) -&gt; List[int]:\n        \"\"\"\n        observation:\n        - lonely node is the only child of its parent node. \n            - if parent has left child node, then it must not have right\n            - vice versa\n        - \u6bcf\u6b21\u8fdbstack\u7684\u65f6\u5019\uff0c\u505a\u68c0\u67e5\n        \"\"\"\n        stack = []\n        curr = root\n        res = []\n        only_child = False\n        while stack or curr:\n            while curr:\n                stack.append(curr)\n                if only_child:\n                    res.append(curr.val)\n                only_child = not curr.right\n                curr = curr.left\n\n            # reach None, \u8fd9\u65f6\u5019curr\u5fc5\u7136\u6ca1\u6709left child\n            curr = stack.pop()\n            only_child = not curr.left\n            curr = curr.right\n\n        return res\n</code></pre>","tags":["Tree","Depth-first Search","Breadth-first Search","Binary Tree"]},{"location":"leetcode/1469-find-all-the-lonely-nodes/#approach-2-recursive-dfs","title":"Approach 2 Recursive DFS","text":"<p>\u8f6c\u5316\u4e00\u4e0blonely child\u7684\u6761\u4ef6:</p> <ul> <li>\u6709parent node</li> <li>\u4e14parent node\u53ea\u6709\u4e00\u4e2achild node</li> </ul> <p>\u6240\u4ee5\u53ef\u4ee5\u5229\u7528exclusive OR\u6765\u5224\u65ad</p> <pre><code>class Solution:\n    def getLonelyNodes(self, root: Optional[TreeNode]) -&gt; List[int]:\n        res = []\n        def dfs(node,parent):\n            nonlocal res\n            if parent and (not parent.left)^(not parent.right):\n                res.append(node.val)\n            if node.left:\n                dfs(node.left,node)\n            if node.right:\n                dfs(node.right,node)\n        dfs(root,None)\n        return res\n</code></pre>","tags":["Tree","Depth-first Search","Breadth-first Search","Binary Tree"]},{"location":"leetcode/1474-delete-N-nodes-after-M-nodes-of-a-linked-list/","title":"Intuition","text":"<p>When i see linked list: - set up a dummy header node - set two pointers for helping traversal, one points to current node, one points to previous node shown in the figure below</p> <p></p>"},{"location":"leetcode/1474-delete-N-nodes-after-M-nodes-of-a-linked-list/#approach","title":"Approach","text":"<ul> <li>declare a dummy node and insert at the begining of the linked list <code>head</code></li> <li>create two pointer <code>prev</code> and <code>curr</code> refers to the previous node and current node, initialize <code>prev</code> and <code>curr</code> with <code>dummy_node</code> and <code>head</code>, respectively</li> <li>traverse until the end with <code>while</code> statement<ul> <li><code>for loop</code> of fixed <code>m</code> steps, just shuffles both pointers. <code>else</code> for cases when it reaches the end of linked list and return <code>dummy_node.next</code> (for skipping dummy node).</li> <li><code>for loop</code> of fixed <code>n</code> steps, remove the current node and shuffle <code>curr</code> pointer forward since <code>prev</code> stays at the same location. <code>else</code> for cases when it reaches the end of linked list and return <code>dummy_node.next</code> (for skipping dummy node).</li> </ul> </li> <li>return <code>dummy_node.next</code> for edge cases when <code>len(head)%(m+n) == 0</code></li> </ul>"},{"location":"leetcode/1474-delete-N-nodes-after-M-nodes-of-a-linked-list/#keep-m-phase","title":"Keep m phase","text":"<p>An graphical explanation of a test case is shown below, Let's assume the input of the test cases are: - <code>head = [1,2,3,4,5,6,7,8,9]</code> - <code>m = 2</code> - <code>n = 3</code></p> <p>During the m phase, you just neet to shuffle both <code>prev</code> and <code>curr</code> pointer forward illustrated in the figure below</p> <p></p>"},{"location":"leetcode/1474-delete-N-nodes-after-M-nodes-of-a-linked-list/#remove-n-phase","title":"Remove n phase","text":"<p>After the first m nodes, you need to do the following: - connect the previous <code>node[i-1]</code> with the <code>node[i+1]</code> using pointer <code>prev.next = curr.next</code> - move forward of the <code>curr</code> pointer by one and the <code>prev</code> pointer stays put - The node left will be collected automatically in Python.</p> <p>In the graph below, the node 3 has been skipped and collected.</p> <p></p>"},{"location":"leetcode/1474-delete-N-nodes-after-M-nodes-of-a-linked-list/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: \\(O(1)\\) one pass solution</li> </ul> <ul> <li>Space complexity: \\(O(1)\\)</li> </ul>"},{"location":"leetcode/1474-delete-N-nodes-after-M-nodes-of-a-linked-list/#code","title":"Code","text":"<pre><code># Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\nclass Solution:\n    def deleteNodes(self, head: ListNode, m: int, n: int) -&gt; ListNode:\n        # create a dummy node\n        dummy_node = ListNode(val = None,next = None)\n        dummy_node.next = head\n\n        # set up two pointer pointing to current and previous location\n        prev, curr = dummy_node,head\n\n        # traverse the linked list\n        while curr:\n            # keep m node: just shuffle forward pointers\n            for i in range(m):\n                if curr:\n                    # shuffule forward pointers\n                    prev = curr\n                    curr = curr.next\n                else:\n                    # reach end of the linekd list\n                    return dummy_node.next\n\n            for j in range(n):\n                # throw away n nodes\n                if curr:\n                    # remove node\n                    prev.next = curr.next\n                    # shuffle forward\n                    curr = curr.next\n                else:\n                    # reach the end of the linked list\n                    return dummy_node.next\n\n        # edge cases: len(head)%(m+n) == 0\n        return dummy_node.next\n</code></pre>"},{"location":"leetcode/1475-final-prices-with-a-special-discount-in-a-shop/","title":"1475 Final Prices With a Special Discount in a Shop","text":"<p>\u5f88\u597d\u7684monotonic stack\u7684\u9898\u76ee, \u7528stack\u6765\u89e3\u51b3nearest smaller element\u7684\u95ee\u9898.</p>","tags":["Array","Stack","Monotonic Stack"]},{"location":"leetcode/1475-final-prices-with-a-special-discount-in-a-shop/#approch-1-monotonic-stack","title":"Approch 1: Monotonic Stack","text":"<pre><code>class Solution:\n    def finalPrices(self, prices: List[int]) -&gt; List[int]:\n        # ==&gt; find next element smaller or equal to prices[i]\n        stack = []\n        ans = prices[:]\n        for i, price in enumerate(prices):\n            while stack and price &lt;= prices[stack[-1]]:\n                prev_index = stack.pop()\n                ans[prev_index] = prices[prev_index] - price\n\n            stack.append(i)\n\n        return ans\n</code></pre>","tags":["Array","Stack","Monotonic Stack"]},{"location":"leetcode/1481-least-number-of-unique-intergers-after-K-removals/","title":"1481 Least Number Of Unique Integers After K Removals","text":"","tags":["Array","Hash Table","Greedy","Sorting","Counting","Bucket Sort"]},{"location":"leetcode/1481-least-number-of-unique-intergers-after-K-removals/#approach-1-bucket-sort","title":"Approach 1 Bucket Sort","text":"<p>\u8fd9\u9898\u6211\u7684\u601d\u8def\u662f,  Step 1, \u5fc5\u987b\u8981\u5148\u7edf\u8ba1\u6bcf\u4e2a\u6570\u5b57\u51fa\u73b0\u7684\u6b21\u6570, \u81ea\u7136\u60f3\u5230\u7684\u662f\u7528hashmap. Hashmap\u7684\u957f\u5ea6\u5c31\u662funique number\u7684\u4e2a\u6570.</p> <p>Step 2, we sort by occurrence, \u7136\u540e\u6211\u4eec\u8981\u5220\u9664k\u4e2a\u6570\u5b57, \u5e76\u4e14\u6c42least number of unique, \u90a3\u80af\u5b9a\u662f\u6709\u4e00\u4e2a\u6309\u9891\u7387\u51fa\u73b0\u7684\u7edf\u8ba1\u5206\u5e03\u7684, \u6211\u4eec\u8981\u4ece\u6700\u5c0f\u7684\u9891\u7387\u5f00\u59cb\u5220\u9664, \u76f4\u5230k\u4e3a0.</p> <p>\u5982\u4e0b\u56fe\u6240\u793a</p> <p></p> <p>\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5build\u4e00\u4e2aarray of size n+1, \u628a\u4ed6\u4eec\u6309\u7167\u9891\u7387\u653e\u8fdb\u53bb, \u7136\u540e\u4ece\u6700\u5c0f\u7684\u5f00\u59cb\u5220\u9664, \u76f4\u5230k\u4e3a0, \u5982\u4e0b\u56fe</p> <p></p> <p>Warning</p> <p>This is a very sparse array of size n+1, we can probably optimize it.</p> <p>Then we traverse the array from the smallest frequency, and remove the number of elements from the array until k is equal or less than zeros. Need to handle three cases:</p> <ul> <li><code>k &gt; 0</code>: we still need to remove more elements, decrement the unique count by 1</li> <li><code>k == 0</code>:, After this removal, we exactly removed k elements. decrement the unique count by 1 and return it</li> <li><code>k &lt; 0</code>:, after this removal, it means it's not enough to fully remove this alphabet at this frequency, still got some left. return the unique count</li> </ul> <pre><code>from collections import defaultdict\nclass Solution:\n    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -&gt; int:\n        # create an auxillary DS with val:count and sort it by count\n        # start removing it from the count\n        hashmap = defaultdict(int)\n        n = len(arr)\n        for num in arr:\n            hashmap[num] += 1\n\n        unique = len(hashmap)\n\n        # left padding zero, \u6700\u591a\u51fa\u73b0n\u6b21\n        bucket = [[] for _ in range(n+1)]\n        for val,count in hashmap.items():\n            bucket[count].append(val)\n\n        # removing stuff from the head of the bucket, since it has less count\n        for i in range(len(bucket)):\n            if len(bucket[i]) != 0:\n                for j in range(len(bucket[i])):\n                    k -= i\n                    if k == 0:\n                        return unique - 1\n                    elif k &lt; 0:\n                        return unique\n                    else:\n                        unique -= 1\n</code></pre>","tags":["Array","Hash Table","Greedy","Sorting","Counting","Bucket Sort"]},{"location":"leetcode/15-three-sum/","title":"15 Three Sum","text":"","tags":["Array","Two Pointers","Sorting"]},{"location":"leetcode/15-three-sum/#approach-1-brute-force","title":"Approach 1 Brute Force","text":"<p>\u66b4\u529b\u89e3\u6cd5\u5c31\u662f\u4e09\u5faa\u73af\uff0c\u7136\u540e\u627e\u5230\u6240\u6709\u7684\u7ec4\u5408\uff0c\u7136\u540e\u53bb\u91cd\uff0c\u8fd9\u4e2a\u65b9\u6cd5\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u662fO(n^3)</p>","tags":["Array","Two Pointers","Sorting"]},{"location":"leetcode/15-three-sum/#approach-2-hashset","title":"Approach 2 Hashset","text":"<p>\u5982\u4f55\u5728\u786e\u4fdd\u6211\u4eeccover\u6240\u6709solution\u7684\u524d\u63d0\u4e0b\uff0cspeed up the brute force method\u5462\uff1fA hashset\u53ef\u4ee5\u7528\u7a7a\u95f4\u6362\u65f6\u95f4, \u5177\u4f53\u601d\u8def\u5982\u4e0b: - \u5916\u5faa\u73afpointer i \u4ece0\u5f00\u59cb - \u5185\u5faa\u73afpointer j \u4ecei+1\u5f00\u59cb - \u7b2c\u4e09\u4e2aindex k \u662f\u4eceranging from i to j\u7684\u53cc\u5f00\u533a\u95f4, \u6216\u8005\u8bf4<code>nums[i+1:j]</code>\u8fdb\u884c\u9009\u62e9, \u7531\u4e8e\u6211\u4eec\u7684i,j\u90fd\u5df2\u7ecf\u786e\u8ba4\u4e86\uff0c\u6240\u4ee5\u6211\u4eec\u53ea\u9700\u8981\u627e\u5230\u4e00\u4e2ak\u4f7f\u5f97<code>nums[i]+nums[j]+nums[k] = 0</code>\u5373\u53ef\uff0c\u6211\u4eec\u5728\u50a8\u5b58\u8fd9\u4e2aincremental\u8bb0\u5f55\u7684\u65f6\u5019\uff0c\u53ea\u9700\u8981\u50a8\u5b58deduplicated\u7ed3\u679c\u5373\u53ef, \u6240\u4ee5\u9700\u8981\u4e00\u4e2ahashset\u6765\u50a8\u5b58\u6211\u4eec\u7684\u7ed3\u679c, \u6bcf\u6b21\u5230\u4e0b\u4e00\u4e2ai\u7684\u65f6\u5019\uff0c\u6211\u4eec\u9700\u8981reset\u6211\u4eec\u7684hashset.</p> <p></p> <p>\u4f46\u8fd9\u6837\u5c31\u80fd\u4fdd\u8bc1\u6211\u4eec\u7684solution\u662funique\u7684\u5417\uff1f\u5e76\u4e0d\u662f\uff0c\u6211\u4eec\u76ee\u524d\u5b9a\u4e49\u7684hashset\uff0c\u53ea\u8d1f\u8d23\u5728\u5df2\u7ecf\u77e5\u9053i,j\u7684\u60c5\u51b5\u4e0b\uff0c\u53bb\u91cd\u3002\u867d\u7136i,j\u80fd\u4fdd\u8bc1\u4e0d\u4e00\u6837\uff0c\u4f46\u662fnums[i],nums[j]\u5e76\u4e0d\u80fd\u4fdd\u8bc1\u4e0d\u4e00\u6837, \u6240\u4ee5\u8fd8\u662f\u8981\u8fdb\u884cdeduplication with <code>tuple(sorted([nums[i],nums[j],nums[k]]))</code> as key to the hashset</p> <p>Tip</p> <p>\u53bb\u91cd\u7684\u65f6\u5019\uff0c\u6211\u4eecpass in sorted tuple (1,2,3). \u8fd9\u4e2a\u903b\u8f91\u548canagram\u7684\u65f6\u7528tuple(sorted(str))\u662f\u4e00\u6837\u7684\uff0c\u90fd\u662f\u4e3a\u4e86\u4fdd\u8bc1\u6211\u4eec\u7684key\u662funique\u7684</p>","tags":["Array","Two Pointers","Sorting"]},{"location":"leetcode/15-three-sum/#code-implementation","title":"Code Implementation","text":"<pre><code>class Solution:\n    def threeSum(self, nums: List[int]) -&gt; List[List[int]]:\n        # assuming i &lt; k &lt; j\n        res = set()\n        for i in range(len(nums)):\n            # reset hash\n            hashmap = set()\n            for j in range(i+1,len(nums)):\n                third = -nums[i]-nums[j]\n                if third in hashmap:\n                    res.add(tuple(sorted([third,nums[i],nums[j]])))\n                hashmap.add(nums[j])     \n        return res\n</code></pre>","tags":["Array","Two Pointers","Sorting"]},{"location":"leetcode/15-three-sum/#_1","title":"\u5fae\u4f18\u5316","text":"<p>\u4f46\u8fd9\u4e00\u9898\u8fd8\u6709\u5fae\u4f18\u5316\u7a7a\u95f4.</p> <ul> <li><code>problem 1:</code> outer loop \u53ef\u80fd\u6709\u91cd\u590d\u7684nums[i], \u53ef\u4ee5\u53bb\u91cd</li> <li><code>problem 2:</code> \u6211\u4eec\u6bcf\u8d70\u8fc7\u4e00\u6b21i, \u90fd\u9700\u8981reset hashset</li> </ul> <p>\u6839\u636e\u8fd9\u4e24\u70b9\uff0c\u6211\u4eec\u53ef\u4ee5\u5efa\u7acb\u4e00\u4e2a<code>set()</code> and <code>dict()</code> \u6765\u89e3\u51b3\u8fd9\u4e24\u4e2a\u95ee\u9898. \u4e3a\u4ec0\u4e48\u7528dict? </p> <ul> <li>key\u4e3aunique value for <code>nums[k]</code>, </li> <li>value\u4e3a\u5f53\u524d\u6240\u5728\u7684outer iteration\u7684index, <code>i</code></li> </ul> <p>\u4e3e\u4e2a\u4f8b\u5b50,</p> <p></p> <p>\u8fd9\u4e48\u505a\u7684\u597d\u5904\u662f\uff0c\u4e0d\u9700\u8981\u6bcf\u6b21i\u53d8\u6362\uff0c\u90fdreset hashset, \u73b0\u5728\u53ea\u9700\u8981\u5728dict()\u91cc\uff0c\u968f\u7740i\u7684\u53d8\u5316\uff0c</p> <ul> <li>\u5982\u679cvalue\u5728<code>dict().keys()</code>, \u8986\u76d6\u6389\u4e4b\u524d\u7684iterator\u5373\u53ef.</li> <li>\u5982\u679cvalue\u4e0d\u5728<code>dict().keys()</code>, assign value:iterator as the key:value pair\u5373\u53ef</li> </ul> <p>\u5982\u4e0b\u56fe\u6240\u793a, </p> <p></p>","tags":["Array","Two Pointers","Sorting"]},{"location":"leetcode/15-three-sum/#code-implementation_1","title":"\u4f18\u5316\u540e Code Implementation","text":"<pre><code>class Solution:\n    def threeSum(self, nums: List[int]) -&gt; List[List[int]]:\n        outer_dups = set() # deduplication for nums[k]\n        seen = dict() # deduplication for nums[i]\n        res = set()\n        for i in range(len(nums)):\n            if nums[i] not in outer_dups:\n                outer_dups.add(nums[i])\n                for j in range(i+1,len(nums)):\n                    third = -nums[i]-nums[j]\n                    if third in seen and seen[third] == i:\n                        res.add(tuple(sorted([third,nums[i],nums[j]])))\n                    seen[nums[j]] = i\n        return res\n</code></pre>","tags":["Array","Two Pointers","Sorting"]},{"location":"leetcode/15-three-sum/#approach-2-two-pointer","title":"Approach 2 Two Pointer","text":"<p>\u8fd9\u9898combine\u4e86two sum and two sum II, </p>","tags":["Array","Two Pointers","Sorting"]},{"location":"leetcode/15-three-sum/#reference","title":"Reference","text":"<ul> <li>take u forward, good as always</li> </ul>","tags":["Array","Two Pointers","Sorting"]},{"location":"leetcode/150-evaluate-reverse-polish-notation/","title":"Intuition","text":"<p>The pattern is always two operators follows one operand like this, </p> <pre><code>[\"2\",\"1\",\"+\"]\n</code></pre> <p>You have one input array, but you need to do the calculation from left to right. Popping the first element in an array is O(n), which is advised to avoid. So we can reverse the array to a stack, <code>S1</code>.  Now we just pop from there. </p> <p>Note: One edge case doesn't fit the 2 operator + 1 operand pattern, which is <code>[\"2\"]</code>, so we need to handle this edge case.</p> <p>So we just need an auxillary DS to store the operators, and when we encounter an operand, we pop two operators from the auxillary DS, and do the calculation, then put the result back to the original stack. The auxillary DS is a stack as well, let's call it <code>S2</code>.</p> <p>It's kinda like pouring water from one cup to another cup, and then pour it back.</p> <p></p>"},{"location":"leetcode/150-evaluate-reverse-polish-notation/#example","title":"Example","text":"<pre><code>input: [\"2\",\"1\",\"+\",\"3\",\"*\"]\n</code></pre> <p>Initially, we have <code>s1</code> as reversed and <code>s2</code> as empty stack.</p> <p><pre><code>s1 = [\"*\",\"3\",\"+\",\"1\",\"2\"]\ns2 = []\n</code></pre> Then next two moves, <pre><code>s1 = [\"*\",\"3\",\"+\",]\ns2 = [\"1\",\"2\"]\n</code></pre> We encounter operand, we calculate the <code>temp = 1 + 2 = 3</code>, pop the operand in s1, and put <code>temp</code> back to <code>s1</code></p> <p><pre><code>s1 = [\"*\",\"3\",\"3\"]\ns2 = []\n</code></pre> Then <pre><code>s1 = [\"*\",]\ns2 = [\"3\",\"3\"]\n</code></pre> Finally,  <pre><code>s1 = [\"9\"]\ns2 = []\n</code></pre></p>"},{"location":"leetcode/150-evaluate-reverse-polish-notation/#solution","title":"Solution","text":"<pre><code>class Solution:\n    def evalRPN(self, tokens: List[str]) -&gt; int:\n        # use of two stack, O(n) in time, O(n) in space\n\n        # edge case\n        if len(tokens) == 1:\n            return int(tokens[0])\n\n        # reverse the stack\n        s1 = []\n        while tokens:\n            s1.append(tokens.pop())\n\n        s2 = []\n        operands = (\"+\",\"-\",\"/\",\"*\",)\n\n        while s1:\n            curr = s1[-1]\n            if curr not in operands:\n                # encounter a number\n                s2.append(s1.pop())\n            else:\n                # encounter a operand\n                operator_two = int(s2.pop())\n                operator_one = int(s2.pop())\n                if curr == \"+\":\n                    temp = operator_one + operator_two\n                elif curr == \"-\":\n                    temp = operator_one - operator_two\n                elif curr == \"*\":\n                    temp = operator_one * operator_two\n                else:\n                    # edge case, be careful that in python int/int != int \n                    temp = int(operator_one / operator_two)\n                # remove the operand\n                s1.pop()\n                # then put calculated result back \n                s1.append(temp)\n\n        return s2[0]            \n</code></pre>"},{"location":"leetcode/1512-number-of-good-pairs/","title":"1512-number-of-good-pairs","text":"<pre><code>class Solution:\n    def numIdenticalPairs(self, nums: List[int]) -&gt; int:\n        hashtable = collections.defaultdict(list)\n        res = 0\n        for i, num in enumerate(nums):\n            res += len(hashtable[num])\n            hashtable[num].append(i)\n\n        return res\n</code></pre>","tags":["Array","Hash Table","Math","Counting"]},{"location":"leetcode/153-find-minimum-in-rotated-sorted-array/","title":"153 Find Minimum in Rotated Sorted Array","text":"<p>First thing first, we gotta understand the problem. </p>","tags":["Array","Binary Search"]},{"location":"leetcode/153-find-minimum-in-rotated-sorted-array/#definition-of-rotated-sorted-array","title":"Definition of Rotated Sorted Array","text":"<p>Rotation is a operation that shift the array to the right by 1, if anything go beyond the capacity of the array, it will be put to the start of the array. Kinda like a wrap-around. Let's take <code>nums = [1, 2, 3, 4, 5]</code> for example, </p> <pre><code>rotate 1 time: [5, 1, 2, 3, 4]\nrotate 2 times: [4, 5, 1, 2, 3]\nrotate 3 times: [3, 4, 5, 1, 2]\nrotate 4 times: [2, 3, 4, 5, 1]\nrotate 5 times: [1, 2, 3, 4, 5]\n......\n</code></pre> <p>You can conclude that, </p> <ul> <li>rotate <code>n</code> times wll go back to original where n is the length of the array</li> <li>rotate <code>x</code> time, will shift the array to the right by x, if any element go beyond the capacity of the static array, it will be put to the start of the array</li> </ul>","tags":["Array","Binary Search"]},{"location":"leetcode/153-find-minimum-in-rotated-sorted-array/#intuition","title":"Intuition","text":"<p>This question is asking for the minimum element of the array, which is <code>min(nums)</code>, but we need something with \\(O(\\log n)\\) which is a typical binary search problem.</p> <p>Then we look at the constrains we are given to construct our search condition:</p> <ul> <li><code>nums</code> is a sorted ascending array.</li> <li>it has unique elements.</li> <li>it is rotated <code>1</code> to <code>n</code> times. It means it has to rotate.</li> </ul> <p>Where the minimum element would be at? It would be at the index <code>x</code> where <code>nums[x-1] &gt; nums[x] &lt; nums[x+1]</code>. Sort of a valley. We can use <code>nums = [1,2,3,4,5]</code> to make an example,</p> <ul> <li>rotate <code>1</code> time: [5, 1, 2, 3, 4], 5&gt; 1 &lt; 2</li> <li>rotate <code>2</code> times: [4, 5, 1, 2, 3], 4 &gt; 5 &lt; 1</li> <li>rotate <code>3</code> times: [3, 4, 5, 1, 2], 3 &gt; 4 &lt; 5</li> <li>rotate <code>4</code> times: [2, 3, 4, 5, 1], 5 &gt; 1, we sitting at the end of the array</li> <li>rotate <code>5</code> times: [1, 2, 3, 4, 5], 1 &lt; 2, back to original, sitting at start of the array</li> </ul> <p>We know we gonna have <code>nums[mid]</code>, <code>nums[left]</code> and <code>nums[right]</code>  to construct an inequality as our search condition to update <code>left</code> and <code>right</code> pointers. It can't be <code>nums[mid] &gt; nums[mid+1]</code> since we will be at the risk of <code>mid + 1 &gt;= n</code> and it will be out of bound. Then, the inequality we can use is limited to,</p> <p>Search Condition 1</p> \\[ nums[mid] &lt; nums[right]\\quad and\\quad nums[mid] &gt;= nums[left] \\] <p>or Search Condition 2</p> \\[ nums[mid] &gt;= nums[right]\\quad and\\quad nums[mid] &lt; nums[left] \\] <p>Since we are looking for the minimum element, i.e. the transition element, it has the characteristic of  being smaller than both its left and right neighbors. We go for Search Condition 1.</p> <p>The rest of explanation could be found in the code implementation which is pretty thorough.</p>","tags":["Array","Binary Search"]},{"location":"leetcode/153-find-minimum-in-rotated-sorted-array/#code-implementation","title":"Code Implementation","text":"<pre><code>class Solution:\n    def findMin(self, nums: List[int]) -&gt; int:\n        # - rotate [1,2,3,...,n] and n == len(nums)\n        # - rotate n times wll go back to original\n        # - roatate x time, will shift the array to the right by 1, if anything go beyond\n        # the capacity of the array, it will be put to the start of the array\n\n        # objective: minimum element of this array. index of the minimum element of the array is the\n        # one that rotated x time\n\n        # find a value that\n        # nums[i-1] &lt; nums[i] &lt; nums[i+1]\n\n        n = len(nums)\n        left,right = 0,n-1\n\n        # \u627e\u8f6c\u6298\u70b9\u7684\u6545\u4e8b\n        while left &lt; right:\n            mid = (left + right)//2\n            # if nums[mid] &gt; nums[mid-1] and nums[mid] &lt; nums[i+1]:\n            #     return nums[mid]\n            if nums[mid] &lt; nums[right]:\n                # nums[mid] ... nums[right] must be sorted, \n                # the transition point won't be in this range (mid,right], it is still\n                # possible that mid is the transition point, so we can't be aggressive\n                right = mid\n            else:\n                # nums[mid] &gt;= nums[right]. The transition point must be to the right of mid\n                # there are chances that mid == right, so we can be more aggressive\n                left = mid + 1\n\n        return nums[right]\n</code></pre>","tags":["Array","Binary Search"]},{"location":"leetcode/1542-number-of-subarrays-with-odd-sum/","title":"1524 Number of Sub-arrays With Odd Sum","text":"","tags":["Array","Math","Dynamic Programming","Prefix Sum"]},{"location":"leetcode/1542-number-of-subarrays-with-odd-sum/#approach-1-prefix-sum","title":"Approach 1: Prefix Sum","text":"<p>Thought process is explained in the code comments.</p> <pre><code>class Solution:\n    def numOfSubarrays(self, arr: List[int]) -&gt; int:\n        \"\"\"\n        brute force: \n            find every single subarray O(n^2) * summing it O(n) --&gt; O(n^3), O(1)\n            with pre-compute: O(n^2) --&gt; O(1)\n        10^5 --&gt; O(nlogn) at most but most likely a O(n) O(n) solution\n\n        intuition\n        - we will use prefix sohow\n        - for a subarray [x,y,z,...] for it to have odd sum, we can have\n            - 0 odd then sum is even\n            - 1 odd then sum is odd\n            - 2 odd then sum is even\n            ...\n        it can be generalized such that if we have even number of odd number, then we not good\n        x x x [x x x x]\n            j.       i\n        one edge case\n        [x x x] x x x x\n       j.    i\n        \"\"\"\n        hashtable = {\n            'odd': 0,\n            'even':1,\n        }\n        num_of_odd = 0\n        res = 0\n        for i in range(len(arr)):\n            if arr[i]%2 == 1:\n                num_of_odd += 1\n\n            if num_of_odd %2 == 1:\n                # looking for even\n                res += (hashtable['even'] % (10**9 +7))\n                hashtable['odd'] += 1\n            else:\n                # looking for odd\n                res += (hashtable['odd'] % (10**9 + 7))\n                hashtable['even'] += 1\n\n        return res  % (10**9 + 7)\n</code></pre>","tags":["Array","Math","Dynamic Programming","Prefix Sum"]},{"location":"leetcode/1544-make-the-string-great/","title":"1544 Make The String Great","text":"","tags":["String","Stack"]},{"location":"leetcode/1544-make-the-string-great/#approach-1-stack","title":"Approach 1 Stack","text":"<pre><code>class Solution:\n    def makeGood(self, s: str) -&gt; str:\n        # Use stack to store the visited characters.\n        stack = []\n        def is_bad(a,b):\n            if a != b and (a.upper() == b or a == b.upper()):\n                return True\n            return False\n\n        # Iterate over 's'.\n        for curr_char in list(s):\n            # If the current character make a pair with the last character in the stack,\n\n            if stack and is_bad(curr_char,stack[-1]):\n                stack.pop()\n            else:\n                stack.append(curr_char)\n\n        # Returns the string concatenated by all characters left in the stack.\n        return \"\".join(stack)\n</code></pre> <p>You can improve the code by comparing if the unicode difference between the two characters is 32. This is because the difference between the uppercase and lowercase characters is 32. </p> <p>Tip</p> <p>You can use the <code>ord()</code> function to get the unicode of a character. As for quickly compare whether two character are upper-lower-conjugate, you can use <code>abs(ord(a) - ord(b)) == 32</code>.</p> <pre><code>class Solution:\n    def makeGood(self, s: str) -&gt; str:\n        # Use stack to store the visited characters.\n        stack = []\n\n        # Iterate over 's'.\n        for curr_char in list(s):\n            # If the current character make a pair with the last character in the stack,\n            # remove both of them. Otherwise, we add the current character to stack.\n            if stack and abs(ord(curr_char) - ord(stack[-1])) == 32:\n                stack.pop()\n            else:\n                stack.append(curr_char)\n\n        # Returns the string concatenated by all characters left in the stack.\n        return \"\".join(stack)\n</code></pre>","tags":["String","Stack"]},{"location":"leetcode/1570-dot-product-of-two-sparse-vectors/","title":"1570 Dot Product of Two Sparse Vectors","text":"<p>\u9898\u76ee\u7ed9\u4e86\u4fe9\u5f88\u5927\u7684sparse vector, \u95ee\u600e\u4e48\u6c42dot product\u6bd4\u8f83efficient. \u91cd\u70b9\u5728\u4e8esparse vector, \u8be5\u600e\u4e48\u6837\u50a8\u5b58\u6bd4\u8f83efficient\u7684\u95ee\u9898\uff0c\u6211\u60f3\u5230\u51e0\u4e2a\u65b9\u6cd5,</p> <ul> <li>\u5b58\u6210array, \u4f46\u662f\u8fd9\u6837\u4f1a\u6d6a\u8d39\u7a7a\u95f4</li> <li>\u5b58\u6210hash table</li> <li>\u8054\u60f3\u5230\u4e86skyline storage in FEA. \u4f46\u8fd9\u4e2a\u662ffor sparse matrix with symmetric property. \u4f46\u601d\u8def\u53ef\u4ee5\u501f\u9274.</li> </ul> <p>Follow-Up from Meta</p> <p>What if one of the vectors is sparse and another is very dense? It means \\(L_1\\) is very large and \\(L_2\\) is very small. How can you optimize your solution? \u8fd9\u9898\u8fd8\u6709\u4e00\u4e2a\u59d0\u59b9\u9898\uff0c\u4e5f\u53ef\u80fd\u88ab\u95ee 311 Sparse Matrix Multiplication</p> <p>StrongHire from New York University\u7684\u7b54\u6848\u5f88\u4e0d\u9519. \u6211\u4eec\u5148\u6765\u603b\u7ed3\u4e00\u4e0b\u56db\u79cd\u65b9\u6cd5,</p> Method Time Space Note Array \\(O(m+n)\\) \\(O(m+n)\\) \u4e0d\u7ba1sparse vector,\u5168\u5b58\u4e0b\u6765\uff0c\u53c8\u6162\u53c8\u6d6a\u8d39\u7a7a\u95f4 Hash Set \\(O(min(L_1,L_2))\\) \\(O(L_1+L_2)\\) \u7528hash set\u5b58\u50a8\u975e0\u503c\uff0c\u7f29\u5c0f\u50a8\u5b58\u7a7a\u95f4\u3002\u4f46\u6570\u636e\u91cf\u4e00\u5927\uff0c\u8fd8\u662f\u6709hash collision Two Pointers \\(O(L_1+L_2)\\) \\(O(L_1+L_2)\\) \u6211\u4eec\u600e\u4e48\u65e2\u8981\u53ea\u50a8\u5b58non-zero, \u800c\u4e0d\u7528hashset\u5462? \u727a\u7272\u4e00\u70b9\u65f6\u95f4\uff0c\u7528Array\u50a8\u5b58<code>(index,value)</code> pair, \u7136\u540e\u7528\u53cc\u6307\u9488\u904d\u5386. Binary Search \\(min(L_1,L_2)\\log (max(L_1,L_2))\\) \\(L_1 + L_2\\) \u7531\u4e8e\u4e00\u4e2avector\u5f88\u5927\uff0c\u53e6\u4e00\u4e2a\u5f88\u5c0f\uff0c\u6240\u4ee5\\(\\approx log(max(L_1,L_2))\\) <p>where \\(m\\) and \\(n\\) are the number of elements in the two vectors, and \\(L_1\\) and \\(L_2\\) are the number of non-zero elements in both vectors.</p>","tags":["Array","Hash Table","Design","Two Pointers"]},{"location":"leetcode/1570-dot-product-of-two-sparse-vectors/#approach-1-array","title":"Approach 1: Array","text":"<p>\u6ca1\u5565\u597d\u8bf4\u7684, brute force. O(n) in time (constructing the sparse vector and also dot product), O(n) in space (storing the sparse vector).</p> <pre><code>class SparseVector:\n    def __init__(self, nums: List[int]):\n        self.nums = nums        \n\n    # Return the dotProduct of two sparse vectors\n    def dotProduct(self, vec: 'SparseVector') -&gt; int:\n        res = 0\n        for num1,num2 in zip(self.nums,vec.nums):\n            res += num1*num2\n        return res\n</code></pre>","tags":["Array","Hash Table","Design","Two Pointers"]},{"location":"leetcode/1570-dot-product-of-two-sparse-vectors/#approach-2-hash-set","title":"Approach 2: Hash Set","text":"<p>\u5bf9\u4e8esparse vector, \u6709\u5f88\u591a0\u503c\u662f\u65e0\u610f\u4e49\u7684\uff0c\u6211\u4eec\u53ef\u4ee5\u7528hash set\u6765\u5b58\u50a8\u975e0\u503c\uff0cfor a vector with 1 million values with 900 thousand zeros, \u8fd9\u6837\u53ef\u4ee5\u8282\u770190%\u7684\u7a7a\u95f4. </p> <pre><code>class SparseVector:\n    def __init__(self, nums: List[int]):\n        self.lookup = dict()\n        # kay:value pair as index:value\n        for index,num in enumerate(nums):\n            self.lookup[index] = num\n\n    # Return the dotProduct of two sparse vectors\n    def dotProduct(self, vec: 'SparseVector') -&gt; int:\n        res = 0\n        for key in self.lookup.keys():\n            if key in self.lookup.keys():\n               res += self.lookup[key] * vec.lookup[key]\n        return res\n</code></pre> <p>\u5f53\u7136\uff0c\u4e0a\u8ff0\u8fd8\u6709\u4e00\u4e9b\u4f18\u5316\u7a7a\u95f4\uff0c\u6211\u4eec\u53ef\u4ee5\u904d\u5386\u8f83\u5c0f\u7684hash set, \u8fd9\u6837\u53ef\u4ee5\u51cf\u5c11\u65f6\u95f4\u590d\u6742\u5ea6.</p> <pre><code>class SparseVector:\n    def __init__(self, nums: List[int]):\n        self.lookup = dict()\n        # kay:value pair as index:value\n        for index,num in enumerate(nums):\n            self.lookup[index] = num\n\n    # Return the dotProduct of two sparse vectors\n    def dotProduct(self, vec: 'SparseVector') -&gt; int:\n        # choose the minimum\n        if len(vec.lookup) &lt; len(self.lookup):\n            return vec.dotProduct(self.lookup)\n\n        # traverse\u81ea\u5df1\n        res = 0\n        for key in self.lookup.keys():\n            if key in self.lookup.keys():\n               res += self.lookup[key] * vec.lookup[key]\n        return res\n</code></pre> <p>Tip</p> <p>\u8fd9\u4e2a\u65b9\u6cd5\u4e0d\u591f\u4f18\u79c0\uff0c\u867d\u7136hash set\u89c4\u907f\u4e86zero value\u50a8\u5b58\u7684\u7a7a\u95f4\u6d6a\u8d39\uff0c\u4f46\u662f\u5982\u679cinput size\u592a\u5927\uff0c\u4f60\u4e0d\u53ef\u907f\u514d\u7684\u4f1a\u53d1\u751fhash collision, \u4e00\u822c\u5bf9\u4e8ehash collision, \u6211\u4eec\u6709\u4ee5\u4e0b\u51e0\u4e2a\u624b\u6bb5\uff0c\u8fd9\u65f6\u5019\u6709\u4ee5\u4e0b\u51e0\u4e2asolution:</p> <ul> <li>\u8bbe\u8ba1\u66f4\u597d\u66f4\u5feb, \u66f4\u8d34\u5408input\u7684hash function</li> <li><code>open addressing</code>: \u5982\u679chash function\u540e\uff0c\u53d1\u751f\u4e86collision, \u5c31\u627e\u4e0b\u4e00\u4e2a\u7a7a\u7684slot.</li> <li><code>chaining</code>: \u5982\u679chash function\u540e\uff0c\u53d1\u751f\u4e86collision, \u5c31\u628a\u8fd9\u4e2a\u503c\u653e\u5728\u4e00\u4e2alinked list\u91cc\u9762\uff0c\u5982\u679c\u8981\u5bfb\u627e\u4e00\u4e2a\u6570\uff0c\u5c31deny it. \u5982\u679c\u8fd9\u4e2alinked list\u5927\u5230\u4e0d\u53ef\u5fcd\u53d7, \u5c31\u8f6c\u5316\u4e3a\u7ea2\u9ed1\u6811.</li> </ul> <p>\u8bd5\u60f3\u4e00\u4e0b\uff0cinstead of 1 million data, we have 1 billion vector with 100 million zeros, \u8fd9\u4e2ahash set\u5c31\u4f1a\u53d8\u5f97\u5f88\u5927\uff0c\u8fd9\u4e2a\u65f6\u5019\u5c31\u4f1a\u53d1\u751fhash collision. \u6709\u6ca1\u6709\u6bd4hashset\u66f4\u597d\u7684\u65b9\u6cd5\u5462? \u8fd9\u65f6\u5019\u6211\u4eec\u8be5\u600e\u4e48\u529e?</p> <p>Note</p> <p>load factor: \\(\\alpha = \\frac{n}{m}\\), where \\(n\\) is the number of elements and \\(m\\) is the number of slots. \u662f\u7528\u6765\u8868\u5f81on average, how many elements are in each slot. \u5982\u679c\\(\\alpha\\) is too large, \u5c31\u4f1a\u66f4hash collision. \u4e00\u822c\u8bbe\u8ba1load factor\u662f0.7, \u5047\u8bbe\u6211\u4eec\u6709100\u4e2a\u6570\uff0c\u5c31\u9700\u8981allocate \\(100/0.7\\approx 143\\)\u4e2aslots. Idea is similar to safety factor in engineering design.</p>","tags":["Array","Hash Table","Design","Two Pointers"]},{"location":"leetcode/1570-dot-product-of-two-sparse-vectors/#approach-3-two-pointers","title":"Approach 3: Two Pointers","text":"<p>\u540c\u5411\uff0c\u53cc\u6307\u9488\u5728\u4e24\u4e2aarray\u4e0a\u7528, \u7531\u4e8e\u6211\u4eec\u662flinear scan array\u6765\u6784\u6210\u6211\u4eec\u7684list of pairs, \u6240\u4ee5\u5df2\u7ecf\u662fsorted\u7684\u4e86\uff0c\u6211\u4eec\u6b63\u597d\u53ef\u4ee5\u5229\u7528two pointers\u6765\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898.</p> <pre><code>class SparseVector:\n    def __init__(self, nums: List[int]):\n        self.pairs = [(i,num) for i,num in enumerate(nums) if num != 0]\n\n    # Return the dotProduct of two sparse vectors\n    def dotProduct(self, vec: 'SparseVector') -&gt; int:\n        \"\"\"\n        O(L1 + L2) in time, O(L1+L2) in space, where L1 and L2 are number of non-zeros elements in both vec\n        \"\"\"\n        curr_i_1 = curr_i_2 = 0\n        res = 0\n        while curr_i_1 &lt; len(self.pairs) and curr_i_2 &lt; len(vec.pairs):\n            # equal\n            if self.pairs[curr_i_1][0] == vec.pairs[curr_i_2][0]:\n                res += self.pairs[curr_i_1][1] * vec.pairs[curr_i_2][1]\n                curr_i_1 += 1\n                curr_i_2 += 1\n            elif self.pairs[curr_i_1][0] &lt; vec.pairs[curr_i_2][0]:\n                # &lt; , move the LHS\n                curr_i_1 += 1\n            else:\n                # &gt; , move the RHS\n                curr_i_2 += 1\n        return res\n</code></pre>","tags":["Array","Hash Table","Design","Two Pointers"]},{"location":"leetcode/1570-dot-product-of-two-sparse-vectors/#approach-4-binary-search-meta-follow-up","title":"Approach 4: Binary Search (Meta Follow-Up)","text":"<p>\u9762\u8bd5\u5b98\u95ee\u4f60\uff0c\u5f53\u4f60\u4e24\u4e2avector, \u4e00\u5927\u4e00\u5c0f\uff0c\u4f60\u6709\u4ec0\u4e48\u7b56\u7565\u5417? \u6211\u4eec\u56de\u5230\u6700\u57fa\u672c\u7684\u601d\u8def\uff0c\u4ee5\u7a7a\u95f4\u6362\u65f6\u95f4\uff0c\u6211\u4eec\u53ef\u4ee5\u7528binary search\u6765\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898. </p> <pre><code>from bisect import bisect_left\nclass SparseVector:\n    def __init__(self, nums: List[int]):\n        self.pairs = [(i,num) for i,num in enumerate(nums) if num != 0]\n\n    # Return the dotProduct of two sparse vectors\n    def dotProduct(self, vec: 'SparseVector') -&gt; int:\n        if len(self.pairs) &gt; len(vec.pairs):\n            return vec.dotProduct(self)\n\n        res = 0\n        # linear scan smaller array, binary search in larger array\n        for target_i,target_val in self.pairs:\n            candidate_val = self.binary_search(vec.pairs,target_i)\n            res += target_val * candidate_val\n\n        return res\n\n    def binary_search(self,pairs,target):\n        \"\"\"\n        return the value if exists else 0\n        \"\"\"\n        left,right = 0,len(pairs)-1\n        while left &lt;= right:\n            mid = left + (right - left)//2\n            if pairs[mid][0] == target:\n                # found it\n                return pairs[mid][1]\n            elif pairs[mid][0] &gt; target:\n                # solution space to the left\n                right = mid - 1\n            else:\n                # solution space to the right\n                left = mid + 1\n\n        # not found\n        return 0\n</code></pre>","tags":["Array","Hash Table","Design","Two Pointers"]},{"location":"leetcode/1570-dot-product-of-two-sparse-vectors/#reference","title":"Reference","text":"<ul> <li>hashing, hashing algorithms and hash collision<ul> <li>\u5b66\u5230\u4e86\u4e00\u4e2ahashing function\u7528\u6570\u5b66\u7684\u89e3\u91ca\u89d2\u5ea6. hashing function\u7684\u8f6c\u5316input to a finite signature. \u4f46input size\u662finfinite\u7684\u3002\u628a\u65e0\u9650\u7684\u95ee\u9898\u7528\u6709\u9650\u7684\u63cf\u8ff0\u51fa\u6765\uff0c\u5728\u6570\u636e\u91cf\u5c0f\u7684\u65f6\u5019\uff0c\u8fd9\u4e2a\u95ee\u9898\u662f\u4e0d\u660e\u663e\u7684\uff0c\u4f46\u662f\u5f53\u6570\u636e\u91cf\u5927\u7684\u65f6\u5019\uff0c\u8fd9\u4e2a\u95ee\u9898\u5c31\u4f1a\u663e\u73b0\u51fa\u6765\uff0c\u8fd9\u5c31\u662fhash collision.</li> </ul> </li> </ul>","tags":["Array","Hash Table","Design","Two Pointers"]},{"location":"leetcode/159-longest-substring-with-at-most-two-distinct-characters/","title":"159 Longest Substring with At Most Two Distinct Characters","text":"","tags":["String","Sliding Window","Hash Table"]},{"location":"leetcode/159-longest-substring-with-at-most-two-distinct-characters/#approach-1-sliding-window","title":"Approach 1 Sliding Window","text":"<pre><code>from collections import defaultdict\nclass Solution:\n    def lengthOfLongestSubstringTwoDistinct(self, s: str) -&gt; int:\n        global_max = 0\n        left = 0\n        uniques = defaultdict(int)\n        for right,r_char in enumerate(s):            \n            uniques[r_char] += 1\n            while len(uniques) &gt; 2 and left &lt; right:\n                uniques[s[left]] -= 1\n                if uniques[s[left]] == 0:\n                    del uniques[s[left]]\n                left += 1\n            # if reach here, it's good\n            global_max = max(global_max,right-left+1)\n\n        return global_max\n</code></pre>","tags":["String","Sliding Window","Hash Table"]},{"location":"leetcode/16-3sum-closest/","title":"16 3 Sum Closest","text":""},{"location":"leetcode/16-3sum-closest/#approach-1-brute-force","title":"Approach 1 Brute Force","text":"<p>\u66b4\u529b\u89e3\u5c31\u662fenumerate\u6240\u6709\u7684triplet, \u7136\u540e\u627e\u5230\u79bbtarget\u6700\u8fd1\u7684\u90a3\u4e2atriplet.</p> <pre><code>class Solution:\n    def threeSumClosest(self, nums: List[int], target: int) -&gt; int:\n        # exactly one solution!!\n        # Brute force: \n        # 1. find all arbitary three elements that match the condtion (enumeration)\n        # 2. run through all of them to see which is closest\n\n        n = len(nums)\n        res = []\n        curr = 1e5\n        for i in range(n):\n            for j in range(i):\n                for k in range(j):\n                    candidate = nums[i] + nums[j] + nums[k] - target\n                    if abs(candidate) &lt; abs(curr):\n                        curr = candidate\n        return curr + target\n</code></pre>"},{"location":"leetcode/16-3sum-closest/#approach-2-sorting-two-pointers","title":"Approach 2 Sorting + Two Pointers","text":"<pre><code>class Solution:\n    def threeSumClosest(self, nums: List[int], target: int) -&gt; int:\n        diff = float('inf')\n        nums.sort()\n\n        for i in range(len(nums)):\n            lo,hi = i+1,len(nums)-1\n            while lo &lt; hi:\n                curr_sum = nums[i] + nums[lo] + nums[hi]\n                # maintain the diff\n                if abs(target - curr_sum) &lt; abs(diff):\n                    diff = target - curr_sum\n\n                # \u5224\u65ad\u662f\u5426\u8981\u53d8\u5927\u8fd8\u662f\u53d8\u5c0f\n                if curr_sum == target:\n                    break\n                elif curr_sum &lt; target:\n                    lo += 1\n                else:\n                    hi -= 1\n\n        return target - diff\n</code></pre>"},{"location":"leetcode/160-intersection-of-two-linked-list/","title":"Approach 1: smart two-pointer solution","text":"<p>\u8fd9\u4e2a\u89e3\u6cd5\u5f88\u6f02\u4eae, \u5047\u8bbe\u4fe9linked list A and B, A\u7684\u957f\u5ea6\u4e3am, B\u7684\u957f\u5ea6\u4e3an, \u6211\u4eec\u8bbe\u7f6e\u4fe9\u6307\u9488<code>pointerA</code> and <code>pointer B</code> traverse both linked list, \u5f53\u5176\u4e2d\u4efb\u610f\u4e00\u4e2apointer\u8d70\u5b8c\u90a3\u4e2alinked list\u4e4b\u540e\uff0c\u6211\u4eecloop back to another linked list, \u5047\u8bbelinked list A and B\u76f8\u4ea4\uff0c\u90a3\u4e48\u5f53\u8fd9\u4fe9\u6307\u9488\u76f8\u9047\u7684\u70b9\uff0c\u5fc5\u7136\u662f\u4ea4\u70b9</p> <p></p> <p>\u53ef\u80fd\u6709\u4e9b\u8d39\u89e3\u7684\u8bdd\u770b\u4e0a\u56fe, \u5047\u8bbe\u94fe\u8868A\u957f\u5ea6\u4e3am \u94fe\u8868B\u957f\u5ea6\u4e3an, \u5047\u8bbe\u94fe\u8868A\u4e0e\u94fe\u8868B\u76f8\u4ea4\uff0c\u90a3\u4e48exclusive to \u94fe\u8868A\u7684\u957f\u5ea6\u4e3aa, exclusive to\u94fe\u8868B\u7684\u957f\u5ea6\u4e3ab, \u5171\u4eab\u957f\u5ea6\u4e3ac, \u90a3\u4e48\u4ee5\u4e0b\u7b49\u5f0f\u5fc5\u6ee1\u8db3: $$ \\begin{align} (a+b) + (b+c) &amp;= (b+c) + (a+c)\\ (a+b+c) + c &amp;= (a+b+c) +c \\end{align}  $$</p> <p>\\((a+b+c)\\)\u4e3a: - pointer A\u4ecehead of linked list A\u5f00\u59cb\u8d70\uff0c\u8d70\u5230\u5934\u540e\uff0c\u518d\u4ecelinked list B\u7684\u5f00\u5934\u8d70\uff0c\u518d\u8d70\u5230\u4ea4\u70b9\u7684\u8ddd\u79bb. - pointer B\u4ecehead of linked list B\u5f00\u59cb\u8d70\uff0c\u8d70\u5230\u5934\u540e\uff0c\u518d\u4ecelinked list A\u7684\u5f00\u5934\u8d70\uff0c\u518d\u8d70\u5230\u4ea4\u70b9\u7684\u8ddd\u79bb.</p> <p>\u57fa\u4e8e\u8fd9\u4e2a\u6211\u4eec\u7406\u89e3\uff0c\u6211\u4eec\u5c31\u53ef\u4ee5\u5199\u7b97\u6cd5\u4e86</p>"},{"location":"leetcode/160-intersection-of-two-linked-list/#intuition","title":"Intuition","text":"<p>\u505a\u4e86\u4e00\u5f20gif, \u6765\u5f88\u597d\u7684\u8be0\u91ca\u4e86\u8fd9\u4e2a\u7b97\u6cd5</p> <p></p> <p>Note: in python, <code>None</code> is stored at a specific location. <code>None == None</code>\u662f\u6052\u6210\u7acb\u7684</p>"},{"location":"leetcode/160-intersection-of-two-linked-list/#algorithm","title":"Algorithm:","text":"<ul> <li>set two pointers <code>pA</code> and <code>pB</code> at the start of linked list A and B, respectively</li> <li>while <code>pA != pB</code>, <code>pA</code> and <code>pB</code> traverse down linked A and linked list B, if one of pointer reaches the <code>None</code>, redirect to another linked list (\u8d70\u5b8cA\u7684\u8d70B, \u8d70\u5b8cB\u7684\u8d70A)</li> <li>\u4e09\u79cd\u60c5\u51b5:</li> <li>linked list A and B\u76f8\u4ea4\uff0c\u5728\u7b2c\u4e8c\u5708\u4ea4\u70b9\u76f8\u9047</li> <li>linked list A and B\u4e0d\u76f8\u4ea4\u4e14\u957f\u5ea6\u4e0d\u7b49, \u5728\u7b2c\u4e8c\u5708\u7ec8\u70b9\u76f8\u9047</li> <li>linked list A and B\u4e0d\u76f8\u4ea4\u4e14\u957f\u5ea6\u76f8\u7b49, \u5728\u7b2c\u4e00\u5708\u7ec8\u70b9\u76f8\u9047, \u7531\u4e8e<code>None== None</code> returns true.</li> </ul>"},{"location":"leetcode/160-intersection-of-two-linked-list/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: \\(O(2m+2n)\\approx O(m+n)\\) where m and n are length of linekd list A and B, respectively.\u5982\u679c\u4fe9linked list\u76f8\u4ea4\uff0c\u90a3\u4e48\u9700\u8981traverse\u6bcf\u4e2alinked list\u81f3\u5c11\u4e24\u6b21(a+b+c)\u6b21 to be exact. \u4f46\u5982\u679c\u4fe9\u4e0d\u76f8\u4ea4\uff0c\u4e14\u957f\u5ea6\u4e0d\u7b49\uff0c2m+2n\u6b21. \u4f46\u5982\u679c\u4e0d\u76f8\u4ea4\u4e14\u957f\u5ea6\u76f8\u7b49m+n\u6b21.</li> </ul> <ul> <li>Space complexity: \\(O(1)\\)</li> </ul>"},{"location":"leetcode/160-intersection-of-two-linked-list/#code","title":"Code","text":"<pre><code># Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -&gt; Optional[ListNode]:\n        probeA = headA\n        probeB = headB\n\n        while probeA != probeB:\n            if probeA is None:\n                probeA = headB\n            else:\n                probeA = probeA.next\n\n            if probeB is None:\n                probeB = headA\n            else:\n                probeB = probeB.next\n\n        # if no intersection, both probe points to null\n        # if intersect, both at same place\n        return probeA\n</code></pre>"},{"location":"leetcode/160-intersection-of-two-linked-list/#approach-2-normal-two-pointer-solution","title":"Approach 2: normal two pointer solution","text":"<p>\u5982\u679c\u4e24\u4e2alinked list\u76f8\u4ea4, \u90a3\u628a\u8fd9\u4fe9linekd list, \u5728tail\u4fa7\u5bf9\u9f50\u540e\uff0c\u6240\u6709\u7684\u53ef\u80fd\u6027\u5982\u4e0b\u56fe\u6240\u793a</p> <p></p> <p>\u6211\u4eec\u53ea\u9700\u8981\u6bd4\u8f83\u8f83\u77ed\u7684\u94fe\u8868\u4e2d\u7684\u6bcf\u4e2anode with its corresponding node (\u53eb\u505anode pair), \u8fdb\u884c\u6bd4\u8f83\uff0c\u5c31\u53ef\u4ee5\u83b7\u5f97\u7b54\u6848\u4e86;</p>"},{"location":"leetcode/160-intersection-of-two-linked-list/#algorithm_1","title":"Algorithm","text":"<ul> <li>\u8bbe\u7f6e\u4fe9\u6307\u9488at the start of linked list A and B</li> <li>traverse down both linekd list to find their length m and n, assuming n is the smaller length</li> <li>compare every node within the shorter linked list with length n starting from top with n-m th node from the longer linked list to the end. </li> </ul>"},{"location":"leetcode/160-intersection-of-two-linked-list/#complexity_1","title":"Complexity","text":"<ul> <li>Time complexity: \\(O(m+n)\\), with m and n are length of the two input linked list, respectively</li> </ul> <ul> <li>Space complexity: \\(O(1)\\)</li> </ul>"},{"location":"leetcode/160-intersection-of-two-linked-list/#code_1","title":"Code","text":"<pre><code># Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def getLength(self,head):\n        # return the length of the linked list\n        probe = head\n        count = 0\n\n        while probe:\n            count += 1\n            probe = probe.next\n\n        return count\n\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -&gt; Optional[ListNode]:\n        # two-pointer Solution\n        # step 1: traverse both both linked list and count # of nodes in both\n        # step 2: assuming two linked list has length m and n, and m is the smaller one. compare the shorter linked list n nodes, with the last n nodes of the linked list with length m\n\n        # length of linekd list A and B  \n        m = self.getLength(headA)\n        n = self.getLength(headB)\n\n        # min and max length of the two linked list\n        if m &lt;= n:\n            min_ll,max_ll = m,n\n            short_ll,long_ll = headA, headB\n        else:\n            min_ll,max_ll = n,m\n            short_ll,long_ll = headB, headA\n\n        # set up two pointer, one at the start of shorter linked list, another one max-min away from the start position of the longer linked list\n        probe_short = short_ll\n        probe_long = long_ll\n\n        for i in range(max_ll - min_ll):\n            probe_long = probe_long.next\n\n        while probe_short and probe_long:\n            if probe_short == probe_long:\n                return probe_short\n\n            probe_long = probe_long.next\n            probe_short = probe_short.next\n\n        return None\n</code></pre>"},{"location":"leetcode/160-intersection-of-two-linked-list/#approach-3-hash-solution","title":"Approach 3: Hash solution","text":""},{"location":"leetcode/160-intersection-of-two-linked-list/#intuition_1","title":"Intuition","text":"<p>\u8fd9\u4e5f\u662f\u6211\u505a\u7684\u65f6\u5019\u60f3\u51fa\u6765\u7684\u89e3\u6cd5, \u53ea\u9700\u8981\u628a\u4e00\u4e2alinked list\u4e2d\u6240\u6709node\u5b58\u5165hash, \u7136\u540e\u518dtraverse down another linked list to see whether any node in the key space of the hash</p> <p>Note: in python, <code>set()</code> is a hash with only key space, unlike dictionary. \u529f\u80fd\u4e0a<code>set()</code>\u662f<code>{}</code>\u7684\u5b50\u96c6\uff0c\u4e14<code>set()</code>\u4fdd\u8bc1\u6bcf\u4e2akey\u90fdunique</p>"},{"location":"leetcode/160-intersection-of-two-linked-list/#complexity_2","title":"Complexity","text":"<ul> <li>Time complexity: \\(O(m+n)\\)</li> </ul> <ul> <li>Space complexity: \\(O(m)\\)</li> </ul>"},{"location":"leetcode/160-intersection-of-two-linked-list/#code_2","title":"Code","text":"<pre><code># Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -&gt; Optional[ListNode]:\n        # Hash Solution, time complexity O(m+n), space complexity O(m)\n        # where m and n are the length of headA and headB respevtively.\n\n\n        # create a hashmap to store\n        hashtable = {}\n\n        # two pointer, one for each linked list\n        probeA = headA\n        probeB = headB\n\n        # traverse A and puts the memory address as key input the hash\n        while probeA:\n            hashtable[id(probeA)] = probeA.val        \n            probeA = probeA.next\n\n        # traverse b, check memory address of node in b is in the key space of the hash\n\n        while probeB:\n            if id(probeB) in hashtable.keys():\n                return probeB\n\n            probeB = probeB.next\n\n        return None            \n</code></pre>"},{"location":"leetcode/1609-even-odd-tree/","title":"1609 Even Odd Tree","text":"<p>typical tree BFS with queue, the trick is</p> <ul> <li>maintain\u4e00\u4e2aflag to determine odd or even layer and perform checks on<ul> <li><code>odd layer</code>: strictly decreasing and all even numbers</li> <li><code>even layer</code>: strictly increasing and all odd numbers</li> </ul> </li> </ul> <p>Time complexity</p> <p><code>Time complexity:</code> \\(O(n)\\) where <code>n</code> is the number of nodes in the tree. We need to visit all nodes, plus sort all nodes in every layer.</p> <p><code>Space complexity:</code> In the last layers of a binary tree with height \\(h\\), we have \\(2^h=k\\) and \\(k\\) is the number of nodes in the last layer. In worst case scenario, the binary tree is full, so we have the relationship between the number of nodes \\(n\\) and the height of the tree \\(h\\) as \\(n=2^h-1\\). So \\(k\\approx n\\), and the space complexity is \\(O(n)\\).</p>","tags":["Tree","Breadth-First Search","Binary Tree"]},{"location":"leetcode/1609-even-odd-tree/#approach-1-bfs","title":"Approach 1 BFS","text":"<pre><code># Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isEvenOddTree(self, root: Optional[TreeNode]) -&gt; bool:\n        # 1. BFS, left to right scan with queue\n        # 2. check if odd level increasing order\n        # 3. check if even level decreasing order\n        # at most\n        # lvl 0 : 2**0 = 1\n        # lvl 1 : 2**1 = 2\n        # lvl 2: 2**2 = 4\n\n        level = 0\n        queue = collections.deque([root])\n\n        while queue:\n            array = []\n\n            for _ in range(len(queue)):\n                # in case this lvl is not full                       \n                curr = queue.popleft()\n                array.append(curr.val)\n\n                if curr.left:\n                    queue.append(curr.left)\n\n                if curr.right:\n                    queue.append(curr.right)\n\n            # reverse flag\n            odd = False if level % 2 == 0 else True\n\n            if odd:\n                # we at odd level, strictly decreasing, all even number\n                for i in range(len(array)-1):\n                    if array[i+1] &gt;= array[i] or array[i] % 2 == 1:\n                        return False\n\n                if array[len(array)-1] % 2 == 1: return False\n\n            else:\n                # we at even level, strictly increasing, all odd number\n                for i in range(len(array)-1):\n                    if array[i+1] &lt;= array[i] or array[i] % 2 == 0:\n                        return False\n                if array[len(array)-1] % 2 == 0: return False\n\n            # update the lvl\n            level += 1\n\n        return True\n</code></pre> <p>slight improvement can be made for how to maintain the flag variable by <code>odd = not odd</code> instead of doing extra work to check if the level is odd or even by modulus operation <code>%</code> and maintain a counter.</p> <pre><code># Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isEvenOddTree(self, root: Optional[TreeNode]) -&gt; bool:\n        # 1. BFS, left to right scan with queue\n        # 2. check if odd level increasing order\n        # 3. check if even level decreasing order\n        # at most\n        # lvl 0 : 2**0 = 1\n        # lvl 1 : 2**1 = 2\n        # lvl 2: 2**2 = 4\n\n        odd = False\n        level = 0\n        queue = collections.deque([root])\n\n        while queue:\n            array = []\n\n            for _ in range(len(queue)):\n                # in case this lvl is not full                       \n                curr = queue.popleft()\n                array.append(curr.val)\n\n                if curr.left:\n                    queue.append(curr.left)\n\n                if curr.right:\n                    queue.append(curr.right)\n\n\n            if odd:\n                # we at odd level, strictly decreasing, all even number\n                for i in range(len(array)-1):\n                    if array[i+1] &gt;= array[i] or array[i] % 2 == 1:\n                        return False\n\n                if array[len(array)-1] % 2 == 1: return False\n\n            else:\n                # we at even level, strictly increasing, all odd number\n                for i in range(len(array)-1):\n                    if array[i+1] &lt;= array[i] or array[i] % 2 == 0:\n                        return False\n                if array[len(array)-1] % 2 == 0: return False\n\n            # toggle flag\n            odd = not odd\n\n        return True\n</code></pre>","tags":["Tree","Breadth-First Search","Binary Tree"]},{"location":"leetcode/161-one-edit-distance/","title":"Two pointers","text":"<p>\u6211\u4eec\u53ef\u4ee5\u7528<code>len(s) - len(t)</code>\u4f5c\u4e3a\u5224\u5b9a\u6761\u4ef6\uff0csolution\u5fc5\u7136\u5728\\(|len(s) - len(t)|\\leq1\\) \u4e4b\u95f4\u4ea7\u751f - \\(len(s) == len(t)\\), \u53ea\u505a\u4e00\u6b21<code>replace operation</code> - \\(len(s) - len(t) == 1\\), longer string do one <code>delete operation</code> while shorter string do one <code>insert operation</code></p> <p>\u5177\u4f53\u56fe\u89e3\u5982\u4e0b\u56fe</p> <p></p>"},{"location":"leetcode/161-one-edit-distance/#code","title":"Code","text":"<pre><code>class Solution:\n    def isOneEditDistance(self, s: str, t: str) -&gt; bool:\n        # one edit distance\u5fc5\u987b\u6ee1\u8db3\u4ee5\u4e0b\u51e0\u4e2acases\n        # 1. s == t is true, \u5b8c\u5168\u76f8\u7b49\n        # 2. len(s) == len(t), \u4f46\u6709\u4e14\u4ec5\u6709\u4e00\u4e2a\u5b57\u7b26\u4e0d\u540c\n        # 3. abs(len(s) - len(t)) == 1, \u90a3\u4e48the larger one only has one unnecessary character\n        if len(s) == 0 and len(t)==0: return False\n\n        if abs(len(s) - len(t)) &gt;= 2: return False\n\n        if s == t: return False\n\n        if len(s) == len(t):\n            difference_counter = 0\n            for i in range(len(s)):\n                if s[i] != t[i]:\n                    difference_counter += 1\n\n                if difference_counter &gt;= 2:\n                    return False\n\n        else:\n            # \u53ea\u5269\u4e0b\u957f\u5ea6\u4e3a1\u7684\u4e86\n            if len(s) &gt; len(t):\n                longer = s\n                shorter = t\n            else:\n                longer = t\n                shorter = s\n\n            for i in range(len(shorter)):\n                if longer[i] != shorter[i]:\n                    if shorter[i:] == longer[i+1:]:\n                        return True\n                    else:\n                        return False\n\n        # \u53ea\u5269\u4e0b case 1: remove last char in the longer string like \"abcd\" and \"abcde\"\n        # case2: \u5b8c\u5168\u76f8\u7b49 abcd = abcd\n        return True\n</code></pre>"},{"location":"leetcode/1614-maximum-nesting-depth-of-the-parentheses/","title":"1614 Maximum Nesting Depth of the Parentheses","text":"<p>intuition: </p> <ul> <li>\u8fd9\u9053\u9898\u76ee\u662f\u4e00\u4e2a\u62ec\u53f7\u5339\u914d\u7684\u9898\u76ee\uff0c\u6211\u4eec\u9700\u8981\u627e\u5230\u6700\u5927\u7684\u62ec\u53f7\u5d4c\u5957\u6df1\u5ea6. \u4e00\u770b\u5230\u62ec\u53f7\u5c31\u60f3\u5230stack\u548cvalid parentheses\u8fd9\u4e00\u7c7b\u9898\u76ee.</li> </ul>","tags":["String","Stack"]},{"location":"leetcode/1614-maximum-nesting-depth-of-the-parentheses/#approach-1-stack","title":"Approach 1: Stack","text":"<p>\u7531\u4e8e\u6bcf\u4e00\u4e2aopening parantheses\u90fd\u4f1a\u6709\u4e00\u4e2aclosing parantheses, \u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u7528stack\u7684\u6765\u8bb0\u5f55\u5f53\u524d\u7684\u62ec\u53f7\u6df1\u5ea6\uff0c\u6ca1\u9047\u5230\u4e00\u4e2aopening parantheses, \u6211\u4eec\u5c31\u628a\u6df1\u5ea6\u52a01, \u9047\u5230\u4e00\u4e2aclosing parantheses, \u6211\u4eec\u5c31\u628a\u6df1\u5ea6\u51cf1\u3002</p> <p>\u6709\u4e24\u4e2aedge case\u9700\u8981\u8003\u8651:</p> <ul> <li>\"()\" == 1</li> <li>\"1\" == 0</li> </ul> <pre><code>class Solution:\n    def maxDepth(self, s: str) -&gt; int:\n        \"\"\"\n        () == 1\n        \"\"\"\n        stack = []\n        res = 0\n        for c in s:\n            if c == '(':\n                stack.append(c)\n            elif c == ')':\n                stack.pop()\n\n            res = max(res,len(stack))\n\n        return res\n</code></pre>","tags":["String","Stack"]},{"location":"leetcode/164-maximum-gap/","title":"164 Maximum Gap","text":""},{"location":"leetcode/164-maximum-gap/#approach-1-bucket-sort","title":"Approach 1: Bucket Sort","text":"<p>bucket sort\u7684\u4e24\u4e2a\u5173\u952e\u70b9\uff1a - \u6bcf\u4e2abucket\u7684\u957f\u5ea6? \u5373\u6bcf\u4e2abucket\u7684\u8303\u56f4\u662f\u591a\u5c11\uff1f - \u6709\u591a\u5c11\u4e2abucket\uff1f</p> <p>\u6211\u4eec\u5e0c\u671b\u6bcf\u4e2abucket\u7684\u957f\u5ea6\u76f8\u540c, </p> \\[ \\begin{equation} \\text{bucket\\_length} = \\max(1,\\lfloor{{\\max(nums) - \\min(nums)} \\over {len(nums) - 1}}\\rfloor) \\tag{1} \\end{equation} \\] <p>\u786e\u5b9abucket\u7684\u6570\u91cf</p> <p>$$ \\begin{align} \\text{num_of_buckets} &amp;= \\lfloor{{\\max(nums) - \\min(nums)} \\over {\\text{bucket_length}}}\\rfloor + 1 \\ &amp;= \\lceil{{\\max(nums) - \\min(nums)} \\over {\\text{bucket_length}}}\\rceil </p> <p>\\tag{2} \\end{align} $$</p> <p>\u5982\u679c\u786e\u5b9a\u54ea\u4e2aelement\u5c5e\u4e8e\u54ea\u4e2abucket, \u53ef\u4ee5\u7528\u4e0b\u9762\u7684\u516c\u5f0f</p> \\[  {{nums[i] - \\min(nums)} \\over {\\text{bucket\\_length}}}\\tag3 \\]"},{"location":"leetcode/164-maximum-gap/#references","title":"References","text":"<ul> <li>Hao Kun Yun on CN LC</li> </ul>"},{"location":"leetcode/1642-furthest-building-you-can-reach/","title":"1642 Furthest Building You Can Reach","text":"","tags":["Array","Greedy","Heap (Priority Queue)"]},{"location":"leetcode/1642-furthest-building-you-can-reach/#_1","title":"\u9898\u76ee\u63cf\u8ff0","text":"<p>You are given an integer array <code>heights</code> representing the heights of buildings, some <code>bricks</code>, and some <code>ladders</code>. You start your journey from building <code>0</code> and move to the next building by possibly using bricks or ladders.</p> <p>While moving from building <code>i</code> to building <code>i+1</code> (<code>0-indexed</code>), - If the current building's height is greater than or equal to the next building's height, you do not need a ladder or bricks. - If the current building's height is less than the next building's height, you can either use one ladder or <code>(h[i+1] - h[i])</code> bricks.</p>","tags":["Array","Greedy","Heap (Priority Queue)"]},{"location":"leetcode/1642-furthest-building-you-can-reach/#approach-1-heap","title":"Approach 1 Heap","text":"<p>\u8fd9\u4e2a\u95ee\u9898\u7684\u91cd\u70b9\u5728\u4e8e\uff0c\u597d\u521a\u8981\u7528\u5728\u5200\u5203\u4e0a\uff0c\u5373\u5728\u6700\u9700\u8981\u7684\u65f6\u5019\u4f7f\u7528ladder\uff0c\u800c\u4e0d\u662f\u5728bricks. \u903b\u8f91\u5c31\u662f\uff0c\u5982\u679c\u4f60\u80fd\u628a\u76ee\u524d\u9047\u5230\u7684\u6700\u9ad8\u7684diff, \u90fd\u7528ladder\u89e3\u51b3\uff0c\u90a3\u4e48\u5269\u4e0b\u7684diff\u5c31\u7528bricks\u89e3\u51b3\u3002\u8fd9\u6837\u7684\u8bdd\uff0c\u5c31\u4e00\u5b9a\u80fd\u4fdd\u8bc1\u5230\u6700\u8fdc\u3002\u90a3\u4e48\u5982\u4f55\u6c42\u4f60\u76ee\u524d\u4e3a\u6b62\u9047\u5230\u7684\u6700\u9ad8\u7684diff\u5462\uff1f\u8fd9\u5c31\u662fheap\u7684\u4f5c\u7528\u4e86\u3002</p> <p>Note</p> <p>python's built-in <code>heapq</code> is an implementation of min-heap. If you want to use max-heap, a hacky way, you need to multiply the value by -1. Some common operations are: <code>heapq.heappush(heap,val)</code>, <code>heapq.heappop(heap)</code> and heapify <code>heapq.heapify(heap)</code> that turns a list into a heap.</p> <p>\u5728\u4f60traverse <code>heights</code>\u7684\u65f6\u5019\uff0c\u53ea\u8981\u8fd8\u6709\u7816\u5934\uff0c\u4f60\u90fd\u5047\u8bbe\u5148\u7528\u7816\u5934\uff0c\u5982\u679c\u8fc7\u4e86\uff0c\u5c31\u628adiff\u653e\u5230heap\u91cc\u9762\u3002\u5982\u679c\u7816\u5934\u4e0d\u591f\u4e86\uff0c\u5c31\u7528ladder\uff0c\u540c\u65f6\u628a\u76ee\u524d\u4e3a\u6b62\u7528\u8fc7\u7684\u6240\u6709\u7816\u5934\u7684\uff0c\u7528\u8fc7\u6700\u591a\u7684\u4e00\u6b21\u7816\u5934\uff0c\u4eceheap\u91cc\u5f39\u51fa\u6765\uff0c\u52a0\u56de\u6240\u62e5\u6709\u7684\u7816\u5934\u4e4b\u4e2d. \u8fd9\u6837\u5c31\u80fd\u4fdd\u8bc1\u4f60\u7528\u7684\u7816\u5934\u6700\u5c11\uff0cladder\u6700\u591a.</p> <p>\u903b\u8f91flowchart\u5982\u4e0b, </p> <p></p> <pre><code>class Solution:\n    def furthestBuilding(self, heights: List[int], bricks: int, ladders: int) -&gt; int:\n        heap = []\n\n        for i in range(len(heights)-1):\n            diff = heights[i+1] - heights[i]\n            # \u4e0d\u9700\u8981\u7528\u7816\u5934\n            if diff &lt;= 0:\n                continue\n\n            # \u5047\u8bbe\u7528\u4e86\u7816\u5934\u6765\u722c,and also save the diff we used into a max heap \n            bricks -= diff\n            heapq.heappush(heap,-diff)\n\n            if bricks &lt; 0:\n                if ladders == 0:\n                    # \u5f39\u5c3d\u7cae\u7edd\n                    return i\n\n                ladders -= 1\n                bricks += -heapq.heappop(heap)\n\n        # if reach here, we go through them all\n        return len(heights)-1\n</code></pre>","tags":["Array","Greedy","Heap (Priority Queue)"]},{"location":"leetcode/165-compare-version-numbers/","title":"165 Compare Version Numbers","text":"","tags":["Two Pointers","String"]},{"location":"leetcode/165-compare-version-numbers/#approach-1-three-pass-solution","title":"Approach 1: Three pass solution","text":"<p>\u76f4\u63a5\u60f3\u5230\u7684\u89e3, <code>str.split('.')</code> \u7136\u540e\u6bd4\u8f83\u6bcf\u4e2a\u6570\u5b57, linear scan\u4e86\u4e09\u6b21</p> <ul> <li>version1 scan 1\u6b21 costs O(m)</li> <li>version2 scan 1\u6b21 costs O(n)</li> <li>compare 1\u6b21 costs O(max(m,n))</li> </ul> <p>Note</p> <p>\\(O(max(n,m))\\) in time, \\(O(m+n)\\) in space</p> <pre><code>class Solution:\n    def compareVersion(self, version1: str, version2: str) -&gt; int:\n        one = version1.split('.')\n        two = version2.split('.')\n\n\n        for i in range(max(len(one),len(two))):\n            left = 0 if i &gt;= len(one) else int(one[i])\n            right = 0 if i &gt;= len(two) else int(two[i])\n\n            if left &gt; right:\n                return 1\n\n            if left &lt; right:\n                return -1\n\n        return 0\n</code></pre>","tags":["Two Pointers","String"]},{"location":"leetcode/1669-merge-in-between-linked-lists/","title":"1669 Merge in Between Linked Lists","text":"","tags":["Linked List"]},{"location":"leetcode/1669-merge-in-between-linked-lists/#approach-1","title":"Approach 1","text":"<p>Nothing fancy, just some traversal and pointer manipulation.</p> <ul> <li>Initialize two dummy header nodes</li> <li>Initialize <code>curr</code> and <code>prev</code> pointers for both list1 and list2</li> <li>Advancing both <code>prev</code> and <code>curr</code> in <code>list1</code>. Traverse such that <code>prev</code> is at the node before <code>a</code> and <code>curr</code> is at the node <code>a</code></li> <li>Advancing only <code>curr</code> in <code>list1</code> it's at the next of node of b. If <code>b == 4</code>, <code>curr</code> is at the node 5</li> <li>Advancing <code>prev</code> and <code>curr</code> in <code>list2</code> until <code>curr</code> is at the end of list2</li> <li>connection time!!</li> </ul> <pre><code># Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def mergeInBetween(self, list1: ListNode, a: int, b: int, list2: ListNode) -&gt; ListNode:\n        dummy1,dummy2 = ListNode(0,list1),ListNode(0,list2)\n        curr1,curr2 = list1,list2\n        prev1,prev2 = dummy1,dummy2\n\n        counter = 0\n        while counter &lt; a and curr1:\n            curr1 = curr1.next\n            prev1 = prev1.next\n            counter += 1\n\n        # when we got here\n        while counter &lt;= b:\n            curr1 = curr1.next\n            counter += 1\n\n        while curr2:\n            prev2 = prev2.next\n            curr2 = curr2.next\n\n        # connect\n        prev1.next = list2\n        prev2.next = curr1\n\n        return dummy1.next\n</code></pre>","tags":["Linked List"]},{"location":"leetcode/167-two-sum-II-input-array-is-sorted/","title":"167 Two Sum II - Input Array Is Sorted","text":"<p>\u8fd9\u4e00\u9898\u4e0b\u610f\u8bc6\u7684\u53cd\u5e94\uff0c\u662f\u7528binary search\u505a\uff0c\u4f46\u5b9e\u9645\u4e0a\u7528two pointer\u7684\u65b9\u6cd5\u66f4\u52a0\u7075\u6d3b\u3002</p>","tags":["Two Pointers","Array","Binary Search"]},{"location":"leetcode/167-two-sum-II-input-array-is-sorted/#approach-1-two-pointers","title":"Approach 1 Two Pointers","text":"<pre><code>class Solution:\n    def twoSum(self, numbers: List[int], target: int) -&gt; List[int]:\n        # constrains: O(1) in space\n        # if curr &lt; target, left++\n        # if curr &gt; target, right--\n        left,right = 0,len(numbers) - 1\n\n        while left &lt; right:\n            curr = numbers[left] + numbers[right]\n            if curr == target:\n                return [left + 1,right + 1]\n            elif curr &lt; target:\n                left += 1\n            else:\n                right -= 1\n</code></pre>","tags":["Two Pointers","Array","Binary Search"]},{"location":"leetcode/1685-sum-of-absolute-differences-in-a-sorted-array/","title":"1685 Sum of Absolute Differences in a Sorted Array","text":"","tags":["Array","Math","Prefix Sum"]},{"location":"leetcode/1685-sum-of-absolute-differences-in-a-sorted-array/#approach-1-math","title":"Approach 1 Math","text":"<p>when we are doing the sum of absolute difference, we need to flip sign if the value is greater than the curr value. For example, for <code>[2,3,5]</code>, we have the following pattern and generalization <pre><code>for [2,3,5], total_sum = 2 + 3 + 5 = 10, n = 3\nresult[0] = (+2 -2 -2) + (-2 +3 + 5) = 4     \nresult[1] = (+3 +3 -3) + (-2 -3 + 5) = 3\nresult[2] = (+5 +5 +5) + (-2 -3 -5) = 5\n...\nresult[i] = LHS[i] + RHS[i]\nwhere\nLHS[i] = (i+1) * nums[i] + (n-(i+1)) * (-1) * nums[i]\nand\nRHS[0] = total_sum - 2 * nums[0]\nRHS[1] = RHS[0] - 2*nums[1]\nRHS[2] = RHS[1] - 2*nums[2]\n...\n...\n</code></pre></p> <p>then we can generalize it to</p> \\[ LHS\\left[i\\right] = (i+1)*nums\\left[i\\right] - (n-i-1)*nums\\left[i\\right] \\quad 0 \\le i &lt; n \\] <p>where \\(n\\) is the length of the array <code>nums</code>, </p> \\[ RHS\\left[i\\right] = \\begin{cases} sum(nums) - 2*nums \\left[i \\right] \\quad i ==0\\\\ RHS\\left[i-1\\right] - 2*nums\\left[i \\right] \\quad 1 \\le i &lt; n\\\\ \\end{cases} \\] <p>so the resultant array would be <pre><code>[LHS[i] + RHS[i] for i in range(len(nums))]\n</code></pre></p>","tags":["Array","Math","Prefix Sum"]},{"location":"leetcode/1685-sum-of-absolute-differences-in-a-sorted-array/#code-implementation","title":"Code Implementation","text":"<pre><code>class Solution:\n    def getSumAbsoluteDifferences(self, nums: List[int]) -&gt; List[int]:\n        \"\"\"\n        brute force:\n        - run every adjacency pair\n        trick:\n        for [2,3,5], total_sum = 2 + 3 + 5 = 10, n = 3\n        result[0] = (+2 -2 -2) + (-2 +3 + 5) = 4     \n        result[1] = (+3 +3 -3) + (-2 -3 + 5) = 3\n        result[2] = (+5 +5 +5) + (-2 -3 -5) = 5\n        ...\n        result[i] = LHS[i] + RHS[i]\n\n        LHS[i] = (i+1)*nums[i] + (n-(i+1)) * -1 * nums[i]\n\n        RHS[0] = total_sum - 2 * nums[0]\n        RHS[1] = RHS[0] - 2 * nums[1]\n        RHS[1] = RHS[1] - 2 * nums[2]\n        \"\"\"\n        prev_sum = sum(nums)\n        n = len(nums)\n        res = [None for _ in range(n)]\n        for i,num in enumerate(nums):\n            lhs = (i+1) * num - (n-i-1) * num\n            rhs = prev_sum - 2*num\n            res[i] = lhs + rhs\n            # update\n            prev_sum = rhs\n        return res\n</code></pre>","tags":["Array","Math","Prefix Sum"]},{"location":"leetcode/169-majority-element/","title":"169 Majority Element","text":"<p>\u91cd\u70b9\u662fapproach 2 Boyer-Moore Voting Algorithm\uff0c\u5b66\u4e60\u5b83throw away prefix\u7684\u601d\u60f3. \u4f46\u5c40\u9650\u6027\u8fd8\u662f\u9700\u8981majority element\u5b58\u5728\u4e8e\u6570\u7ec4\u4e2d\uff0c\u6240\u4ee5\u8bb0\u4f4f\u7279\u4f8b\u4ef7\u503c\u5e76\u4e0d\u5927. </p>","tags":["Array","Hash Table","Divide and Conquer","Sorting","Counting"]},{"location":"leetcode/169-majority-element/#approach-1-hash-solution","title":"Approach 1 Hash Solution","text":"<p>Note</p> <ul> <li>Time complexity: \\(O(n)\\)</li> <li>Space complexity: \\(O(n)\\)</li> </ul> <pre><code>from collections import defaultdict\nclass Solution:\n    def majorityElement(self, nums: List[int]) -&gt; int:\n        hashmap = defaultdict(int)\n        for num in nums:\n            hashmap[num] += 1\n            if hashmap[num] &gt; math.floor(len(nums)/2):\n                return num\n</code></pre>","tags":["Array","Hash Table","Divide and Conquer","Sorting","Counting"]},{"location":"leetcode/169-majority-element/#approach-2-boyer-moore-voting-algorithm","title":"Approach 2 Boyer-Moore Voting Algorithm","text":"<p>Boyer and Moore\u8fd9\u4fe9\u4eba\u53d1\u8fc7\u5f88\u591a\u7b97\u6cd5\u6587\u7ae0\uff0c\u8fd9\u7bc7\u6587\u7ae0\u4e13\u95e8\u8ba1\u7b97\u6570\u7ec4\u79cd\u7684majority element \u662f\u54ea\u4e2a. </p> <p>Warning</p> <p>majority element\u662f\u6307\u51fa\u73b0\u6b21\u6570\u8d85\u8fc7\u4e00\u534a\u7684\u5143\u7d20. \u8fd9\u4e2a\u7b97\u6cd5\u7684assumption\u662f\u4e00\u5b9a\u6709majority element\u5b58\u5728\u4e8e\u8fd9\u4e2aarray.</p> <p>\u56e0\u4e3aprefix\u4e0d\u5f71\u54cdsuffix\u5bf9\u4e8emajority element\u7684\u7ed3\u8bba. \u5982\u679c\u5b9a\u4e49prefix\u548csuffix\u7684\u5212\u5206\u70b9\u4e3a\uff0ccounter\u7b2c\u4e8c\u6b21\u4e3a0. \u90a3\u4e48\u53ea\u8981\u4f60\u7684candidate\u5728suffix\u4e2d\u51fa\u73b0\u7684\u6b21\u6570\u8d85\u8fc7\u4e00\u534a\uff0c\u90a3\u4e48\u5b83\u5c31\u662fsuffix\u7684majority element.</p> <p>\u90a3\u6211\u4eec\u73b0\u5728\u6709\u4e86\u6761\u4ef61, \u6211\u4eec\u53c8\u6709assumption\u4f5c\u4e3a\u6761\u4ef62, \u90a3\u4e48</p> <ul> <li><code>\u6761\u4ef61</code>:\u67d0\u4e2a\u6570\u5728suffix\u4e2d\u51fa\u73b0\u7684\u6b21\u6570\u8d85\u8fc7\u4e00\u534a\uff0c\u90a3\u4e48\u5b83\u5c31\u662fsuffix\u7684majority element.</li> <li><code>\u6761\u4ef62</code>: \u8fd9\u4e2a\u6570\u7ec4\u5fc5\u7136\u5b58\u5728majority element\u51fa\u73b0\u5728\u8fd9\u4e2a\u6570\u7ec4\u4e2d.</li> </ul> <p><code>\u6761\u4ef62</code>\u8fd9\u4e2a\u6570\u7ec4\u5fc5\u7136\u5b58\u5728majority element \\(i\\) &lt;--\u7b49\u4ef7\u4e8e--&gt; Majority element \\(i\\) \u5fc5\u7136\u4e5f\u662f\u4ee5<code>counter = 0</code>\u4e3aseparator\u7684suffix\u548cprefix\u7684majority element.</p> <p>\u90a3\u4e48\u6839\u636e<code>\u6761\u4ef61</code>, \u6211\u4eec\u77e5\u9053 \\(i\\) \u662fsuffix\u7684majority element, \u518d\u6839\u636e<code>\u6761\u4ef62</code>\u7684\u7b49\u4ef7\u6761\u4ef6, \u6211\u4eec\u6025\u9700\u4e00\u4e2acandidate\u540c\u65f6\u662fsuffix\u548cprefix\u7684majority element. \u90a3\u4e48\u65e2\u7136\\(i\\)\u662fsuffix\u7684majority element, \u5b83\u4e5f\u5fc5\u7136\u662fprefix\u7684majority element.</p> <p>Note</p> <ul> <li>Time complexity: \\(O(n)\\)</li> <li>Space complexity: \\(O(1)\\)</li> </ul>","tags":["Array","Hash Table","Divide and Conquer","Sorting","Counting"]},{"location":"leetcode/169-majority-element/#code-implementation","title":"Code Implementation","text":"<pre><code>class Solution:\n    def majorityElement(self, nums: List[int]) -&gt; int:\n        counter = 0\n        candidate = None\n        for num in nums:\n            if counter == 0:\n                candidate = num\n\n            counter += 1 if num == candidate else -1\n        return candidate\n</code></pre>","tags":["Array","Hash Table","Divide and Conquer","Sorting","Counting"]},{"location":"leetcode/169-majority-element/#reference","title":"Reference","text":"<ul> <li>Moore-Boyer Voting Algorithm original paper</li> </ul>","tags":["Array","Hash Table","Divide and Conquer","Sorting","Counting"]},{"location":"leetcode/1700-number-of-students-unable-to-eat-lunch/","title":"1700 Number of Students Unable to Eat Lunch","text":"<p>\u6709\u4e24\u79cd\u5b66\u751f\uff0c0 or 1, \u5403\u4e00\u4e2astack of sandwiches, 0\u4ee3\u8868type 0\u5b66\u751f\u7231\u5403\uff0c1\u4ee3\u8868type 1\u5b66\u751f\u7231\u5403. \u5b66\u751f\u7684\u6570\u91cf\u548c\u4e09\u660e\u6cbb\u6570\u91cf\u4e00\u81f4\uff0c\u53ea\u6709\u9876\u90e8\u7684sandwich\u53ef\u4ee5\u88ab\u62ff\u8d70\uff0c\u5982\u679c\u5b66\u751f\u559c\u6b22\u8fd9\u4e2asandwich\uff0c\u90a3\u4e48\u5c31\u53ef\u4ee5\u62ff\u8d70\uff0c\u5426\u5219\u5c31\u4e0d\u53ef\u4ee5\u62ff\u8d70\uff0c\u95ee\u6709\u591a\u5c11\u5b66\u751f\u65e0\u6cd5\u5403\u5230sandwich. </p>","tags":["Array","Stack","Queue","Simulation"]},{"location":"leetcode/1700-number-of-students-unable-to-eat-lunch/#approach-1-counter","title":"Approach 1 Counter","text":"<p>\u7531\u4e8e\u5b66\u751f\u53ea\u80fd\u5403\u9876\u90e8\u7684sandwich, \u90a3\u4e48\u5f53\u6709\u4e00\u65b9\u5b66\u751f\u90fd\u62ff\u5230\u4e86\u81ea\u5df1\u559c\u6b22\u7684sandwich\uff0c\u6bd4\u5982type A. \u4e14\u6b63\u597d\u5361\u5728\u4e86type A\u7684sandwich\u4e0a\uff0c\u90a3\u4e48\u5269\u4e0b\u7684type B\u5b66\u751f\u5c31\u65e0\u6cd5\u5403\u5230\u4ed6\u4eec\u7231\u5403\u7684type B sandwich\u4e86, \u6c38\u8fdc\u5361\u5728\u4e86\u4e0b\u9762. </p> <p>\u4e3e\u4e2a\u4f8b\u5b50 <pre><code>students = [1,1,1,1]\nsandwiches = [0,1,0,1]\n</code></pre> \u90a3\u4fe9type 1\u5b66\u751f\u5c31\u6c38\u8fdc\u5361\u5728\u4e86type 0 sandwich\u4e0a\u4e86.</p> <p>\u7b97\u6cd5\u5982\u4e0b:</p> <ul> <li>\u7edf\u8ba1\u5b66\u751f\u7684\u6570\u91cf</li> <li>one pass scan. Instead of moving students, we can move sandwiches. \u53ea\u8981\u8be5\u7c7b\u5b66\u751f\u8fd8\u6709\uff0c\u5c31\u53ef\u4ee5\u7ee7\u7eed\u79fb\u52a8sandwiches</li> </ul>","tags":["Array","Stack","Queue","Simulation"]},{"location":"leetcode/1700-number-of-students-unable-to-eat-lunch/#code-implementation","title":"Code Implementation","text":"<pre><code>from collections import Counter\nclass Solution:\n    def countStudents(self, students: List[int], sandwiches: List[int]) -&gt; int:\n        \"\"\"\n        dry run:\n        students = [1,1,0,0]\n        counter = {\n            1:2,\n            0:2\n        }\n        Move students is same as moving sandwiches\n        \"\"\"\n        counter = Counter(students) \n        n,k = len(students),0\n\n        # traversing the sandwiches, \u53ea\u8981\u8fd8\u6709\u5b66\u751f\n        while k &lt; n and counter[sandwiches[k]]:\n            # found a match!\n            counter[sandwiches[k]] -= 1\n            k += 1\n        return n - k\n</code></pre> <p>A neater solution with for loop.</p> <pre><code>from collections import Counter\nclass Solution:\n    def countStudents(self, students: List[int], sandwiches: List[int]) -&gt; int:\n        counter = Counter(students) \n        res = len(students)\n\n        for s in sandwiches:\n            if counter[s] &gt; 0:\n                res -= 1\n                counter[s] -= 1\n            else:\n                # whoops, time to stop\n                break\n\n        return res\n</code></pre>","tags":["Array","Stack","Queue","Simulation"]},{"location":"leetcode/1700-number-of-students-unable-to-eat-lunch/#reference","title":"Reference","text":"<ul> <li>lee</li> <li>neetcode</li> </ul>","tags":["Array","Stack","Queue","Simulation"]},{"location":"leetcode/1710-maximum-units-on-a-truck/","title":"1710 Maximum Units on a Truck","text":"<p>\u8d2a\u5fc3 + sorting\u7684\u5f15\u5165greedy\u7684\u95ee\u9898.</p>","tags":["Array","Greedy","Sorting"]},{"location":"leetcode/1710-maximum-units-on-a-truck/#approach-1-sort-greedy","title":"Approach 1: Sort + Greedy","text":"<pre><code>class Solution:\n    def maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -&gt; int:\n        boxTypes.sort(key=lambda x:x[1],reverse=True)\n\n        total = 0\n        num_of_boxes = 0\n\n        for boxes,units in boxTypes:\n            if boxes + num_of_boxes &gt; truckSize:\n                remaining_space = truckSize - num_of_boxes\n                total += remaining_space * units\n                break\n            # we can add it!\n            total += boxes * units\n            num_of_boxes += boxes\n\n        return total\n</code></pre>","tags":["Array","Greedy","Sorting"]},{"location":"leetcode/1750-minimum-length-of-string-after-deleting-similar-ends/","title":"1750 Minumum Length of String After Deleting Similar Ends","text":"","tags":["Two Pointers","String"]},{"location":"leetcode/1750-minimum-length-of-string-after-deleting-similar-ends/#approach-1-two-pointers","title":"Approach 1: Two Pointers","text":"<p>If you understand what the question is asking, you are half way there. The string <code>s</code> consists only of <code>a</code>, <code>b</code> and <code>c</code>. You can perform the following operations,</p> <ul> <li>delete a non-empty prefix of <code>s</code> with the same characters </li> <li>delete a non-empty suffix of <code>s</code> with the same characters. But the characters you are deleting must be the same as the prefix.</li> <li>the prefix and suffix don't intersect</li> </ul> <p>In this case, we having following scenarios, </p> <pre><code># 1. with only 1 char left in the middle\n\"aba\" --&gt; \"b\"\n\n# 2. with more than 2 char left in the middle but cancelable\n\"aabbaa\" --&gt; \"bb\" --&gt; \"\"\n\n# 3. with more than 2 char left in the middle but not cancelable\n\"aabcaa\" --&gt; \"bc\"\n</code></pre> <p>Also we could have edge case like <code>s = \"c\"</code>. Based on those information, i have came up with the following solution,</p> <pre><code>class Solution:\n    def minimumLength(self, s: str) -&gt; int:\n        # edge case\n        if len(s) == 1:\n            return 1\n\n        # O(n) or O(nlogn) at worst\n        left,right = 0,len(s)-1\n\n        while left &lt; right:\n            # if not the same, we quit\n            if s[left] != s[right]:\n                break\n            # base case like \"cbc\"\n            if right - left == 2:\n                return 1\n\n            # if we get here, 1st and last char will be the same\n            curr = s[left]\n            while curr == s[left] and right &gt; left:\n                left += 1\n\n            while curr == s[right] and right &gt; left:\n                right -= 1\n\n        if left == right:        \n            # empty the whole string\n            return 0\n        else:\n            # have some substring left\n            return right - left + 1\n</code></pre> <p>But now i look at it, i found out there are many edge cases and boundary shenanigans to work with. We can create a much generalized solution according to editorial solution,</p> <pre><code>class Solution:\n    def minimumLength(self, s: str) -&gt; int:\n        left = 0\n        right = len(s) - 1\n\n        # Delete similar ends until the ends differ or they meet in the middle\n        while left &lt; right and s[left] == s[right]:\n            curr = s[left]\n\n            # Delete consecutive occurrences of c from prefix\n            while left &lt;= right and s[left] == curr:\n                left += 1\n\n            # Delete consecutive occurrences of c from suffix\n            while right &gt; left and s[right] == curr:\n                right -= 1\n\n        # Return the number of remaining characters\n        return right - left + 1\n</code></pre> s comment analysis <code>\"c\"</code> pass it doesn't get into the while loop <code>\"aba\"</code> pass left points to <code>b</code>, right points to <code>b</code> as well <code>\"aabbaa\"</code> pass left points to the <code>a</code> in <code>bba</code>, right points to <code>b</code> in the middle <code>bba</code>. In this case, <code>left</code> always go past <code>right</code> by 1 <code>\"aabcaa\"</code> pass left points to <code>b</code> and right points to <code>c</code>. This is the most general case since it expands to every <code>aabxxxxxxcaa</code> cases <p>\u6bd4\u8f83\u96be\u7684\u4e00\u70b9\u662f\uff0c\u600e\u4e48\u5728interview setting\u76f8\u5904\u8fd9\u4e48\u6f02\u4eae\u7684\u8fb9\u754c\u5904\u7406\u65b9\u5f0f. \u7279\u522b\u662fleft=right+1 (left\u8d70\u5230right\u53f3\u8fb9\u4e86)\u7684\u8fb9\u754c\u8df3\u51fa\u683c\u5f0f, \u628a\u4e24\u4e2acase\u7edf\u4e00\u4e86. \u5176\u5b9e\u8fd9\u548cbinary search\u7684\u8fb9\u754c\u6761\u4ef6\u90a3\u91cc\u5f88\u50cf\uff0c\u641e\u660e\u767d\u4ec0\u4e48\u6761\u4ef6\u8df3\u51fa.</p>","tags":["Two Pointers","String"]},{"location":"leetcode/1762-buildings-with-an-ocean-view/","title":"1762 Buildings With an Ocean View","text":"","tags":["Arraty","Stack","Monotonic Stack"]},{"location":"leetcode/1762-buildings-with-an-ocean-view/#approach-1-monotonic-stack","title":"Approach 1 Monotonic Stack","text":"<p>\u9700\u8981\u5bfb\u627e\u5bf9\u6bcf\u4e00\u4e2abuilding with index <code>i</code>, \u5728<code>heights[i+1:]</code>\u4e2d\u6ca1\u6709\u4efb\u4f55\u4e00\u4e2a<code>heights[j]</code>\u6ee1\u8db3<code>heights[j] &gt; heights[i]</code>\u7684<code>i</code>. Return a list of those indices. </p> <p>\u6211\u4eec\u53ef\u4ee5\u6c42\u5b83\u7684\u8865\u96c6, \u5f53\u4f60\u7528monotonic stack\u6765\u5bfb\u627e\u6700\u5927\u503c\u65f6\uff0c\u6709\u4e24\u4e2afindings:</p> <ul> <li>\u627e\u5230\u6700\u5927\u503c\u7684\u90fd\u88abpop\u6389\u4e86</li> <li>\u627e\u4e0d\u5230\u6700\u5927\u503c\u7684\u90fd\u5728stack\u91cc</li> </ul> <pre><code>class Solution:\n    def findBuildings(self, heights: List[int]) -&gt; List[int]:\n        # monotonical stack with longer building at the bottom, if found, then we don't want it\n        stack = list()\n        # when the value is poped, that popped value has been blocked and has not ocean view\n        for i,height in enumerate(heights):\n            while stack and height &gt;= heights[stack[-1]]:\n                stack.pop()\n            stack.append(i)\n\n\n        return stack\n</code></pre>","tags":["Arraty","Stack","Monotonic Stack"]},{"location":"leetcode/1768-merge-strings-alternately/","title":"1768 Merge Strings Alternately","text":"","tags":["Two Pointers","String"]},{"location":"leetcode/1768-merge-strings-alternately/#approach-1-two-pointers","title":"Approach 1 Two Pointers","text":"<p>\\(O(m+n)\\) time complexity, \\(O(m+n)\\) space complexity where \\(m\\) is the length of <code>word1</code> and \\(n\\) is the length of <code>word2</code></p> <pre><code>class Solution:\n    def mergeAlternately(self, word1: str, word2: str) -&gt; str:\n        l1,r1 = 0,len(word1)\n        l2,r2 = 0,len(word2)\n\n        res = []\n        while l1 &lt; r1 or l2 &lt; r2:\n            if l1 &lt; r1:\n                res.append(word1[l1])\n                l1 += 1\n            if l2 &lt; r2:\n                res.append(word2[l2])\n                l2 += 1\n\n        return \"\".join(res)\n</code></pre>","tags":["Two Pointers","String"]},{"location":"leetcode/1876-substring-of-size-three-with-distinct-characters/","title":"Approach 1 Hash","text":"<p>First thing pops in my head after seeing checking duplicate in subarray is to ues hash, so i divide the problem into two parts: - determine whether all characters within the window are different from each other, returns boolean. This is handled in <code>isGood()</code> method - traverse the string</p>"},{"location":"leetcode/1876-substring-of-size-three-with-distinct-characters/#code","title":"Code","text":"<pre><code>class Solution:\n    def isGood(self,window):\n        # return whether all three chars are different to each other\n        # create a dictionary\n        sliding_hash = {}\n\n        # traverse the window\n        for i in range(3):\n            if window[i] not in sliding_hash:\n                sliding_hash[window[i]] = 1\n            else:\n                return False\n\n        return True\n\n    def countGoodSubstrings(self, s: str) -&gt; int:\n        # output\n        res = 0\n        # traverse the string \n        for i in range(0,len(s)-2):\n            # determine wether it's unique\n            if self.isGood(s[i:i+3]):\n                res += 1\n        return res\n</code></pre>"},{"location":"leetcode/1876-substring-of-size-three-with-distinct-characters/#approach2-sliding-window","title":"Approach2: Sliding Window","text":"<p>Sliding window, a technique that is used to minimize the number of redundant traversal or scan over the item in array or string. In this problem, when window slides forward by one, you need to: - remove the last element  - take in new element in the direction of moving</p> <p>To achieve the above two operations, just shuffle everything forward by one like how insert and remove work in static array. </p>"},{"location":"leetcode/1876-substring-of-size-three-with-distinct-characters/#code_1","title":"Code","text":"<pre><code>class Solution:\n    def countGoodSubstrings(self, s: str) -&gt; int:\n        # sliding window approach\n\n        # edge case\n        if len(s) &lt; 3:\n            return 0\n\n        # output\n        res = 0\n        # declare three variables\n        a,b,c = s[0],s[1],s[2]\n\n        # compare within the window, then slide forward by 1\n        for i in range(0,len(s)-2):\n            # determine whether char in window are mutually different\n            if a != b and b!=c and a!=c:\n                res += 1\n\n            # for the last window, you don't need to slide forward since it's over\n            if i+3 != len(s):\n                a = b\n                b = c\n                c = s[i+3]\n\n        return res\n</code></pre>"},{"location":"leetcode/19-remove-nth-node-from-end-of-list/","title":"19 remove nth node from end of list","text":"<p>sss</p>"},{"location":"leetcode/191-number-of-1-bits/","title":"191 Number of 1 Bits","text":"<p>\u8fd9\u9898\u662f\u8ba1\u7b97hamming weight. \u7ed9\u7684\u662f\u4e00\u4e2a32\u4f4d\u7684\u6574\u6570\uff0c\u8ba1\u7b97\u8fd9\u4e2a\u6574\u6570\u7684\u4e8c\u8fdb\u5236\u8868\u793a\u4e2d\u6709\u591a\u5c11\u4e2a1, \u6240\u4ee5\u6211\u4eec\u9700\u8981\u505a\u4e24\u4ef6\u4e8b,</p> <ul> <li>check if the last bit is 1</li> <li>use <code>n &amp; 1 = 1</code> to check if the last bit is 1 (same as check if it's odd)</li> <li>traverse the binary input by shift the bits to the right</li> <li><code>n &gt;&gt; 1</code> till <code>n=0</code></li> </ul>","tags":["Divide and Conquer","Bit Manipulation"]},{"location":"leetcode/191-number-of-1-bits/#approach-1-bit-manipulation","title":"Approach 1 Bit Manipulation","text":"<pre><code>class Solution:\n    def hammingWeight(self, n: int) -&gt; int:\n        # 1. check whether the last digit is 1\n        #      n &amp; 1 == 1 then yeahhhh\n        # 2. traverse the bits\n        #      n &gt;&gt; 1 until \n        counter = 0\n        while n != 0:\n            if n &amp; 1 == 1:\n                counter += 1            \n            n = n &gt;&gt; 1\n\n        return counter\n</code></pre>","tags":["Divide and Conquer","Bit Manipulation"]},{"location":"leetcode/1915-number-of-wonderful-substrings/","title":"1915 Number of Wonderful Substrings","text":"<p>\u51e0\u70b9\u95ee\u9898\uff0c</p> <ul> <li>\u5982\u4f55\u80fd\u60f3\u5230\u8981\u7528 bit shift + exclusive or (XOR) \u6765\u89e3\u51b3\u95ee\u9898\uff1f</li> </ul>","tags":["Hash Table","String","Bit Manipulation","Prefix Sum"]},{"location":"leetcode/1915-number-of-wonderful-substrings/#approach-1-prefix-hash-bit","title":"Approach 1: Prefix + Hash + Bit","text":"<p>odd frequency of letter appear at most 1, \u53ef\u4ee5\u88ab\u5206\u89e3\u4e3a\u4e24\u4e2a\u5b50\u95ee\u9898:</p> <ul> <li>\u6c42ending at char i\u7684substring\u4e2d\uff0c\u6709\u591a\u5c11\u4e2aodd letter\u51fa\u73b00\u6b21</li> <li>\u6c42ending at char i\u7684substring\u4e2d\uff0c\u6709\u591a\u5c11\u4e2aodd letter\u51fa\u73b01\u6b21</li> </ul>","tags":["Hash Table","String","Bit Manipulation","Prefix Sum"]},{"location":"leetcode/1915-number-of-wonderful-substrings/#_1","title":"\u63cf\u8ff0\u72b6\u6001","text":"<p>\u4e3a\u4e86\u66f4\u597d\u7684\u63cf\u8ff0state, \u6211\u4eec\u53ef\u4ee5\u7528:</p> <ul> <li>letter\u51fa\u73b0\u8fc7odd\u6b21, bit\u4e3a0</li> <li>letter\u51fa\u73b0\u8fc7even\u6b21, bit\u4e3a1</li> </ul> <p>\u6bcf\u5f53\u6211\u4eecsubstring\u957f\u5927\u65f6\uff0c\u6211\u4eec\u53ef\u4ee5\u7528<code>flip k-th bit</code>\u6765\u4f5c\u4e3a\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b\u6765\u8fed\u4ee3\uff0c<code>mask ^= (1 &lt;&lt; k)</code>, \u4e5f\u5c31\u662f\u8bf4\u6211\u4eec\u53ef\u4ee5\u7528\u4e00\u4e2a10\u4f4d\u7684mask\u6765\u8868\u793a\u5f53\u524d\u7684\u72b6\u6001\uff0c\u6bd4\u5982:</p> <pre><code>a (1 &lt;&lt; 0)\nb (1 &lt;&lt; 1)\nc (1 &lt;&lt; 2)\nd (1 &lt;&lt; 3)\ne (1 &lt;&lt; 4)\nf (1 &lt;&lt; 5)\ng (1 &lt;&lt; 6)\nh (1 &lt;&lt; 7)\ni (1 &lt;&lt; 8)\nj (1 &lt;&lt; 9)\n</code></pre> <p>\u5047\u8bbe<code>s=''</code>, \u521d\u59cb\u503c\u4e3a<code>0000000000</code>, \u4f60\u53ef\u4ee5\u628a\u5b83\u7406\u89e3\u4e3a\u6bcf\u4e2achar\u90fd\u53ea\u51fa\u73b0\u4e86\u5076\u6570\u6b21. \u6bcf\u9047\u5230\u4e00\u4e2a\u65b0\u7684char, \u6211\u4eec\u5c31flip\u5bf9\u5e94\u7684bit with XOR. \u6211\u4eec\u6765\u505a\u4e00\u4e0bdry run, for substring <code>'acadac'</code></p> substring mask <code>''</code> 0 <code>'a'</code> 1 <code>'ac'</code> 101 <code>'aca'</code> 100 <code>'acad'</code> 1100 <code>'acada'</code> 1101 <code>'acadac'</code> 1001 <p>\u63a5\u4e0b\u6765\u6211\u4eec\u53ea\u9700\u8981\u7ef4\u62a4\u4e00\u4e2ahasmap\u4f5c\u4e3a\u6211\u4eec\u7684prefix\u5373\u53ef,</p> <pre><code>{\n    0: 1,\n    1: 1,\n    101: 1,\n    100: 1,\n    1100: 1,\n    1101: 1,\n    1001: 1\n}\n</code></pre>","tags":["Hash Table","String","Bit Manipulation","Prefix Sum"]},{"location":"leetcode/1915-number-of-wonderful-substrings/#1-odd-letter0","title":"\u5b50\u95ee\u98981: odd letter\u51fa\u73b00\u6b21","text":"<p>\u6211\u4eec\u53ea\u9700\u8981\u8bb0\u5f55\u5f53\u524d\u7684mask, \u770b\u4e4b\u524d\u662f\u5426\u51fa\u73b0\u8fc7\uff0c\u51fa\u73b0\u8fc7\u51e0\u6b21\u5c31\u53ef\u4ee5\u8fd9\u4e2a\u89e3\u7684\u53ef\u80fd\u6027. \u7ef4\u62a4\u4e00\u4e2afrequency map\u5373\u53ef</p>","tags":["Hash Table","String","Bit Manipulation","Prefix Sum"]},{"location":"leetcode/1915-number-of-wonderful-substrings/#2-odd-letter1","title":"\u5b50\u95ee\u98982: odd letter\u51fa\u73b01\u6b21","text":"<p>flip <code>k-th</code> bit, \u7136\u540e\u770b\u4e4b\u524d\u662f\u5426\u51fa\u73b0\u8fc7\uff0cO(10)</p> <p>Note</p> <ul> <li>Time Complexity: \\(O(n)\\)</li> <li>Space Complexity: \\(O(n)\\), worst case scenario 10\u4e2a\u89e3</li> </ul>","tags":["Hash Table","String","Bit Manipulation","Prefix Sum"]},{"location":"leetcode/1915-number-of-wonderful-substrings/#code-implementation","title":"Code Implementation","text":"<pre><code>from collections import defaultdict\nclass Solution:\n    def wonderfulSubstrings(self, word: str) -&gt; int:\n        \"\"\"\n        case 1: odd freq\u51fa\u73b00\u6b21\n        case 1: odd freq\u51fa\u73b01\u6b21\n        \u8868\u793astate:\n            jihgfedcba\n\n        a --&gt; 2^0 --&gt; 1\n        b --&gt; 2^1 --&gt; 2\n        ...\n        \"\"\"\n        # initialize a frequency map\n        freq = defaultdict(int)\n        freq[0] = 1\n\n        mask = res = 0\n\n        for char in word:\n            bit = ord(char) - ord('a')\n            # flip current char's bit to get flip mask\n            mask ^= (1 &lt;&lt; bit)\n\n            # case 1: no letter appearing odd number of times\n            res += freq[mask]\n            freq[mask] += 1\n\n            # case 2: one letter appearing odd number of times\n            for odd_char in range(0,10):\n                curr = mask ^ (1 &lt;&lt; odd_char)\n                if curr in freq:\n                    res += freq[curr]\n        return res\n</code></pre>","tags":["Hash Table","String","Bit Manipulation","Prefix Sum"]},{"location":"leetcode/1971-find-if-path-exists-in-graph/","title":"1971 Find if Path Exists in Graph","text":"<p>graph\u7684\u5165\u95e8\uff0c\u662f\u8981\u5f00\u59cb\u6574\u7406graph\u7684\u9898\u76ee\u4e86.</p>","tags":["Depth-First Search","Breadth-First Search","Graph","Union Find"]},{"location":"leetcode/1971-find-if-path-exists-in-graph/#approach-1-dfs","title":"Approach 1 DFS","text":"<pre><code>from collections import defaultdict\nclass Solution:\n    def validPath(self, n: int, edges: List[List[int]], source: int, destination: int) -&gt; bool:\n        # DFS recursive implementation\n        # 1. convert edge set rep of graph to adjacency List (with hashmap)\n        # 2. define an array to mark visited node\n        # 3. pre-order DFS \n\n        graph = defaultdict(list)\n\n        for a,b in edges:\n            graph[a].append(b)\n            graph[b].append(a)\n\n        marked = [False for _ in range(n)]\n        stack = [source]\n\n        while stack:\n            curr = stack.pop()\n            if curr == destination: return True\n\n            if not marked[curr]:\n                marked[curr] = True\n\n                for next_node in graph[curr]:\n                    if not marked[next_node]:\n                        stack.append(next_node)\n\n        return False\n</code></pre>","tags":["Depth-First Search","Breadth-First Search","Graph","Union Find"]},{"location":"leetcode/198-house-robber/","title":"Problem","text":"<p>\u7ed9\u4e00\u4e2ainteger\u6570\u7ec4\uff0c\u6bcf\u4e00\u4e2aelement\u4ee3\u8868\u7740house\u4e2d\u7684\u5f3a\uff0c\u73b0\u5728\u5047\u8bbe\u4f60\u662f\u4e00\u4e2arobber, \u4f60\u9700\u8981\u5728\u4e0d\u80fd\u8fde\u7eed\u5077\u4e24\u4e2a\u76f8\u90bb\u7684houses, \u62a2\u52ab\u6700\u591a\u7684\u7684\u60c5\u51b5\u4e0b\u3002\u4e0d\u80fd\u8fde\u7eed\u5077\u4e24\u4e2a\u76f8\u90bb\u7684houses\u7684\u539f\u56e0\u662f\u4f1a\u89e6\u53d1\u62a5\u8b66\u7cfb\u7edf\uff1b</p> <p>\u6211\u521a\u505a\u8fd9\u9898\u7684Intuition\u662f, \u62a2\u5076\u6570\u5217\u548c\u5947\u6570\u5217\uff0c\u53ef\u4ee5\u62a2\u6700\u591a\u7684houses, \u6240\u4ee5\u7edf\u8ba1\u610f\u4e49\u4e0a\u4e5f\u80fd\u62a2\u6700\u591a\u7684\u4e1c\u897f, \u4f46\u8fd9\u5e76\u4e0d\u7edd\u5bf9\u3002\u7b54\u6848\u662f\u7528DP\u7684\u601d\u60f3</p>"},{"location":"leetcode/198-house-robber/#example-1","title":"Example 1","text":"<pre><code>Input: nums = [1,2,3,1]\nOutput: 4\nExplanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\n</code></pre>"},{"location":"leetcode/198-house-robber/#example-2","title":"Example 2","text":"<pre><code>Input: nums = [1,2,3,1]\nOutput: 4\nExplanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\n</code></pre>"},{"location":"leetcode/198-house-robber/#code-python","title":"Code Python","text":"<p>\u8bb0\u4f4fDP\u7684\u91cd\u8981\u6838\u5fc3\u601d\u60f3: - \u6bcf\u4e00\u6b65\u90fd\u53ef\u80fd\u662f\u6700\u540e\u4e00\u6b65 - \u4f60\u8fd9\u4e00\u6b65\u7684\u51b3\u5b9a\u5982\u4f55\uff0c\u5b8c\u5168\u53d6\u51b3\u4e8e\u4f60\u8fc7\u5f80\u7684\u6b65\u6570 (information in the current time step depends on the prev steps or hisotry steps)</p> <pre><code>class Solution:\n    def rob(self, nums: List[int]) -&gt; int:\n        # initialize an dp list\n        dp = list()\n\n        if len(nums) == 0: \n            return 0\n\n        dp.append(nums[0])\n        if len(nums) == 1:\n            return dp[0]\n\n        dp.append(max(nums[0],nums[1]))\n        if len(nums) == 2:\n            return dp[1]\n\n\n        for i in range(2,len(nums)):\n            # robber has two choices:\n            # Option1: \u5077\u623f\u5b50i\n            # Option2: \u4e0d\u5077\u623f\u5b50i, \u56e0\u4e3a[i-1]\u7684\u503c\u66f4\u5927\uff0c\u800c\u4e14i+1&gt;= 0, \u6240\u4ee5\u8fd9\u4e48\u5077\u4e0d\u4f1a\u4e8f\n            dp.append(max(dp[i-1], dp[i-2] + nums[i]))\n\n        return dp[-1]\n</code></pre>"},{"location":"leetcode/1992-find-all-groups-of-farmland/","title":"1992 Find All Groups of Farmland","text":"","tags":["Array","Depth-First Search","Breadth-First Search","Matrix"]},{"location":"leetcode/1992-find-all-groups-of-farmland/#approach-1-bfs","title":"Approach 1: BFS","text":"<p>\u5229\u7528BFS\u7684\u6027\u8d28\uff0c\u4ee5\u53cafarmland\u662frectangle\u4e14\u4e0d\u8fde\u901a\u7684\u6027\u8d28\uff0c\u6211\u4eec\u53ef\u4ee5\u7528BFS\u6765\u641c\u7d22\u6bcf\u4e00\u4e2afarmland\u7684\u56db\u4e2a\u89d2\u3002\u6211\u4eec\u53ef\u4ee5\u7528\u4e00\u4e2ahashset\u6765\u8bb0\u5f55\u5df2\u7ecf\u8bbf\u95ee\u8fc7\u7684farmland\uff0c\u7136\u540e\u4ece\u5de6\u5230\u53f3\uff0c\u4ece\u4e0a\u5230\u4e0b\u641c\u7d22\uff0c\u5982\u679c\u5f53\u524dfarmland\u6ca1\u6709\u88ab\u8bbf\u95ee\u8fc7\uff0c\u6211\u4eec\u5c31\u7528BFS\u641c\u7d22\u8fd9\u4e2afarmland\u7684\u56db\u4e2a\u89d2\u3002\u6700\u540e\u6211\u4eec\u8fd4\u56de\u6240\u6709farmland\u7684\u56db\u4e2a\u89d2\u3002</p> <p>trick\u5728\u4e8e\uff0c\u6211\u4eec\u9700\u8981\u8bb0\u5f55top left corner (r1,c1)\u548cbottom right corner (r2,c2), \u5176\u5b9e\u5c31\u662fbfs\u7684\u7b2c\u4e00\u5c42\u548c\u6700\u540e\u4e00\u5c42\uff0c\u5982\u4e0b\u56feripple effect of BFS\u6240\u793a:</p> <p></p> <pre><code>from collections import deque\nclass Solution:\n    def findFarmland(self, land: List[List[int]]) -&gt; List[List[int]]:\n        \"\"\"\n        top left (r1,c1)\n        bottom right (r2,c2)\n        represents to (r1,c1,r2,c2)\n        observation: \n        - hashset to store tuple visited = [(r,c),....]\n        - left -&gt; right, top -&gt; down scan\n        - BFS\u641c\u7d22\u7684\u6700\u540e\u4e00\u5c42\n        \"\"\"\n        res = []\n        rows,cols = len(land),len(land[0])\n        visited = set()\n\n        def bfs(i,j):\n            corners = [i,j]            \n            visited.add((i,j))\n            q = deque([(i,j)])\n            directions = [[-1,0],[1,0],[0,-1],[0,1]]\n\n            while q:\n                r_0,c_0 = q.popleft()\n                # infinitesimal steps\n                for dr,dc in directions:\n                    r,c = r_0 + dr, c_0 + dc\n                    if r &gt;= 0 and r &lt; rows and c &gt;=0 and c &lt; cols and (r,c) not in visited and land[r][c] == 1:\n                        visited.add((r,c))\n                        q.append((r,c))\n            # last node will be bottom right corner\n            corners.extend([r_0,c_0])\n            return corners\n\n        for i in range(rows):\n            for j in range(cols):\n                if land[i][j] == 1 and (i,j) not in visited:\n                    corners = bfs(i,j)                    \n                    res.append(corners)\n        return res\n</code></pre>","tags":["Array","Depth-First Search","Breadth-First Search","Matrix"]},{"location":"leetcode/2-add-two-numbers/","title":"Approach 1:","text":"<p>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.</p> <p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p> <p></p> <pre><code>Input: l1 = [2,4,3], l2 = [5,6,4]\nOutput: [7,0,8]\nExplanation: 342 + 465 = 807.\n</code></pre>","tags":["linked list","dummy node","carry"]},{"location":"leetcode/2-add-two-numbers/#intuition","title":"Intuition","text":"<p>\u5728\u6784\u9020\u4e00\u4e2alinked list\u65f6\uff0c\u4e00\u822c\u4f1a\u52a0\u4e00\u4e2adummy header node, \u4fdd\u8bc1boundary nodes\u548cinternal nodes\u6709\u4e00\u6837\u7684\u5904\u7406\u65b9\u6cd5</p> <p>\u8fd9\u4e00\u9898\u521d\u59cb\u6761\u4ef6\u4f4dcarry = 0</p> <p>\u6bcf\u4e00\u4e2a\u65f6\u6b65\u8981\u8ba1\u7b97: - l1 and l2\u7684\u5f53\u524d\u503c, None\u5219\u8bf4\u660e\u6ca1\u6709node, \u5219\u4e3a0 - \u8ba1\u7b97<code>val = l1 + l2</code>, \u662f\u4e00\u4e2a0 - 18\u7684\u6570\u5b57 - \u8ba1\u7b97\u8fdb\u4f4d<code>carry = val//10</code> and \u4f59\u6570<code>val = val%10</code></p>","tags":["linked list","dummy node","carry"]},{"location":"leetcode/2-add-two-numbers/#code","title":"Code","text":"<pre><code># Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -&gt; Optional[ListNode]:\n\n        dummy = ListNode()\n        curr = dummy\n\n        carry = 0\n\n        while l1 or l2 or carry:\n            val_1 = l1.val if l1 else 0\n            val_2 = l2.val if l2 else 0\n\n            val = val_1 + val_2 + carry\n            carry = val//10\n            val = val%10\n\n            curr.next = ListNode(val)\n            curr = curr.next\n\n            l1 = l1.next if l1 else None\n            l2 = l2.next if l2 else None\n\n        return dummy.next\n</code></pre>","tags":["linked list","dummy node","carry"]},{"location":"leetcode/20-valid-parentheses/","title":"Approach 1: brute force","text":""},{"location":"leetcode/20-valid-parentheses/#intuition","title":"Intuition","text":"<p>\u5bf9\u4e8e\u4efb\u4f55valid string\u6765\u8bf4\uff0c\u90fd\u4f1a\u5b58\u5728\u81f3\u5c11\u4e00\u5bf9bracket pair, \u5f53\u4f60\u79fb\u9664\u8fd9\u4e00\u5bf9bracket pair\u65f6\uff0c\u4f60\u4f1a\u53d1\u73b0\uff0c\u81f3\u5c11\u8fd8\u4f1a\u5b58\u5728\u4e00\u5bf9bracket pair, \u76f4\u5230string\u957f\u5ea6\u4e3a0\u3002bracket pair\u7684\u5b9a\u4e49\u662f <code>\"{}\"</code> or <code>\"()\"</code> or <code>\"[]\"</code>. </p> <p>test cases\u6709\u51e0\u79cd\u7c7b\u578b: - nested: <code>\"{([])}\"</code> - side-by-side: <code>[](){}</code></p>"},{"location":"leetcode/20-valid-parentheses/#approach","title":"Approach","text":"<p>\u4e4b\u524d\u5728codewar\u505a\u8fc7\u8fd9\u9053\u9898\uff0c\u6700\u540e\u770b\u5230\u7684\u89e3\u6cd5\u5c31\u662f\u8fd9\u4e2a\uff0c\u975e\u5e38elegant.</p>"},{"location":"leetcode/20-valid-parentheses/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: \\(O(n^2)\\), <code>s.replace</code> is O(n), for every pair of bracket.</li> </ul> <ul> <li>Space complexity: \\(O(1)\\)</li> </ul>"},{"location":"leetcode/20-valid-parentheses/#code","title":"Code","text":"<pre><code>\"\"\"\nbrute force solution, i have done it once on code war,\n\ntime complexity: O(n^2), \u5047\u8bbe\u6211\u4eec\u7684string s\u957f\u5ea6\u4e3an\uff0c\n\u4f5c\u4e3a\u4e00\u4e2avalid parathenes, \u91cc\u9762\u6709n/2 pair of bracket, \n\u6211\u4eec\u9700\u8981traverse\u81f3\u5c11 n/2\u904d of length n, \u6240\u4ee5\u65f6\u95f4\u590d\u6742\u5ea6\u4e3an^2\n\nspace complexity: O(1)\n\"\"\"\n\nclass Solution:\n    def isValid(self, s: str) -&gt; bool:\n        parentheses = \"()\"\n        curlyBracket = \"{}\"\n        squareBracket = \"[]\"\n\n        while parentheses in s or curlyBracket in s or squareBracket in s:\n            if parentheses in s:\n                s = s.replace(parentheses,\"\")\n            if curlyBracket in s:\n                s = s.replace(curlyBracket,\"\")\n            if squareBracket in s:\n                s = s.replace(squareBracket,\"\")\n\n\n        if s is \"\":\n            return True\n        else:\n            return False\n</code></pre>"},{"location":"leetcode/20-valid-parentheses/#approach-2-stack","title":"Approach 2: stack","text":""},{"location":"leetcode/20-valid-parentheses/#intuition_1","title":"Intuition","text":"<p>\u770b\u4e86\u7b54\u6848\u4e4b\u540e\u7684\u601d\u8def\uff0c\u5bf9\u4e8e\u4efb\u4f55valid string\u6709\u4ee5\u4e0b\u51e0\u4e2a\u7279\u5f81\uff1a - number of opening brackets is equal to number of closing brackets - for every closing bracket you met, it must be the pair of the very last opening bracket you met.</p>"},{"location":"leetcode/20-valid-parentheses/#approach_1","title":"Approach","text":"<ul> <li>emulate a <code>stack</code> using python list</li> <li>create a hash for storing pairs info.</li> <li>traverse every element in the string</li> </ul>"},{"location":"leetcode/20-valid-parentheses/#complexity_1","title":"Complexity","text":"<ul> <li>Time complexity: \\(O(n)\\), one-pass solution</li> </ul> <ul> <li>Space complexity: \\(O(n)\\), for stack</li> </ul>"},{"location":"leetcode/20-valid-parentheses/#code_1","title":"Code","text":"<pre><code>class Solution:\n    def isValid(self, s: str) -&gt; bool:\n        # use list to emulate array-based stack\n        stack = []\n\n        # a hash with closing bracket as keys and opening bracket as value\n        mapping = {\n                    \"}\":\"{\",\n                    \"]\":\"[\",\n                    \")\":\"(\"    \n                  }\n\n        # traverse every element in the string\n        for char in s:\n            if char in mapping.keys():\n                # \u8fd9\u4e2a\u5b57\u7b26\u662fclosing bracket\n                if stack:\n                    top_element = stack.pop()\n                else:\n                    top_element = \"dummy\"\n\n                if mapping[char] != top_element:\n                    # \u9519\u4f4d\u4e86,\u5bf9\u4e0d\u4e0a\u53f7 \n                    return False\n            else:\n                # \u8fd9\u4e2a\u5b57\u7b26\u662fopening bracket\n                stack.append(char)\n\n        if len(stack) == 0:\n            return True\n        else:\n            return False\n</code></pre>"},{"location":"leetcode/200-number-of-islands/","title":"200 Number of Islands","text":"<p>\u89e3\u7684\u7b2c\u4e00\u9898graph, \u5f88\u7ecf\u5178,  \u6709\u4ee5\u4e0b\u51e0\u79cd\u505a\u6cd5:</p> <ul> <li>BFS<ul> <li>\u7528HashSet\u8bb0\u5f55visited, O(MN), O(MN)</li> <li>in-place\u4fee\u6539grid, O(MN), O(min(M,N))</li> </ul> </li> <li>DFS<ul> <li>in-place\u4fee\u6539grid, O(MN), O(1)</li> </ul> </li> <li>Union Find</li> </ul> <p>DFS vs BFS</p> <p>Graph algorithm\u5b66\u8d77\u6765\u5f88\u4e0a\u5934\uff0c\u8fd9\u4e2a\u5728porous medium\u4e4b\u4e2d\u8ba1\u7b97pore size distribution\u7b49\uff0c\u53ef\u4ee5\u8bf4\u975e\u5e38\u6709\u5e2e\u52a9. Percolation theory etc. </p> <p>DFS\u662f\u4e00\u6761\u8def\u8d70\u5230\u9ed1\u4e4b\u540e(base case)\uff0c\u518d\u56de\u6765\u53bb\u53e6\u4e00\u4e2a\u65b9\u5411. BFS\u662f\u7684\u5982\u4e2d\u5fc3\u5411\u5916\u8f90\u5c04.</p>","tags":["Array","Depth-first Search","Breadth-first Search","Union Find","Matrix"]},{"location":"leetcode/200-number-of-islands/#approach-1-breadth-first-search","title":"Approach 1: Breadth-first Search","text":"<p>\u7528\u7c7b\u6bd4\u7684\u601d\u60f3\u6bd4\u8f83\u4e00\u4e0b\u6211\u5df2\u7ecf\u4f1a\u7684tree traversal:</p> - BFS in tree BFS in graph description \u5a92\u4ecb TreeNode \u901a\u5e38\u662fMatrix - Auxillary DS Queue Queue,HashSet \u9700\u8981HashSet\u8bb0\u5f55\u6709\u6ca1\u6709\u8bbf\u95ee\u8fc7\uff0c\u4e3b\u8981\u662f\u56e0\u4e3a\u5728graph\u4e2d\u7684BFS\u53ef\u4ee5\u5f80\u56db\u4e2a\u65b9\u5411\u8d70\uff0c\u4f46tree\u4e2d\u5c31\u4e00\u4e2a\u65b9\u5411 <p>\u4e3a\u4e86\u66f4\u597d\u7684\u6bd4\u8f83tree and graph BFS\u770b\u770b\u4e0b\u56fe</p> <p></p> <p>\u90a3\u4e48\u5bf9\u4e8e\u8fd9\u4e00\u9898, BFS\u641c\u7d22\u793a\u610f\u56fe\u5982\u4e0b:</p> <p></p> <pre><code>from collections import deque\nclass Solution:\n    def numIslands(self, grid: List[List[str]]) -&gt; int:\n        rows,cols = len(grid),len(grid[0])\n\n        visited = set()\n        num_of_islands = 0\n\n        def bfs(r,c):\n            # initialization of a grid\n            diff = [(1,0),(-1,0),(0,1),(0,-1)]\n            queue = deque()\n            queue.append((r,c))\n            visited.add((r,c))\n\n            # BFS\u63a2\u7d22neighbours\n            while queue:\n                # \u5982\u679c\u9047\u5230\u4e00\u4e2avalid node\n                # 1. \u4e0d\u8fc7\u8fb9\u754c\n                # 2. \u6ca1\u6709\u8bbf\u95ee\u8fc7\n                # 3. \u662f\u9646\u5730, \"1\"\n\n                i,j = queue.popleft()\n                for dr,dc in diff:\n                    r,c = i + dr,j + dc\n                    if (r &gt;= 0 and r &lt;= rows -1 and c &gt;= 0 and c &lt;= cols -1 and \n                    (r,c) not in visited and grid[r][c] == \"1\"):                    \n                        queue.append((r,c))\n                        visited.add((r,c))\n\n        for r in range(rows):\n            for c in range(cols):\n                if grid[r][c] == \"1\" and (r,c) not in visited:                        \n                    bfs(r,c)\n                    num_of_islands += 1\n\n        return num_of_islands\n</code></pre> <p>Complexity</p> <ul> <li>Time complexity: \\(O(M \\times N)\\), \u6211\u4eecgrid\u6bcf\u4e00\u4e2a\u70b9\u90fd\u8981\u8d70\u4e00\u904d</li> <li>Space complexity: \\(O(M \\times N)\\), \u6211\u4eec\u9700\u8981\u7ef4\u62a4queue\u548cHashSet, queue\u6700\u574f\u60c5\u51b5\u4e0b\u5e94\u8be5\u662f\u80fdfit\u8fdb\u5165\u7684rectangle\u6700\u5927\u5468\u957f\u6216\u8005\u5bf9\u89d2\u7ebf\u957f\u5ea6, HashSet\u6700\u574f\u60c5\u51b5\u4e0b\u4e5f\u4f1a\u6709\\(O(M \\times N)\\)\u4e2a\u70b9. \u6240\u4ee5\u4e0d\u9700\u8981\u7ea0\u7ed3queue\u6700\u574f\u5230\u5e95\u591a\u5c11\uff0c\u4e0b\u9650\u4e3a\\(O(M \\times N)\\).</li> </ul> <p>\u6240\u4ee5\u8fd9\u4e00\u9898\u8fd8\u6709\u4f18\u5316\u7a7a\u95f4\u7684\u53ef\u80fd\u6027\uff0c\u6211\u4eec\u53ef\u4ee5\u4fee\u6539input. \u62ff<code>grid</code>\u505a\u6211\u4eec\u7684hashset!!(\u5982\u679c\u5141\u8bb8\u7684\u8bdd\uff0c\u53ef\u4ee5\u95ee\u9762\u8bd5\u5b98). Worst case\u4e0b\uff0c\u6211\u4eec\u7684space complexity\u53ef\u4ee5\u964d\u5230\\(O(min(M,N))\\), \u4e5f\u5c31\u662fgrid is filled with \"1\".</p> <pre><code>from collections import deque\nclass Solution:\n    def numIslands(self, grid: List[List[str]]) -&gt; int:\n        if not grid:\n            return 0\n\n        rows,cols = len(grid),len(grid[0])\n        islands = 0\n        for i in range(rows):\n            for j in range(cols):\n                if grid[i][j] == '1':\n                    islands += 1\n                    # mark as visited\n                    grid[i][j] = '0'\n                    q = deque([(i,j)])\n\n                    while q:\n                        r,c = q.popleft()                      \n                        if r-1 &gt;= 0 and grid[r-1][c] == \"1\":\n                            q.append((r-1,c))\n                            grid[r-1][c] = \"0\"\n\n                        if r + 1 &lt; rows and grid[r+1][c] == \"1\":\n                            q.append((r+1,c))\n                            grid[r+1][c] = \"0\"\n\n                        if c-1 &gt;= 0 and grid[r][c-1] == \"1\":\n                            q.append((r,c-1))\n                            grid[r][c-1] = \"0\"\n\n                        if c+1 &lt; cols and grid[r][c+1] == \"1\":\n                            q.append((r,c+1))\n                            grid[r][c+1] = \"0\"\n        return islands\n</code></pre>","tags":["Array","Depth-first Search","Breadth-first Search","Union Find","Matrix"]},{"location":"leetcode/200-number-of-islands/#approach-2-dfs","title":"Approach 2: DFS","text":"<p>in-place modification, O(MN), O(1)</p> <pre><code>class Solution:\n    def numIslands(self, grid: List[List[str]]) -&gt; int:\n        if not grid:\n            return 0\n\n        islands = 0\n        rows,cols = len(grid),len(grid[0])\n\n        def dfs(r,c):\n            \"\"\"\u53ea\u8d1f\u8d23mark\n            \"\"\"\n            # invalid, or encounter sea\n            if r &lt; 0 or r &gt;= rows or c &lt; 0 or c &gt;= cols or grid[r][c] != '1':\n                return\n            # in-place modification\n            grid[r][c] = '+'\n            dfs(r+1,c)\n            dfs(r-1,c)\n            dfs(r,c+1)\n            dfs(r,c-1)\n\n        for i in range(rows):\n            for j in range(cols):\n                if grid[i][j] == '1':\n                    dfs(i,j)\n                    islands += 1\n        return islands\n</code></pre>","tags":["Array","Depth-first Search","Breadth-first Search","Union Find","Matrix"]},{"location":"leetcode/200-number-of-islands/#approach-3-union-find","title":"Approach 3 Union Find","text":"","tags":["Array","Depth-first Search","Breadth-first Search","Union Find","Matrix"]},{"location":"leetcode/2000-reverse-prefix-of-word/","title":"2000 Reverse Prefix of Word","text":"","tags":["Two Pointers","String"]},{"location":"leetcode/2000-reverse-prefix-of-word/#approach-1-brute-force","title":"Approach 1 brute force","text":"<pre><code>class Solution:\n    def reversePrefix(self, word: str, ch: str) -&gt; str:\n        \"\"\"\n        1. traverse the string until we found another word[i] == c\n        if found, we reverse it\n\n        if not found, we just join them together\n        \"\"\"\n        N = len(word)\n        prefix = []\n        found = False\n        for i in range(N):\n            if word[i] == ch:\n                found = True\n                prefix.append(word[i])\n                break\n            prefix.append(word[i])\n\n        if found:\n            return ''.join(prefix)[::-1] + word[i+1:]\n        else:\n            return word\n</code></pre>","tags":["Two Pointers","String"]},{"location":"leetcode/201-bitwise-and-of-numbers-range/","title":"201 Bitwise AND of Numbers Range","text":"<p>\u8fd9\u9898\u8981\u7406\u89e3</p>","tags":["Bit Manipulation"]},{"location":"leetcode/201-bitwise-and-of-numbers-range/#approach-1-common-prefix","title":"Approach 1 Common prefix","text":"<p>\u8fd9\u9898\u7684\u7406\u89e3, Bit\u90fd\u662f\u5047\u7684\uff0c\u4e3b\u8981\u7684\u662f\u8fd8\u662f\u627e\u89c4\u5f8b\u548cidentify pattern. \u8fd9\u4e00\u9898\u7684pattern\u662ffind the common prefix.</p> <p></p> <p>\u53ea\u4e0d\u8fc7\u4e0d\u50cftraverse string, \u8fd9\u91cc\u662ftraverse bit. \u7528\u7684\u662fbitwise shift\u7f62\u4e86.</p> <pre><code>class Solution:\n    def rangeBitwiseAnd(self, left: int, right: int) -&gt; int:\n        counter = 0\n        while left != right:\n            left = left &gt;&gt; 1\n            right = right &gt;&gt; 1\n            counter += 1\n        # now, left and right are equal\n        return left &lt;&lt; counter\n</code></pre>","tags":["Bit Manipulation"]},{"location":"leetcode/202-happy-number/","title":"Intuition","text":"<p>The number <code>n</code> either converge to 1 or <code>n</code> forms a loop as you take the sum of all digits.</p>"},{"location":"leetcode/202-happy-number/#approach","title":"Approach","text":"<p>two pointer technique for cycle detection. - check for corner cases 10,100,1000 - set <code>slow</code> and <code>fast</code> pointer to be <code>n</code>  - advances <code>slow</code> one step, <code>fast</code> two steps every iteration until <code>fast</code> pointer equals to 1. Jump out of the loop when <code>fast</code> pointer met <code>slow</code> pointer.</p>"},{"location":"leetcode/202-happy-number/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: \\(O(n)\\)</li> </ul> <ul> <li>Space complexity: \\(O(1)\\)</li> </ul>"},{"location":"leetcode/202-happy-number/#code","title":"Code","text":"<pre><code>class Solution:\n    def squSumAllDigits(self,n):\n        # return the sum of the squares of all digits in n\n        # n: int\n        # res: int, sum of the squares of its digits\n        res = 0\n        for char in str(n):\n            res += int(char)**2\n\n        return res\n\n    def isHappy(self, n: int) -&gt; bool:\n        # Constraints: 1&lt;= n &lt;= 2**31 - 1\n\n        # Corner cases: checking for n = 1,10,100 all those number with 1 following trailing zeros\n        if self.squSumAllDigits(n) == 1:\n            return True\n\n        # two pointer, totorise and hare Solution for cycle detection\n        slow = n\n        fast = n\n\n        # base case: fast !=1\n        # jump out of the loop when two pointer met\n        while fast != 1:\n            # fast pointer advances two steps\n            fast = self.squSumAllDigits(fast)\n            fast = self.squSumAllDigits(fast)\n            # slow pointer advances by one\n            slow = self.squSumAllDigits(slow)\n\n            if fast == slow:\n                return False\n\n        return True\n</code></pre>"},{"location":"leetcode/203-remove-linked-list-elements/","title":"Notes","text":""},{"location":"leetcode/203-remove-linked-list-elements/#sentinel-nodedummy-node","title":"Sentinel Node/Dummy node","text":"<p>\u4e4b\u524dimplement singly linked list \u65f6,\u6709\u51e0\u4e2a\u96be\u70b9: - insert and remove\u7684\u4e0d\u7edf\u4e00\u6027:   - <code>insert/remove</code> at top   - <code>insert/remove</code> at middle   - <code>insert/remove</code> at end</p> <p>\u8fd9\u65f6\u5019\u9700\u8981\u7528\u5230\u4e00\u4e2atechnique\u6765standardize\u548c\u7edf\u4e00\u8fd9\u4e2a\u6d41\u7a0b, \u53eb\u505adummy header node or sentinel node. \u5f53\u4f60\u52a0\u4e86\u4e00\u4e2adummy node at the beginning of the linked list\u65f6, \u6240\u6709\u7684\u70b9\u90fd\u53d8\u4e3a\u4e86middle node\u7684\u5904\u7406\u65b9\u5f0f;</p> <p></p> <p>\u5982\u4e0a\u56fe\uff0c\u5982\u679c\u6211\u4eec\u73b0\u5728\u505a<code>remove(val = 1)</code>, \u5f97\u5206\u7c7b\u8ba8\u8bba: - 1 is store in the first node <code>probe = head; probe.next = None</code> - 1 is stored in the middle node</p> <p>sentinel\u7684\u7528\u6cd5\u8fd8\u4f1a\u6269\u5c55\u5230\uff1a - head dummy node and tail dummy node - used in tree to know the level</p>"},{"location":"leetcode/203-remove-linked-list-elements/#two-helper-pointer","title":"two helper pointer","text":"<p>\u4e4b\u524dimplement\u5355\u94fe\u8868\u65f6\uff0c\u6211\u4e00\u822c\u53ea\u7528\u4e00\u4e2apointer\u6765traverse, etc, \u4f46\u5c31\u8fd9\u4e00\u9898\u6765\u8bf4\uff0c\u53ef\u4ee5\u7528\u4e24\u4e2apointer\u6765mark previous location and current location. \u5b9e\u9645\u4e0a\u5f88\u50cfnumerical method\u4e2d\u8bb0\u5f55last time step\u548ccurrent time step, \u662f\u4e00\u4e2ageneralization.\u4f60\u53ea\u9700\u8981\u4e0d\u65adshuffle\u5c31\u53ef\u4ee5\u4e86, \u5177\u4f53\u6982\u5ff5\u5982\u4e0b\u56fe.</p> <p></p> <p>pointer <code>prev</code>\u548cpointer <code>curr</code>\u4e0d\u65ad\u5411\u4e0b</p>"},{"location":"leetcode/203-remove-linked-list-elements/#approach","title":"Approach","text":""},{"location":"leetcode/203-remove-linked-list-elements/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: \\(O(n)\\), one pass solution</li> </ul> <ul> <li>Space complexity: \\(O(1)\\)</li> </ul>"},{"location":"leetcode/203-remove-linked-list-elements/#code","title":"Code","text":"<pre><code># Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def removeElements(self, head: Optional[ListNode], val: int) -&gt; Optional[ListNode]:\n        \"\"\"\n        dummy node\u6c42\u89e3\u6a21\u5f0f\n        \"\"\"\n        dummy_node = ListNode(val = None,\n                              next =None)\n        dummy_node.next = head\n\n        # \u8bbe\u7f6e\u4e24\u4e2apointer\u8bb0\u5f55previous location and current location\n        prev,curr = dummy_node,head\n\n        while curr:\n            if curr.val == val:\n                # \u53d1\u73b0target\u4e86\n                prev.next = curr.next\n            else:\n                # \u6ca1\u53d1\u73b0\n                prev = curr\n\n            curr = curr.next\n\n        return dummy_node.next\n</code></pre>"},{"location":"leetcode/205-isomorphic-strings/","title":"205 Isomorphic Strings","text":"<p>If two strings are isomorphic, then it exists a hashmap that maps one character to another character such that it can map the first string to the second string, as illustrated in the figure below,</p> <p></p>","tags":["Hash Table","String"]},{"location":"leetcode/205-isomorphic-strings/#approach-1","title":"Approach 1","text":"<pre><code>class Solution:\n    def isIsomorphic(self, s: str, t: str) -&gt; bool:\n\n        def oneWayMapping(str1,str2):\n            stringHash = {}\n            # traverse the string and initialize the hash        \n            for i in range(len(s)):\n                # check if collision happens\n                if str1[i] in stringHash:\n                    if stringHash[str1[i]] != str2[i]:\n                        return False\n                # build the mapping\n                stringHash[str1[i]] = str2[i]\n            return True\n\n        return oneWayMapping(s,t) and oneWayMapping(t,s)\n</code></pre>","tags":["Hash Table","String"]},{"location":"leetcode/206-reverse-linked-list/","title":"206 Reverse Linked List","text":"<p>Good exercise to for learning the concept of recursion.</p> <p>Follow up: Reverse a linked list could also be solved both iteratively and recursively. Implement the recursive solution.</p>","tags":["Linked List","Recursion"]},{"location":"leetcode/206-reverse-linked-list/#approach-1-iterative-solution","title":"Approach 1: iterative solution","text":"<p>How to reverse a linked list, \u6bd4\u8f83\u7ecf\u5178\u7684\u4e00\u9898, \u540c\u65f6\u8003\u5230\u4e86<code>linked list</code>\u548c<code>two pointer technique</code>. </p> <p>\u8fd9\u4e00\u9898\u5c5e\u4e8e<code>two pointer technique</code>\u4e2d\u7684same-direction\u9898\u578b\uff0c\u540c\u65f6\u4fe9pointer traverse at same speed but offset by one.</p> <p>\u6211\u7b2c\u4e00\u6b21\u505a\u8fd9\u4e00\u9898\u7684\u65f6\u5019\uff0c\u6709\u51e0\u4e2a\u9519\u8bef\u601d\u8def:</p> <ul> <li>\u5c06linked list\u4e00\u4e2a\u4e00\u4e2a\u653e\u5230array\u4e2d; \u7136\u540ereverse;\u7136\u540e\u91cd\u65b0\u63d2\u5165 (\u5f53\u573aveto, \u80af\u5b9a\u592a\u6162\u8fc7\u4e0d\u4e86super long test cases)</li> <li>two pointer offset by one </li> </ul>","tags":["Linked List","Recursion"]},{"location":"leetcode/206-reverse-linked-list/#algorithm","title":"Algorithm","text":"<p>Set up two pointer <code>curr</code> and <code>prev</code>, which set to be the first node and null, respectively.</p> <p></p> <p>Warning</p> <p>\u5728\u8fd9\u91cc\u5e76\u4e0d\u662f\u8bbe\u7f6e\u4e86\u5728\u94fe\u8868\u4e2d\u5e38\u89c1\u7684dummy header node. \u8fd9\u91cc\u53ea\u662f\u8bbe\u7f6e\u4e86<code>None</code>\u6765\u6807\u8bb0reverse\u4e4b\u540e\u7684linked list's tail node\u6307\u5411\u7684<code>None</code>. \u4f60\u53ef\u4ee5\u628a\u8fd9\u4e2a\u64cd\u4f5c\u7406\u89e3\u4e3aleft padding in array problems</p> <p>\u7531\u4e8epointer <code>curr</code>\u548c<code>prev</code>\u505asame direction scan, \u8981\u89e3\u51b3\u4ee5\u4e0b\u95ee\u9898:</p> <ul> <li>\u4f60\u80af\u5b9a\u9700\u8981<code>curr.next = prev</code>\u5c06current node\u6307\u5411previous node, \u4f46\u4f60\u4f1a\u4e22\u5931next node\u5728\u54ea, \u6240\u4ee5\u4f60\u9700\u554a\u5efa\u7acb\u4e00\u4e2a\u6307\u9488<code>temp</code>\u6765\u6307\u5411next code (idea is exactly like int value swapping with <code>temp</code>)</li> </ul> <p>\u7b2c\u4e00\u4e2a\u5faa\u73af\u5982\u4e0b\u56fe:</p> <ul> <li><code>temp = curr.next</code>: create a pointer points to next node</li> <li><code>curr.next = prev</code>: points the current node to the previous node. </li> <li><code>prev = current</code>: previous pointer advances by one.</li> <li><code>curr = temp</code>: current pointer advances by one</li> </ul> <p></p> <p>Tip</p> <p>\u8fd9\u91cc\u7684<code>curr</code>, and <code>prev</code>\u662f\u4e00\u4e2a\u6307\u9488, \u4ed6\u4eec\u6307\u5411\u7684\u662f\u4e00\u4e2anode\u7684\u5730\u5740. \u901a\u8fc7\u4ed6\u4eec\u4fe9\u4e4b\u95f4\u7684manipulation, \u4f60\u53ef\u4ee5\u6539\u53d8node\u7684\u6307\u5411</p> <p>\u7b2c\u4e8c\u4e2a\u5faa\u73af\u4e5f\u7c7b\u4f3c</p> <p></p> <p>\u7531\u6b64\u76f4\u5230<code>curr</code> pointer hits <code>null</code>,\u6700\u540e\u7684diagram\u5982\u4e0b\u56fe, \u8fd9\u65f6\u5019<code>curr</code> points to Null while <code>prev</code> is the new \"head\" for this reversed list. <code>return prev</code> </p> <p></p> <p>Time Complexity</p> <p>Time complexity: \\(O(n)\\) in time, \\(O(1)\\) in space</p>","tags":["Linked List","Recursion"]},{"location":"leetcode/206-reverse-linked-list/#code-implementation","title":"Code Implementation","text":"<pre><code># Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\nclass Solution:\n    def reverseList(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:\n\n        # Iteratative sotluon\n        # set up two pointer\n        prev = None\n        curr = head\n\n        while curr:\n            # assuming curr at node[i], prev at node[i-1], index convention\u662f\u6839\u636eold linked list\n\n            # construct a temo points to node[i+1]\n            temp = curr.next\n            # points node[i] to node[i-1]\n            curr.next = prev\n            # update prev from node[i-1] to node[i]\n            prev = curr\n            # update curr pointer to node[i+1] (for the old linked list)\n            curr = temp\n\n        # iteration\u7ed3\u675f\u65f6, curr\u5728null, prev\u662fnew head of the linked list\n        return prev\n</code></pre>","tags":["Linked List","Recursion"]},{"location":"leetcode/206-reverse-linked-list/#approach-2-recursive-solution","title":"Approach 2: recursive solution","text":"<p>\u548citerative solution\u7684\u4ece\u5934\u5f80\u524d\u7684\u601d\u8def\u4e0d\u540c, recursive solution\u662f\u4ece\u5c3e\u5f80\u524d\u7684\u601d\u8def. \u8fd9\u9898\u7684\u601d\u8def\u662f\uff0c\u628areverse\u6574\u4e2alinked list\u7684\u95ee\u9898\u8f6c\u5316\u4e3areverse\u4e00\u4e2anode\u7684\u95ee\u9898, \u5f53\u628a\u6240\u6709\u5b50\u95ee\u9898\u89e3\u51b3\u7684\u65f6\u5019\uff0c\u6574\u4e2a\u95ee\u9898\u4e5f\u5c31\u89e3\u51b3\u4e86.</p> <ul> <li><code>base case</code>: <code>head</code>\u4e3a<code>[]</code> or <code>[1]</code> \u8fd9\u4e24\u79cd\u60c5\u51b5\uff0c\u76f4\u63a5\u8fd4\u8fd8<code>head</code>\u5373\u53ef.</li> <li><code>recursive case</code>: \u9012\u5f52\u8c03\u7528<code>reverseList</code>\u51fd\u6570, \u76f4\u5230<code>head</code>\u6307\u5411\u6700\u540e\u4e00\u4e2anode\u65f6, \u5f00\u59cbpop function from stack.</li> </ul> <p>\u5982\u4e0b\u56fe\u6240\u793a, \u51fd\u6570\u4e0d\u65ad\u5806\u79ef\u5728call stack\u91cc\uff0c\u76f4\u5230<code>head</code>\u6307\u5411\u6700\u540e\u4e00\u4e2anode,\u7ec8\u4e8e\u6ee1\u8db3<code>head.next is None</code>, \u5f00\u59cbpop function from stack\u4e86</p> <p></p> <p>\u7136\u540e\u5c31\u5230\u4e86\u7b2c\u4e00\u4e2a\u975ebase case\u7684\u60c5\u51b5, \u8fd9\u65f6\u5019<code>head</code>\u6307\u5411\u7684\u662f\u5012\u6570\u7b2c\u4e8c\u4e2anode, <code>head.next</code>\u6307\u5411\u7684\u662f\u6700\u540e\u4e00\u4e2anode.</p> <ul> <li><code>head.next.next = head</code>: \u8fd9\u4e00\u6b65\u662f\u5173\u952e, \u4ed6\u662f\u628a<code>head</code>\u6307\u5411\u7684node\u7684next\u6307\u5411<code>head</code>\u672c\u8eab, \u8fd9\u6837\u5c31\u5b8c\u6210\u4e86reverse linked list\u7684\u64cd\u4f5c</li> <li><code>head.next = None</code>: \u65a9\u65ad\u5173\u7cfb, \u4f7f\u5f97<code>head</code>\u6307\u5411\u7684node\u7684next\u6307\u5411<code>None</code></li> </ul> <p></p> <p>Note</p> <p>\u8981\u6ce8\u610f\uff0c\u5176\u5b9e\u6bcf\u4e2afunction call\u90fd\u6709\u81ea\u5df1\u7684function scope, \u4ed6\u4eec\u4e4b\u95f4\u7684\u53d8\u91cf\u662f\u4e0d\u5171\u4eab\u7684. \u5b8c\u5168\u9760\u5404\u79cd<code>return</code>\u6765\u4f20\u9012\u6d88\u606f\uff0c\u5f53\u7136\u4e5f\u6709\u4e0d\u9760<code>return</code>\u4f20\u9012\u6d88\u606f\u7684\u65b9\u6cd5\uff0c\u6bd4\u5982<code>global head</code>\u6216\u8005<code>nonlocal head</code> keyword to declare variable <code>head</code> to be exempt from being constrained in function scope and push their privilege to global or enclosing scope. \u8fd9\u79cd\u601d\u8def\u89e3\u9898\u53ef\u4ee5\uff0c\u4f46\u4e0d\u9002\u5408industry level\u7684\u4ee3\u7801, \u7531\u4e8e\u4f1apollute global scope, \u4e5f\u4e0d\u5229\u4e8edebugging.</p>","tags":["Linked List","Recursion"]},{"location":"leetcode/206-reverse-linked-list/#code-implementation_1","title":"Code Implementation","text":"<pre><code># Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def reverseList(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:\n        # 1 --&gt; 2 --&gt; 3 --&gt; 4 --&gt; None\n        #             h\n        # 1 --&gt; 2 --&gt; 3 --&gt; 4 --&gt; 3\n        #             h\n        # 1 --&gt; 2 --&gt; 3 --None  4 --&gt; 3\n        #             h\n        # rearrange\n        # 1 --&gt; 2 --&gt; 3 &lt;-- 4\n        #             h\n\n        # base case\n        if not head:\n            return head\n        if not head.next:\n            return head\n        # sub-preblem: reverse a linkedlist that's one node smaller\n        p = self.reverseList(head.next)\n        head.next.next = head\n        head.next = None\n        return p        \n</code></pre> <p>Note</p> <p>\u8981\u6ce8\u610f\u7684\u662f\uff0cbase case\u91cc\u7684<code>if not head:</code>, \u5e76\u6ca1\u6709\u88ab\u7528\u4e8e\u9012\u5f52\u91cc. \u8fd9\u662f\u56e0\u4e3anumber of node\u6709\u53ef\u80fd\u4e3a0\u800c\u51fa\u7684edge case. </p>","tags":["Linked List","Recursion"]},{"location":"leetcode/206-reverse-linked-list/#reference","title":"Reference","text":"<ul> <li>animation of recursively reverse a linked list</li> </ul>","tags":["Linked List","Recursion"]},{"location":"leetcode/2073-time-needed-to-buy-tickets/","title":"2073 Time Needed to Buy Tickets","text":"","tags":["Array","Queue","Simulation"]},{"location":"leetcode/2073-time-needed-to-buy-tickets/#approach-1-one-pass","title":"Approach 1 One Pass","text":"<p>First round of intuition is that:</p> <ul> <li>if tickets[k] is min, then it's tickets[0] * n</li> <li>if tickets[k] is max, then it's sum(tickets)</li> <li>if tickets[k] is in between min and max of the array, there are some tricks can be done</li> </ul> <p>Or more precisely:</p> <ul> <li>for tickets[i] strictly smaller than tickets[k], take tickets[i]</li> <li>for tickets[i] strictly larger than tickets[k], take the tickets[k]</li> <li>for tickets[i] == tickets[k], take either tickets[k] or tickets[i]</li> </ul> <p>But one exception is that for the elements comes after the k, then we won't be going over them again,</p> <pre><code>            [         ]\n[84,49,5,24,70,77,87,8]\n         k\n</code></pre> <p>What's gonna happens is here if <code>tickets[i] &gt;= tickets[k] and i &gt; k</code>, we will decrement the total by 1.</p> <pre><code>class Solution:\n    def timeRequiredToBuy(self, tickets: List[int], k: int) -&gt; int:\n        \"\"\"\n        if tickets[k] is min, then it's tickets[0] * n\n        if tickets[k] is max, then it's sum(tickets)\n        if in between min and max of the array, do some tricks:\n            - for tickets[i] stricktly smaller than tickets[k], take tickets[i]\n            - for tickets[i] stricktly larger than tickets[k], take the tickets[k]\n            - for tickets[i] == tickets[k], take either\n        then we also need to count the \"last loop\"\n                    [         ]\n        [84,49,5,24,70,77,87,8]\n                 k\n        the ones in the brackets, should minimize one\n        \"\"\"\n        total = 0\n        for i in range(len(tickets)):\n            if tickets[i] &lt; tickets[k]:\n                total += tickets[i]               \n            else:\n                total += tickets[k]\n                if i &gt; k:\n                    total -= 1\n\n        return total\n</code></pre>","tags":["Array","Queue","Simulation"]},{"location":"leetcode/209-minimum-size-subarray-sum/","title":"209 Minimum Size Subarray Sum","text":"<p>sliding window + prefix sum (rolling in the deep)\u9898\u578b</p> <p>Follow up: If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log n).</p> <p>Follow up: \u5982\u679c\u4f60\u7684array\u4e2d\u5b58\u5728\u8d1f\u6570\uff0c\u4f60\u600e\u4e48\u8bf4?</p>","tags":["Array","Binary Search","Sliding Window","Prefix Sum"]},{"location":"leetcode/209-minimum-size-subarray-sum/#approach-1-sliding-window","title":"Approach 1: Sliding Window","text":"<p>\u7531\u4e8e\u5168\u662fpositive integers array, \u6240\u4ee5potentially\u53ef\u4ee5\u7528sliding window\u6765\u89e3\u51b3\u95ee\u9898. \u6211\u4eec\u5faa\u73af\u4e00\u4e2a\u6570\u7ec4\uff0c\u987a\u4fbf\u8bb0\u5f55\u4e00\u4e2arolling_sum, </p> <ul> <li>\u6bcf\u4e00\u6b65\uff0c\u6211\u4eec\u66f4\u65b0\u4e00\u4e0b\u6211\u4eec\u7684rolling_sum</li> <li>\u5224\u5b9a<code>while prefix_sum &gt;= target</code>, we move the left pointer to the right so we popping one element out of the window</li> </ul> <p>\u6211\u4eec\u4e0d\u9700\u8981check <code>whicle prefix_sun &gt;= target and l &lt;= r</code>, \u7531\u4e8e\u9898\u76ee\u7684constrains, </p> <ul> <li>1 &lt;= target &lt;= \\(10^9\\)</li> <li>1 &lt;= nums.length &lt;= \\(10^5\\)</li> <li>1 &lt;= nums[i] &lt;= \\(10^4\\)</li> </ul>","tags":["Array","Binary Search","Sliding Window","Prefix Sum"]},{"location":"leetcode/209-minimum-size-subarray-sum/#code-implementation","title":"Code Implementation","text":"<pre><code>class Solution:\n    def minSubArrayLen(self, target: int, nums: List[int]) -&gt; int:\n        # positive array so we can sliding window\n        # we eat element (moving right) when target not meet,\n        # we spit out element (moving left) when target has been met\n        # we kept a rolling sum\n\n        n = len(nums)\n        res = n+1\n        prefix_sum = 0\n\n        l = 0\n        for r,num in enumerate(nums):\n            prefix_sum += num\n            # \u4e0d\u9700\u8981\u62c5\u5fc3\u5de6\u8fb9\u754c\u8d85\u8fc7\u53f3\u8fb9\u754c\uff0c\u7531\u4e8econstrains.\n            while prefix_sum &gt;= target:\n                # update window size\n                res = min(res,r-l+1)\n\n                # we have to pop left till empty\n                prefix_sum -= nums[l]\n                l += 1\n\n\n        return res if res != n+1 else 0\n</code></pre>","tags":["Array","Binary Search","Sliding Window","Prefix Sum"]},{"location":"leetcode/209-minimum-size-subarray-sum/#approach-2-binary-search","title":"Approach 2: Binary Search","text":"<p>Link here.</p>","tags":["Array","Binary Search","Sliding Window","Prefix Sum"]},{"location":"leetcode/21-merge-two-sorted-lists/","title":"21. Merge Two Sorted Lists","text":"","tags":["Linked List","Recursion"]},{"location":"leetcode/21-merge-two-sorted-lists/#approach-1-iterative-approach","title":"Approach 1: iterative approach","text":"<p>merge two sorted list, as one of the most classic problem, \u6709\u633a\u591a\u6d4b\u8bd5\u7684\u70b9\u7684, \u9700\u8981\u4e0d\u65ad\u6bd4\u8f83\u4e24\u4e2a\u94fe\u8868\u4e2d\u7684\u6700\u5c0f\u503c,\u76f4\u5230\u4e00\u4e2a\u94fe\u8868reach null.</p> <p>\u5047\u8bbe\u4e24\u4e2a\u94fe\u8868\uff0c\u5b83\u4eec\u7684\u503c\u5206\u522b\u662f\\(a_i\\) and \\(b_i\\), respectively. \u6709\u9700\u8981\u7b80\u5316\u7684\u662f\uff0c\u5c06\\(a_i\\) = \\(b_i\\)\u7684\u60c5\u51b5\uff0c\u5f52\u5165\\(a_i\\)&lt;\\(b_i\\) \u7684\u60c5\u51b5</p> <ul> <li>\\(a_i\\) = \\(b_i\\) (\u8fd9\u79cd\u60c5\u51b5\u53ef\u4ee5\u5f52\u5165a&lt;b\u4e2d)</li> <li>\\(a_i\\) &lt; \\(b_i\\)</li> <li>\\(a_i\\) &gt; \\(b_i\\)</li> </ul> <p>\u5408\u5e76\u540e\u4e3a:</p> <ul> <li>\\(a_i\\leq\\) \\(b_i\\)</li> <li>\\(a_i &gt;\\) \\(b_i\\)</li> </ul> <p>\u7b97\u6cd5\u601d\u8def\u5982\u4e0b:</p> <ul> <li>create a dummy node as the start of result linked list</li> <li>create two pointers, <code>head</code> and <code>tail</code> which points to the start and end of the linked list respectively.</li> <li>compare \\(a_i\\) and \\(b_i\\) then,</li> <li>connect the <code>tail</code> with linked list with \\(min(a_i,b_i)\\) (in this step, you add one more node into your result linked list)</li> <li>advance the linked list with \\(min(a_i,b_i)\\)</li> <li>advance the tail by one</li> <li>append the remaining nodes to the <code>tail</code> of merged list</li> </ul>","tags":["Linked List","Recursion"]},{"location":"leetcode/21-merge-two-sorted-lists/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: \\(O(m+n)\\), m and n are the # of nodes in each linked list, respectively</li> </ul> <ul> <li>Space complexity: \\(O(1)\\)</li> </ul>","tags":["Linked List","Recursion"]},{"location":"leetcode/21-merge-two-sorted-lists/#code-implementation","title":"Code Implementation","text":"<pre><code># Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\nclass Solution:\n    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -&gt; Optional[ListNode]:\n\n        # create two dummy ListNode\n        tail = ListNode(None)\n\n        head = tail\n\n        # tip: \u5c0f\u7684\u5f80\u524d\u8d70\u4e00\u6b65\n        while list1 and list2:\n            if list1.val &lt;= list2.val:\n                # case: l1.val &lt;= l2.val\n                tail.next = list1\n                list1 = list1.next\n            else:\n                # case: l1.val &gt; l2.val \n                tail.next = list2\n                list2 = list2.next\n\n            # advance merged list by one\n            tail = tail.next\n\n        # \u5728\u8fd9\u4e2a\u9636\u6bb5,\u603b\u5171\u4e24\u79cd\u60c5\u51b5:\n        # 1. list1 is None, list2 != None\n        # 2. list2 is None, list1 != None\n        if list1 != None:\n            # list1\u4e2d\u5269\u4f59\u7684\u6570\uff0c\u90fd\u6bd4merged list\u4e2d\u7684\u5927\n            tail.next = list1\n        else:\n            # list2\u5269\u4f59\u7684\u6570\uff0c\u90fd\u6bd4merged list\u4e2d\u7684\u5927\n            tail.next = list2\n\n        return head.next\n</code></pre>","tags":["Linked List","Recursion"]},{"location":"leetcode/21-merge-two-sorted-lists/#approach-2-recursive-approach","title":"Approach 2: recursive approach","text":"<pre><code>class Solution:\n    def mergeTwoLists(self, l1, l2):\n        if l1 is None:\n            return l2\n        elif l2 is None:\n            return l1\n        elif l1.val &lt; l2.val:\n            l1.next = self.mergeTwoLists(l1.next, l2)\n            return l1\n        else:\n            l2.next = self.mergeTwoLists(l1, l2.next)\n            return l2\n</code></pre>","tags":["Linked List","Recursion"]},{"location":"leetcode/2108-find-the-first-palindromic-string-in-the-array/","title":"2108 Find First Palindromic String in the Array","text":"<p>too ez.</p> <pre><code>class Solution:\n    def firstPalindrome(self, words: List[str]) -&gt; str:\n        def is_palindrome(word):\n            left,right = 0,len(word)-1\n            while left &lt; right:\n                if word[left] != word[right]:\n                    return False\n                left += 1\n                right -= 1\n\n            return True\n\n        for word in words:\n            if is_palindrome(word):\n                return word\n\n        return \"\"\n</code></pre>","tags":["Array","Two Pointers","String","Palindrome"]},{"location":"leetcode/2149-rearrange-array-elements-by-sign/","title":"2149 Rearrange Array Elements by Sign","text":"<p>\u8fd9\u9898\u8bb2\u4e24\u4e2a\u89e3\u6cd5:</p> <ul> <li>with hash O(n) in space and time</li> <li>with two pointers O(n) in time and O(n) in space, </li> <li>\u6bd4approach 1\u5c11\u7528\u4e00\u4e2ahash</li> <li>\u5982\u679coutput space\u4e0d\u7b97\u7684\u8bdd\uff0c\u8fd9\u4e2a\u65b9\u6cd5\u662fO(1) in space</li> </ul>","tags":["Array","Two Pointers","Simulation"]},{"location":"leetcode/2149-rearrange-array-elements-by-sign/#approach-1-hash-on-in-space-and-time","title":"Approach 1 Hash \\(O(n)\\) in space and time","text":"<pre><code>class Solution:\n    def rearrangeArray(self, nums: List[int]) -&gt; List[int]:\n        hashmap = {\"p\":[],\"n\":[]}\n        for num in nums:\n            if num &gt; 0:\n                hashmap[\"p\"].append(num)\n            else:\n                hashmap[\"n\"].append(num)\n\n        res = []\n        half_length = int(len(nums)/2)\n        for i in range(half_length):\n            res.append(hashmap[\"p\"][i])\n            res.append(hashmap[\"n\"][i])\n\n        return res\n</code></pre>","tags":["Array","Two Pointers","Simulation"]},{"location":"leetcode/2149-rearrange-array-elements-by-sign/#approach-2-two-pointers-on-in-time-and-space","title":"Approach 2 two pointers \\(O(n)\\) in time and space","text":"<pre><code>class Solution:\n    def rearrangeArray(self, nums: List[int]) -&gt; List[int]:\n        n = len(nums)\n        res = [0 for _ in range(n)]\n\n        posi,nega = 0,1\n\n        for i in range(n):\n            if nums[i] &gt; 0:\n                res[posi] = nums[i]\n                posi += 2\n            else:\n                res[nega] = nums[i]\n                nega += 2\n        return res\n</code></pre>","tags":["Array","Two Pointers","Simulation"]},{"location":"leetcode/215-kth-largest-element-in-an-array/","title":"215 Kth Largest Element in an Array","text":"","tags":["Array","Divide and Conquer","Sorting","Heap (Priority Queue)","Quickselect"]},{"location":"leetcode/215-kth-largest-element-in-an-array/#approach-1-max-heap","title":"Approach 1 Max Heap","text":"<pre><code>from heapq import heappop,heapify\nclass Solution:\n    def findKthLargest(self, nums: List[int], k: int) -&gt; int:\n        neg_nums = [-num for num in nums]\n        heapify(neg_nums)\n\n        while k &gt; 0:\n            curr = heappop(neg_nums)\n            k -= 1\n\n        return -curr\n</code></pre>","tags":["Array","Divide and Conquer","Sorting","Heap (Priority Queue)","Quickselect"]},{"location":"leetcode/217-contains-duplicate/","title":"Intuition","text":"<p>Very classy way of using hash to find duplicate.</p>"},{"location":"leetcode/217-contains-duplicate/#approach","title":"Approach","text":"<p>\u7565</p>"},{"location":"leetcode/217-contains-duplicate/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: \\(O(n)\\) assuming good implemention of hash</li> </ul> <ul> <li>Space complexity: \\(O(1)\\)</li> </ul>"},{"location":"leetcode/217-contains-duplicate/#code","title":"Code","text":"<pre><code>class Solution:\n    def containsDuplicate(self, nums: List[int]) -&gt; bool:\n        #\n        hashtable = {}\n\n        for i in range(len(nums)):\n            # check if current element\n            if nums[i] in hashtable.keys():\n                return True\n\n            # assign key-value pair as value-index \n            hashtable[nums[i]] = i\n\n        return False\n</code></pre>"},{"location":"leetcode/219-contain-duplicate-II/","title":"219 Contains Duplicate II","text":"","tags":["Array","Hash Table","Sliding Window"]},{"location":"leetcode/219-contain-duplicate-II/#approach-1-hash-table","title":"Approach 1: Hash Table","text":"<p>\u7ef4\u62a4\u4e00\u4e2ahashtable, \u8bb0\u5f55\u6bcf\u4e2a\u6570\u5b57\u6700\u540e\u4e00\u6b21\u51fa\u73b0\u7684\u4f4d\u7f6e\uff0c\u5982\u679c\u5f53\u524d\u6570\u5b57\u5df2\u7ecf\u5728hashtable\u4e2d\uff0c\u4e14\u5f53\u524d\u4f4d\u7f6e\u548c\u4e0a\u4e00\u6b21\u51fa\u73b0\u7684\u4f4d\u7f6e\u7684\u8ddd\u79bb\u5c0f\u4e8e\u7b49\u4e8ek\uff0c\u90a3\u4e48\u5c31\u8fd4\u56deTrue\u3002</p> <pre><code>class Solution:\n    def containsNearbyDuplicate(self, nums: List[int], k: int) -&gt; bool:\n        # (key:value) as (value: last_seen_index)\n        hashtable = {}\n        for i,num in enumerate(nums):            \n            if num in hashtable and abs(i - hashtable[num]) &lt;= k:\n                return True\n            hashtable[num] = i\n        return False\n</code></pre>","tags":["Array","Hash Table","Sliding Window"]},{"location":"leetcode/219-contain-duplicate-II/#approach-2","title":"Approach 2: \u66b4\u529b","text":"<p>\u6211\u4e00\u5f00\u59cb\u60f3\u51fa\u6765\u7684solution, \u975e\u5e38\u810f. \u903b\u8f91\u662f\u7ef4\u62a4\u4e00\u4e2a\u7b26\u5408\u6761\u4ef6\u7684sliding window, size\u4e3a2k, \u7136\u540e\u4e0d\u65ad\u7684\u5403\u8fdb\u53bbright pointer, \u5410\u51fa\u6765left pointer. One-pass traversal\u65f6\u6bd4\u8f83\u5f53\u524d<code>nums[i]</code>\u662f\u5426\u5728window\u4e2d\u51fa\u73b0&gt;=2\u6b21.</p> <p>\u4f46\u8fd9\u4e2a\u89e3\u6cd5\u7684\u5f0a\u7aef\u662f:</p> <ul> <li>window\u548carray\u7684\u4e24\u4e2a\u8fb9\u754c\u9700\u8981handle. \u5bb9\u6613\u51fa\u9519</li> </ul> <pre><code>from collections import defaultdict\nclass Solution:\n    def containsNearbyDuplicate(self, nums: List[int], k: int) -&gt; bool:\n        \"\"\"\n        \u5c0f\u4e8e2k\u7684window\u4e4b\u4e2d\uff0c\u6709\u6ca1\u6709\u76f8\u540c\u7684\u6570\u5b57, \u904d\u5386n-k\u6b21\n        &lt;--  1 --&gt;       \n        [1,2,3,1]\n        \"\"\"\n        n = len(nums)\n        if n == 1:\n            return False\n\n        hashtable = defaultdict(int)\n\n        for i in range(min(n,k+1)):\n            hashtable[nums[i]] += 1\n\n        if hashtable[nums[0]] &gt; 1:\n            return True\n\n        for i in range(1,n):            \n            # left pop, right append\n            if i - k &gt;= 0:\n                hashtable[nums[i-k]] -= 1\n            if i + k &lt; n:\n                hashtable[nums[i+k]] += 1\n            if hashtable[nums[i]] &gt; 1:\n                return True\n        return False\n</code></pre>","tags":["Array","Hash Table","Sliding Window"]},{"location":"leetcode/2219-maximum-sum-score-of-array/","title":"2219 Maximum Sum Score of Array","text":"<p>\u91cd\u70b9\u5728\u4e8eApproach 2 one-pass solution, \u5229\u7528\u4e86<code>max()</code>\u662fcommutative\u7684\u6027\u8d28\uff0c\u53ef\u4ee5\u5728\u4e00\u6b21\u904d\u5386\u4e2d\u627e\u5230\u6700\u5927\u503c\u3002</p>","tags":["Array","Prefix Sum"]},{"location":"leetcode/2219-maximum-sum-score-of-array/#approach-1-two-pass","title":"Approach 1: two pass","text":"<p>we can maintain two variables that:</p> <ul> <li><code>prefix_sum</code>: starts at <code>nums[0]</code>, keep adding <code>nums[i]</code>.</li> <li><code>suffix_sum</code>: starts at <code>sum(nums)</code>, keep substracting <code>nums[i]</code></li> </ul> <p>one pass for <code>sum(nums)</code>, another pass for traversing the array.</p> <pre><code>class Solution:\n    def maximumSumScore(self, nums: List[int]) -&gt; int:\n        \"\"\"\n        [4,3,],[-2,5]\n        one pass solution by maintaining prefix_sum and suffix_sum        \n        \"\"\"\n        n = len(nums)\n\n        prefix,suffix = nums[0],sum(nums)\n        res = max(prefix,suffix)\n        for i in range(1,n):\n            prefix += nums[i]\n            suffix -= nums[i-1]\n            res = max(res,max(prefix,suffix))\n        return res\n</code></pre>","tags":["Array","Prefix Sum"]},{"location":"leetcode/2219-maximum-sum-score-of-array/#approach-2-one-pass","title":"Approach 2: one pass","text":"<p>At each index, we need to compare two value, for every index <code>i</code> in nums, we need to compare a total of n pairs, which is <code>2n</code> values in total, and we are trying to find the global maximum among <code>2n</code> variables. We can save the cost of <code>sum(nums)</code> by this trick.</p> <pre><code>class Solution:\n    def maximumSumScore(self, nums: List[int]) -&gt; int:\n        prefix = suffix = 0\n        res = -inf\n\n        n = len(nums)\n        for i in range(n):\n            prefix += nums[i]\n            suffix += nums[n-i-1]\n            res = max(res,prefix,suffix)\n\n        return res\n</code></pre>","tags":["Array","Prefix Sum"]},{"location":"leetcode/226-invert-binary-tree/","title":"Problem","text":"<p>Given the <code>root</code> of a binary tree, invert the tree, and return its root.</p> <p></p>"},{"location":"leetcode/226-invert-binary-tree/#solution","title":"Solution","text":"<p>The idea is to do the BFS but instead of regular left to right. We do it from right to left.</p> <p></p>"},{"location":"leetcode/226-invert-binary-tree/#code","title":"Code","text":"<pre><code># Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nfrom collections import deque\nclass Solution:\n    def invertTree(self, root: Optional[TreeNode]) -&gt; Optional[TreeNode]:\n\n        if root is None: return None\n\n        inverted_root = TreeNode(val = root.val)\n        inverted_queue = deque([inverted_root])\n\n        queue = deque([root])\n\n        while queue:\n            for _ in range(len(queue)):\n                curr = queue.popleft()\n                inverted_curr = inverted_queue.popleft()\n\n                # right append left, left append right\n                if curr.right: \n                    queue.append(curr.right)\n                    inverted_curr.left = TreeNode(curr.right.val)\n                    inverted_queue.append(inverted_curr.left)\n\n                if curr.left: \n                    queue.append(curr.left)\n                    inverted_curr.right = TreeNode(curr.left.val)\n                    inverted_queue.append(inverted_curr.right)\n\n\n        return inverted_root\n</code></pre>"},{"location":"leetcode/231-power-of-two/","title":"231 Power of Two","text":"<p>\u8fd9\u9898\u4e09\u79cd\u89e3\u6cd5\uff0c\u91cd\u70b9\u638c\u63e1bit manipulation\u7684</p> <ul> <li>loop</li> <li>recursion</li> <li>bit manipulation</li> </ul> <p>\u5229\u7528\u7684\u6027\u8d28\u662f\uff0c\u5982\u679c\u4e00\u4e2a\u6570<code>n</code>\u80fd\u88ab\u8868\u793a\u6210\\(2^x\\), where \\(x\\in \\mathbb{N^*}\\), \u90a3\u4e48\u9664\u4e86x = 0, \u5176\u5b83x\u90fd\u6ee1\u8db3<code>n &amp; (n-1) == 0</code>. \u8fd9\u4e2a\u6027\u8d28\u53ef\u4ee5\u7528\u6765\u5224\u65ad\u4e00\u4e2a\u6570\u662f\u5426\u662f2\u7684\u5e42\u6b21\u65b9\u3002</p>","tags":["Bit Manipulation","Recursion","Math"]},{"location":"leetcode/231-power-of-two/#approach-1-loop","title":"Approach 1 loop","text":"<p>\u5224\u65ad\u5bf9\u4e8e\u4e00\u4e2ainteger <code>n</code>, \u662f\u5426\u5b58\u5728\u53e6\u4e00\u4e2ainterger <code>x</code> \u4f7f\u5f97 \\(2^x = n\\)\uff0c\u90a3\u4e48\u4f60\u7684solution\u5c31\u53ea\u80fd\u662f,</p> <p>$$ 2^x \\quad x\\in \\mathbb{N^{*}}  $$ where \\(\\mathbb{N}^{*}\\) is \u6b63\u6574\u6570.</p> <p>Tip</p> <p>\u6ce8\u610f\uff0c\u5728\u8ba1\u7b97\u673a\u548c\u96c6\u5408\u8bba\u4e2d\uff0c\\(\\mathbb{N}\\) \u5b9a\u4e49\u4e3a\u5305\u62ec0\u7684\u6b63\u6574\u6570. \u4f46\u5728\u6570\u8bba\u4e2d\uff0c\\(\\mathbb{N}\\) \u5b9a\u4e49\u4e3a\u4e0d\u5305\u62ec0\u7684\u6b63\u6574\u6570. \u6240\u4ee5\u5728\u8fd9\u91cc\u505a\u4e86\u533a\u5206\u3002Conventionally, \\(\\mathbb{N^0}\\) is used to denote the set of non-negative integers, \\(\\mathbb{N}^{*}\\) for positive integers. \u5982\u679c\u4f60\u60f3\u4e25\u8c28\u4e00\u4e9b\u7684\u8bdd.</p> <p>\u65e2\u7136\u7ed3\u679c\u80af\u5b9a\u662f, <code>{1, 2, 4, 8, 16...}</code>, \u6211\u7684\u601d\u8def\u662f\u8bbe\u8ba1\u4e00\u4e2a\u4ece0\u4e0d\u65ad\u4e58\u4ee52\u7684\u5faa\u73af\uff0c\u76f4\u5230\u627e\u5230\u4e00\u4e2a\u6570\u7b49\u4e8en\uff0c\u6216\u8005\u8d85\u8fc7n.</p> <pre><code>class Solution:\n    def isPowerOfTwo(self, n: int) -&gt; bool:\n        counter = 0\n        bar = 2**counter\n\n        while bar &lt;= n:\n            if bar == n:\n                return True\n            counter += 1\n            bar = 2**counter\n\n        return False\n</code></pre>","tags":["Bit Manipulation","Recursion","Math"]},{"location":"leetcode/231-power-of-two/#follow-up-wo-looprecursion","title":"Follow-up: w/o loop/recursion","text":"<p>\u80fd\u5426\u4e0d\u7528loop\u6216\u8005recursion\u6765\u6c42\u5462? \u5bf9\u4e8e2\u7684\u5e42\u6b21\u65b9\uff0c\u6709\u4e00\u4e2a\u5feb\u901f\u5224\u65ad\u7684trick, \u4e5f\u5c31\u662f<code>&amp;</code> operator\u7684\u6027\u8d28, \u5148\u770b\u5982\u4e0b\u8868</p> \\(2^x\\) in binary \\(2^x - 1\\) in binary \\(2^0 = 1\\) 0001 \\(2^0 -1 = 0\\) 0000 \\(2^1 = 2\\) 0010 \\(2^1 -1 = 1\\) 0001 \\(2^2 = 4\\) 0100 \\(2^2 -1 = 3\\) 0011 \\(2^3 = 8\\) 1000 \\(2^3 -1 = 7\\) 0111 \\(2^4 = 16\\) 10000 \\(2^4 -1 = 15\\) 01111 \\(2^5 = 32\\) 100000 \\(2^5 -1 = 31\\) 011111 <p>\u6211\u4eec\u968f\u4fbf\u53d6\u4fe9\u505a\u4e2a\u8ba1\u7b97, \u6bd4\u5982<code>2=0010</code> and <code>1=0001</code> <pre><code>    0010\n  &amp; 0001\n    ------\n    0000\n</code></pre></p> <p>\u5bf9\u4e8e\u4e00\u4e2apower of two\u7684\u6570\uff0c\u5b83\u7684\u4e8c\u8fdb\u5236\u8868\u793a\u4e2d\u53ea\u6709\u4e00\u4e2a1\uff0c\u6240\u6709\u5176\u4ed6\u4f4d\u90fd\u662f0. \u6240\u4ee5\u5b83\u51cf\u53bb1\u7684\u8bdd\uff0c\u5c31\u662flower bits\u90fd\u662f1. \u6240\u4ee5\u5b83\u4eec\u7684<code>&amp;</code>\u64cd\u4f5c\u7ed3\u679c\u5c31\u662f0.</p> <pre><code>class Solution:\n    def isPowerOfTwo(self, n: int) -&gt; bool:\n        \"\"\"\n        1:          0:\n        01          00\n        2:          1:\n        10          01\n        4:          3:\n        100         011\n        8:          7:\n        1000        0111\n        16          15:\n        10000       01111\n\n        so for n = 2^x, we always have the properties that n &amp; (n-1) == 0\n        \"\"\"\n        if n &lt;= 0: return 0\n        return n &amp; (n-1) == 0\n</code></pre>","tags":["Bit Manipulation","Recursion","Math"]},{"location":"leetcode/232-implement-queue-using-stacks/","title":"232 implement queue using stacks","text":"<ul> <li>Intuition</li> <li>Approach1: O(n) in push, O(1) in pop</li> <li>Approach 2: O(1) in push, O(1) in pop</li> </ul>"},{"location":"leetcode/232-implement-queue-using-stacks/#intuition","title":"Intuition","text":"<p>The question ask for implementing a queue using stacks. The key point is to use existing methods of stacks to simulate the queue.\u5148\u6765\u590d\u4e60\u4e00\u4e0bstack\u548cqueue\u7684\u533a\u522b</p> <p></p> <p>peek()method\u540d\u5b57\uff0c\u4e3a\u770b\u4e00\u4e0b\u9a6c\u4e0a\u8981\u88abpop or dequeue\u51fa\u53bb\u7684\u5143\u7d20\u662f\u4ec0\u4e48\uff0c\u4f46\u662f\u4e0d\u4f1a\u771f\u7684pop\u51fa\u53bb</p>"},{"location":"leetcode/232-implement-queue-using-stacks/#approach1-on-in-push-o1-in-pop","title":"Approach1: O(n) in push, O(1) in pop","text":"<p>\u56e0\u4e3a\u8981\u75282\u4e2astack\u6765\u6a21\u62dfqueue\uff0c\u6240\u4ee5\u5728push\u7684\u65f6\u5019\uff0c - \u9700\u8981\u628as1\u91cc\u7684\u5143\u7d20\u90fdpop\u51fa\u6765\uff0cpush\u5230s2\u91cc\uff0c - \u7136\u540e\u518d\u628a\u65b0\u5143\u7d20push\u5230s2\u91cc\uff0c - \u6700\u540e\u518d\u628as2\u91cc\u7684\u5143\u7d20\u90fdpop\u51fa\u6765\uff0cpush\u5230s1\u91cc\u3002</p> <p>\u5176\u5b83\u7684functionality like pop or peek, \u5c31\u662f\u76f4\u63a5\u64cd\u4f5cs1\u5373\u53ef.</p> <p>\u6700\u96be\u7684push, \u4f60\u53ef\u4ee5\u62bd\u8c61\u6210spring coil like, s1\u662f\u5de6\u8fb9\u5f39\u7c27\uff0c\u4f60\u5148\u628a\u5b83\u79fb\u52a8\u5230\u53f3\u8fb9s2, \u4f60\u52a0\u5165\u65b0\u5143\u7d20\uff0c\u4f60\u518d\u79fb\u52a8\u56de\u6765</p> <p></p> <p>Approach 1\u5177\u4f53\u56fe\u89e3\u5982\u4e0b </p> <pre><code>class MyQueue:\n    def __init__(self):\n        self.s1 = []\n        self.s2 = []\n\n    def push(self, x: int) -&gt; None:\n        while self.s1:\n            self.s2.append(self.s1.pop())\n        self.s1.append(x)\n        while self.s2:\n            self.s1.append(self.s2.pop())\n\n    def pop(self) -&gt; int:\n        return self.s1.pop()\n\n    def peek(self) -&gt; int:\n        return self.s1[-1]\n\n    def empty(self) -&gt; bool:\n        return not self.s1\n\n\n# Your MyQueue object will be instantiated and called as such:\n# obj = MyQueue()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.peek()\n# param_4 = obj.empty()\n</code></pre>"},{"location":"leetcode/232-implement-queue-using-stacks/#approach-2-o1-in-push-o1-in-pop","title":"Approach 2: O(1) in push, O(1) in pop","text":"<p>\u8fd9\u4e2a\u6709\u70b9tricky,  - \u5229\u7528s1\u7684tail, \u6765\u6a21\u62dfqueue\u7684tail, \u8fdb\u884cenqueue - \u5229\u7528s2\u7684tail, \u6765\u6a21\u62dfqueue\u7684head, \u8fdb\u884cdequeue and peek</p> <p></p> <pre><code>class MyQueue:\n    def __init__(self):\n        self.s1 = []\n        self.s2 = []\n\n    def push(self, x: int) -&gt; None:\n        self.s1.append(x)\n\n    def pop(self) -&gt; int:\n        self.peek()\n        return self.s2.pop()\n\n    def peek(self) -&gt; int:\n        # when s2 is empty\n        if not self.s2:\n            while self.s1:\n                self.s2.append(self.s1.pop())        \n        return self.s2[-1]\n\n    def empty(self) -&gt; bool:\n        return not self.s1 and not self.s2\n</code></pre>"},{"location":"leetcode/234-palindrome-linked-list/","title":"234 Palindrome Linked List","text":"<p>follow-up</p> <p>follow-up, \u8981\u6c42\\(O(n)\\) in time, \\(O(1)\\) in space\u7684\u89e3\uff0c\u57282021\u5e74\u4f5c\u4e3afacebook\u7684\u9762\u8bd5\u9898\u51fa\u73b0\uff0c\u95ee\u6700\u4f18\u89e3.</p> <p>\u7b80\u7ea6\u4f46\u4e0d\u7b80\u5355, \u6570\u5b66\u7684\u5316\u5f52\u601d\u60f3\uff0c\u53ef\u4ee5\u628a\u8fd9\u4e2a\u95ee\u9898\u8f6c\u5316\u95ee\u5df2\u77e5\u7684\u95ee\u9898, \u6bd4\u5982</p> <ul> <li>125 Valid Palindrome</li> <li>206 Reverse Linked List</li> </ul> <p>\u60f3\u5230\u8fd9\u4e24\u70b9\u662f\u6210\u529f\u7684\u4e00\u534a\uff0cvalid palindrome\u5f88\u5bb9\u6613\u60f3\u5230\uff0c\u4f46\u662freverse linked list\u4f60\u60f3\u5230\u7684\u6982\u7387\u4f1a\u5c0f\u4e0d\u5c11. </p>","tags":["Linked List","Two Pointers","Stack","Recursion"]},{"location":"leetcode/234-palindrome-linked-list/#approach-1-to-array","title":"Approach 1 to array","text":"<p>\u6309\u7167wisdom peak\u7684\u8bdd\uff0c\u8fd9\u9898\u89e3\u6cd5\u8fd8\u4e0d\u591f\u4f18\u79c0.</p> <p>complexity</p> <ul> <li>Time complexity: \\(O(n)\\)</li> <li>Space complexity: \\(O(n)\\)</li> </ul> <pre><code># Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def isPalindrome(self, head: Optional[ListNode]) -&gt; bool:        \n        if not head:\n            return False\n\n        res = []\n        curr = head\n        while curr:\n            res.append(curr.val)\n            curr = curr.next\n\n        left,right = 0,len(res)-1\n        while left &lt; right:\n            if res[left] != res[right]:\n                return False\n            left += 1\n            right -= 1\n\n        return True\n</code></pre>","tags":["Linked List","Two Pointers","Stack","Recursion"]},{"location":"leetcode/234-palindrome-linked-list/#approach-2-in-place-reverse","title":"Approach 2: in-place reverse","text":"<p>\u8fd9\u4e2a\u89e3\u6cd5\u5305\u62ec\u4e86\u4ee5\u4e0b\u51e0\u4e2a\u6280\u5de7:</p> <ul> <li><code>two runner pointer</code></li> <li><code>reverse a linked list</code></li> </ul> <p>Note</p> <p>in-place algo, \u5728concurrent setting\u4f1alock\u8fd9\u4e2ainput till the operation on the input is done\uff0c\u8fd9\u662fin-place algo\u7684\u901a\u75c5</p> <p>\u8fd9\u4e00\u9898\u7684\u5177\u4f53\u601d\u8def\u5982\u4e0b\uff1a</p> <ul> <li>write two helper functions:<ul> <li><code>def reverse(self,head)</code>: return reversed linked list</li> <li><code>def mid_node(self,head)</code>: \u627e\u5230linked list\u4e2d\u70b9</li> </ul> </li> <li>reverse the 2nd half of the linked list</li> <li>use <code>two pointers</code> to compare the first half and 2nd half from start to end</li> <li>restore the linked list by re-reverse the 2nd half</li> </ul> <p>Tip</p> <p><code>\u5feb\u6162\u6307\u9488</code>\u6709\u51e0\u4e2a\u4f5c\u7528, </p> <ul> <li>\u5feb\u6307\u9488\u901f\u5ea6\u662f\u6162\u6307\u9488\u4e24\u500d\uff0c\u53ef\u4ee5determine <code>mid node</code> and <code>end node</code>. Generally, \u6211\u4eec\u53ef\u4ee5\u627e\u52301/3\u70b9\uff0c1/4\u70b9\uff0c1/5\u70b9\u7b49\u7b49 with different speed multiplier</li> <li>cycle detection</li> </ul>","tags":["Linked List","Two Pointers","Stack","Recursion"]},{"location":"leetcode/234-palindrome-linked-list/#step1-two-helper-functions","title":"Step1: two helper functions","text":"<p>For the <code>def reverse(self,head)</code>, refers to 206 reverse a linked list.</p> <p>For the <code>def mid_node(self,head)</code>, \u6709\u4e24\u79cd\u601d\u8def:</p> <ul> <li>traverse with counter, then do floor division to get mid node</li> <li>\u5feb\u6162\u6307\u9488</li> </ul> <p>\u5feb\u6162\u6307\u9488technique\u8bbe\u7f6e\u4e86\u4e24\u4e2apointer moving at different pace, \u7531\u4e8e\u6211\u4eec\u662f\u8981\u627e\u4e2d\u70b9\uff0c\u6240\u4ee5\u8bbe\u7f6e\u7684\u4e24\u4e2apointer, and they are <code>slow</code> and <code>fast</code> pointer, respectively. <code>fast</code>\u5411\u524dadvancing\u7684\u901f\u5ea6\u6bd4<code>slow</code>\u5feb\u4e24\u500d, illustrated in the figure below</p> <p></p> <p>It stops until one of the next two nodes after <code>fast</code> is <code>null</code></p> <p>\u6ce8\u610f,\u7531\u4e8epanlindom linked list\u90fd\u62e5\u6709\u5076\u6570\u4e2anodes\uff0c\u6240\u4ee5slow pointer\u4f1a\u505c\u5728\u524d\u534a\u6bb5\u7684\u6700\u540e\u4e00\u4e2a.</p> <p>\u4e3e\u4e2a\u4f8b\u5b50,\u5982\u679c\u4f60\u7684<code>head = [1,2,3,4]</code> at beginning, \u90a3\u4e48<code>slow = [2,3,4]</code> </p>","tags":["Linked List","Two Pointers","Stack","Recursion"]},{"location":"leetcode/234-palindrome-linked-list/#step2-reverse-the-2nd-half-of-the-linked-list","title":"Step2: reverse the 2nd half of the linked list","text":"<p>\u7531\u4e8eslow pointer\u505c\u5728\u524d\u534a\u6bb5\u6700\u540e\u4e00\u4e2a\uff0creverse from slow pointer\u4f1a\u9020\u6210\u5982\u56fe\u7684\u666f\u8c61;</p> <p></p> <p>\u5982\u679c\u4f60\u7684<code>head = [1,2,3,4]</code> at beginning, \u90a3\u4e48<code>slow = [2,3,4]</code> ,\u7136\u540e\u4f60reverse\u4e86slow with <code>rev_half = self.reverse(slow)</code>,\u4f60\u7684pointer\u5c31\u4f1a\u53d8\u5316\u5982\u4e0b:</p> <ul> <li><code>head = [1,2]</code></li> <li><code>slow = [2]</code></li> <li><code>rev_half = [4,3,2]</code></li> </ul> <p>\u8fd9\u79cd\u60c5\u51b5node with value 2\u88ab\u4e24\u4e2a\u94fe\u8868\u540c\u65f6\u5360\u6709\uff0c\u540c\u65f6<code>slow</code> pointer\u6b63\u597d\u6307\u5411last non-null node in both linked list.</p>","tags":["Linked List","Two Pointers","Stack","Recursion"]},{"location":"leetcode/234-palindrome-linked-list/#step3-compare-two-linked-list","title":"Step3: compare two linked list","text":"<p>\u8fd9\u4e00\u6b65\u5f88\u7b80\u5355\uff0c\u53ea\u9700\u8981traverse\u4e24\u4e2alist, \u9010\u4e2a\u6bd4\u8f83\u5c31\u53ef\u4ee5\u4e86\uff0c\u6ce8\u610f\u7531\u4e8e\u524d\u534a\u94fe\u8868\u6c38\u8fdc\u6bd4\u540e\u534a\u94fe\u8868\u5c11\u4e00\u4e2anode, \u5faa\u73af\u6761\u4ef6\u8981\u6ce8\u610f</p> <p></p>","tags":["Linked List","Two Pointers","Stack","Recursion"]},{"location":"leetcode/234-palindrome-linked-list/#step4-restore","title":"Step4: restore","text":"<p>It's a good practice to restore the input <code>head</code> since <code>head</code> might also be used in other functions.</p> <p><code>self.reverse(second_half)</code> \u5c31\u53ef\u4ee5\u4e86,\u56e0\u4e3a\u5b83\u4f1a\u4fee\u6539second half linked list, \u5f53\u4f60\u7528\u6307\u9488<code>head</code>\u6765traverse\u65f6\uff0c\u539f\u5148\u7684\u65ad\u70b9\u5df2\u7ecf\u88ab\u4fee\u590d\u4e86</p> <p></p> <p>Complexity</p> <ul> <li>Time complexity: \\(O(n)\\) </li> <li>Space complexity: \\(O(1)\\)</li> </ul>","tags":["Linked List","Two Pointers","Stack","Recursion"]},{"location":"leetcode/234-palindrome-linked-list/#code-implementation","title":"Code Implementation","text":"<pre><code># Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def isPalindrome(self, head: Optional[ListNode]) -&gt; bool:\n        \"\"\"\n        1. reverse the half of linked list\n        1 -&gt; 2 -&gt; 2 -&gt; 1\n        1 -&gt; 2 -&gt; 1 -&gt; 2\n        i.        j\n\n        1 -&gt; 2 -&gt; 3 -&gt; 2 -&gt; 1\n\n        1.1 finding the middle index\n        1.2 reverse linked list\n\n        2. reverse it!!\n        3. use two separate pointers on two array to traverse to determine if it's palindrom\n        4. restore it\n        \"\"\"\n        def get_mid(head):\n            end = head\n            mid = head\n            while end and end.next:\n                mid = mid.next\n                end = end.next.next\n            return mid\n\n        def reverse(head):\n            if not head:\n                return None                \n            curr,prev = head,None\n            while curr:\n                temp = curr.next\n                curr.next = prev\n                prev = curr\n                curr = temp\n\n            return prev\n\n        mid = get_mid(head)\n        mid_head = reverse(mid)\n\n        left = head\n        right = mid_head\n\n        flag = True\n        while left and right:\n            if left.val != right.val:\n                flag = not flag\n                break\n            left = left.next\n            right = right.next\n\n        # we have to reverse the likedin list back no matter what we return\n        reverse(mid_head)\n\n        return flag\n</code></pre>","tags":["Linked List","Two Pointers","Stack","Recursion"]},{"location":"leetcode/237-delete-node-in-a-linked-list/","title":"237 Delete Node in a Linked List","text":"","tags":["Linked List"]},{"location":"leetcode/237-delete-node-in-a-linked-list/#approach-1","title":"Approach 1:","text":"<p>\u79fb\u9664node\u7684\u4e24\u4e2a\u65b9\u6cd5:</p> <ul> <li><code>Approach 1</code>: given only <code>node</code>, \u5c06node\u7684\u503c\u66ff\u6362\u4e3a\u4e0b\u4e00\u4e2anode\u7684\u503c\uff0c\u7136\u540e\u8df3\u8fc7\u4e0b\u4e00\u4e2anode<ul> <li>node.val = node.next.val</li> <li>node.next = node.next.next</li> </ul> </li> <li><code>Approach 2</code>: \u53cc\u6307\u9488\u6cd5, \u5c06node\u7684\u4e0a\u4e00\u4e2a\u6307\u9488\u6307\u5411\u4e0b\u4e00\u4e2anode. given <code>head</code> of linked list and <code>node</code> to delete<ul> <li>prev.next = node.next</li> <li>\u8fd9\u4e2a\u65b9\u6cd5\u9700\u8981generalize treatment for first node and interior node. \u52a0\u4e00\u4e2adummy header node\u53ef\u4ee5\u7b80\u5316\u8fd9\u4e2a\u95ee\u9898</li> </ul> </li> </ul>","tags":["Linked List"]},{"location":"leetcode/237-delete-node-in-a-linked-list/#code-implementation","title":"Code Implementation","text":"<pre><code># Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def deleteNode(self, node):\n        \"\"\"\n        :type node: ListNode\n        :rtype: void Do not return anything, modify node in-place instead.\n        \"\"\"\n        node.val = node.next.val\n        node.next = node.next.next\n</code></pre>","tags":["Linked List"]},{"location":"leetcode/2370-longest-ideal-subsequence/","title":"2370 Longest Ideal Subsequence","text":"","tags":["Hash Table","String","Dynamic Programming"]},{"location":"leetcode/2370-longest-ideal-subsequence/#approach-1-tle","title":"Approach 1 TLE","text":"<p>Same as LIS, but input size is \\(10^5\\), which means it only takes up to \\(O(n)\\) or \\(O(nlogn)\\) time complexity. This one is \\(O(n^2)\\), so it will TLE.</p> <pre><code>class Solution:\n    def longestIdealString(self, s: str, k: int) -&gt; int:\n        n = len(s)\n        dp = [1 for _ in range(n)]\n\n        for i in range(1,n):\n            for j in range(i):\n                if abs(ord(s[i]) - ord(s[j])) &lt;= k:\n                    dp[i] = max(dp[i],dp[j]+1)\n\n        return max(dp)\n</code></pre>","tags":["Hash Table","String","Dynamic Programming"]},{"location":"leetcode/2370-longest-ideal-subsequence/#approach-2","title":"Approach 2","text":"<p><code>abcda</code> and <code>abcca</code> has the same length. Whether it's a valid subsequence or not, only depends on the most adjacent pair, so our state can be simplified to a 26 x 26 size array.</p> <p></p> <p>We only need 26 x 26 states to describe all the possible subsequence. However, we can simplify it even further to a 1-D array of 26. Since we don't really even care the first character, we only care about the previous character to see if we can insert anything into it. Therefore, a 1D array is enough to describe the state.</p> <pre><code>dp = [0] * 26\n</code></pre> <p>Algorithm:</p> <ul> <li>initialize an array of 26 with zeros. indicate we haven't seen any character yet.</li> <li>iterate through the string \\(O(n)\\)<ul> <li>iterate through every alphabets character, we find the longest previous character that can be inserted into it \\(O(26)\\)</li> <li>update the current character's value with the candidate (previous character + 1)</li> <li>update the result to the maximum value of the current character</li> </ul> </li> </ul>","tags":["Hash Table","String","Dynamic Programming"]},{"location":"leetcode/2370-longest-ideal-subsequence/#code-implementation","title":"Code Implementation","text":"<pre><code>class Solution:\n    def longestIdealString(self, s: str, k: int) -&gt; int:\n        \"\"\"\n        - highly likely a DP since subsequence;\n        - \u8111\u8865\u4e00\u4e0b\u7684\u8bdd\uff0c\u662f\u4e00\u6761\u66f2\u6298\u7684\u7ebf\uff0c\u7136\u540e\u753by = a to y = a+k \u4e4b\u95f4\u6240\u6709\u7684\u7ebf\uff0c\u627e\u5230\u7ecf\u8fc7\u6700\u591a\u7684\u4ea4\u70b9;\n        \"\"\"\n        n = len(s)\n        dp = [0] * 26\n        res = 0\n        for i in range(n):\n            curr = ord(s[i]) - ord('a')\n            best = 0\n            # \u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\uff0c\u4e0a\u4e00\u4e2a\u6700\u5927\u7684\u503c\n            for prev in range(26):\n                if abs(prev - curr) &lt;= k:\n                    best = max(best,dp[prev])\n            # subsequence ending with s[i], update it\n            dp[curr] = max(dp[curr],best+1)\n            res = max(res,dp[curr])\n        return res\n</code></pre>","tags":["Hash Table","String","Dynamic Programming"]},{"location":"leetcode/238-product-of-array-except-self/","title":"238 Product of Array Except Self","text":"<p>\u8fd9\u9898requirements\u592a\u4e0d\u5408\u7406\u4e86</p> <ul> <li>O(n) in time and without using the division operation.</li> </ul>","tags":["Array","Prefix Sum"]},{"location":"leetcode/238-product-of-array-except-self/#approach-1-on-in-time-on-in-space","title":"Approach 1 O(n) in time, O(n) in space","text":"<p>There is a pattern that if the nums contains</p> <ul> <li>0 zero, you don't worry about division by zeros</li> <li>1 zero, only that <code>nums[i] = 0</code>, so only <code>ans[i] != zero</code></li> <li>2 zeros, <code>ans[i] = [0]*len(nums)</code></li> </ul> <p>You can use hashmap + above pattern to solve this problem</p> <pre><code>class Solution:\n    def productExceptSelf(self, nums: List[int]) -&gt; List[int]:\n        # trick: \n        # no zeros, do the rolling product\n        # 1 zeros, fill value at that index and fill others zero\n        # 2 zeros, fill with zeros\n        hashmap = set()\n        for i in range(len(nums)):\n            if nums[i] == 0:\n                hashmap.add(i)\n\n        product = 1\n        ans = [0 for _ in range(len(nums))]\n        if len(hashmap) == 1:\n            # 1 zero in nums\n            zero_index = hashmap.pop()\n            for i in range(len(nums)):\n                if i != zero_index:\n                    product *= nums[i]\n            # assign value to the only value that is not equal to zeros\n            ans[zero_index] = int(product)\n        elif len(hashmap) == 0:\n            # no zeros in nums            \n            # initialize\n            for i in range(1,len(nums)):\n                product *= nums[i]\n            ans[0] = product\n            # update\n            for curr in range(1,len(nums)):\n                product = product * nums[curr-1] / nums[curr]\n                ans[curr] = int(product)\n\n        # do nothing for &gt;= 2 zeros\n        return ans\n</code></pre>","tags":["Array","Prefix Sum"]},{"location":"leetcode/238-product-of-array-except-self/#approach-2-on-in-time-o1-in-space","title":"Approach 2 O(n) in time, O(1) in space","text":"<p>With the trick above, you don't even need to use hashmap. Just use a counter to count the number of zeros in the nums. </p> <pre><code>class Solution:\n    def productExceptSelf(self, nums: List[int]) -&gt; List[int]:\n        num_of_zeros = 0\n        zero_index = -1\n        for i in range(len(nums)):\n            if nums[i] == 0:\n                num_of_zeros += 1\n                zero_index = i\n\n        product = 1\n        ans = [0 for _ in range(len(nums))]\n        if num_of_zeros == 1:\n            # 1 zero in nums\n            for i in range(len(nums)):\n                if i != zero_index:\n                    product *= nums[i]\n            # assign value to the only value that is not equal to zeros\n            ans[zero_index] = int(product)\n        elif num_of_zeros == 0:\n            # no zeros in nums            \n            # initialize\n            for i in range(1,len(nums)):\n                product *= nums[i]\n            ans[0] = product\n            # update\n            for curr in range(1,len(nums)):\n                product = product * nums[curr-1] / nums[curr]\n                ans[curr] = int(product)\n\n        # do nothing for &gt;= 2 zeros\n        return ans\n</code></pre>","tags":["Array","Prefix Sum"]},{"location":"leetcode/239-sliding-window-maximum/","title":"239 Sliding Window Maximum","text":"","tags":["Array","Queue","Sliding Window","Monotonic Queue","Heap (Priority Queue)"]},{"location":"leetcode/239-sliding-window-maximum/#approach-1-brute-force","title":"Approach 1: Brute Force","text":"<p>Brute force solution would be slicing every window and take the maximum of each window. The time complexity would be <code>O(n*k)</code> where <code>n</code> is the length of the array and <code>k</code> is the window size.</p>","tags":["Array","Queue","Sliding Window","Monotonic Queue","Heap (Priority Queue)"]},{"location":"leetcode/239-sliding-window-maximum/#approach-2-monotonic-queue","title":"Approach 2: Monotonic Queue","text":"<p>\u65e2\u7136\u662f\u6c42sliding window\u6700\u5927\u503c\uff0c\u6211\u4eec\u53ef\u4ee5\u7528\u4e00\u4e2amonotonically decreasing\u7684queue\u6765\u7ef4\u62a4window\u5185\u7684\u6700\u5927\u503c\u548c\u5355\u8c03\u6027. </p> <pre><code>queue: storing the \"index\" for an decreasing monotonic queue. \nres: \u8bb0\u5f55max index for monotonic queue\n</code></pre> <p>\u53ef\u4ee5\u5206\u6210\u4e24\u4e2a\u90e8\u5206:</p> <ul> <li>\u521d\u59cb\u5316\u7b2c\u4e00\u4e2awindow<ul> <li>\u5982\u679c\u65b0\u5143\u7d20\u6bd4queue\u4e2d\u7684\u6700\u540e\u4e00\u4e2a\u5143\u7d20\u5927\uff0cpop\u6389\u6700\u540e\u4e00\u4e2a\u5143\u7d20\uff0c\u76f4\u5230queue\u88ab\u6e05\u7a7a\u6216\u8005\u65b0\u5143\u7d20\u6bd4queue\u4e2d\u7684\u6700\u540e\u4e00\u4e2a\u5143\u7d20\u5c0f</li> <li>\u8bb0\u5f55queue\u4e2d\u7684\u7b2c\u4e00\u4e2a\u5143\u7d20\u5230res\u4e2d, \u6b64\u65f6res\u957f\u5ea6\u4e3a1</li> </ul> </li> <li>\u4ece\u7b2c2\u4e2a to \u7b2c(n-k+1)\u4e2a window<ul> <li>\u5982\u679cqueue\u4e2d\u7684\u7b2c\u4e00\u4e2a\u5143\u7d20\u5df2\u7ecf\u79bb\u5f00\u5f53\u524dwindow, pop\u6389\u7b2c\u4e00\u4e2a\u5143\u7d20</li> <li>\u5982\u679c\u65b0\u5143\u7d20\u6bd4queue\u4e2d\u7684\u6700\u540e\u4e00\u4e2a\u5143\u7d20\u5927\uff0cpop\u6389\u6700\u540e\u4e00\u4e2a\u5143\u7d20\uff0c\u76f4\u5230queue\u88ab\u6e05\u7a7a\u6216\u8005\u65b0\u5143\u7d20\u6bd4queue\u4e2d\u7684\u6700\u540e\u4e00\u4e2a\u5143\u7d20\u5c0f</li> <li>\u628a\u65b0\u5143\u7d20\u7684index\u52a0\u5165queue</li> <li>\u8bb0\u5f55queue\u4e2d\u7684\u7b2c\u4e00\u4e2a\u5143\u7d20\u5230res\u4e2d, res\u957f\u5ea6 +1 \u76f4\u5230res\u957f\u5ea6\u4e3an-k+1</li> </ul> </li> </ul> <p>Note</p> <ul> <li>time complexity: \\(O(n)\\) \u770b\u4e0a\u53bb\u50cf\u662ffor + while loop, \u4f46\u5b9e\u9645\u4e0aworst case scenario\u662f\u6bcf\u4e2a\u5143\u7d20\u90fd\u8fdb\u51faqueue\u4e00\u6b21\uff0c\u6240\u4ee5\u662f\\(O(2n) \\approx O(n)\\)</li> <li>space complexity: \\(O(k)\\), queue\u7684\u6700\u5927\u957f\u5ea6\u4e3ak</li> </ul>","tags":["Array","Queue","Sliding Window","Monotonic Queue","Heap (Priority Queue)"]},{"location":"leetcode/239-sliding-window-maximum/#code-implementation","title":"Code Implementation","text":"<pre><code>from collections import deque\nclass Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -&gt; List[int]:\n        # \u6c42\u6bcf\u4e00\u4e2awindow\u4e2d\u7684\u6700\u5927\u503c\uff0c\u6240\u7ec4\u6210\u7684Array.\n        queue = deque()\n        res = []\n        n = len(nums)\n\n        # initialize the initial monotonic queue (in the first window of size k)\n        for i in range(k):\n            # pop \u961f\u5217\u4e2d\u5c0f\u4e8e\u65b0\u5143\u7d20nums[i]\u7684\u503c, \u76f4\u5230\u7ed3\u675f\n            while queue and nums[i] &gt;= nums[queue[-1]]:\n                queue.pop()\n            queue.append(i)\n\n        res.append(nums[queue[0]])\n\n        for i in range(k,n):\n            # \u6bd4\u8f83queue\u6700\u5de6\u8fb9\u503c\u662f\u5426\u5df2\u7ecf\u79bb\u5f00window\n            if queue and queue[0] == i-k:\n                queue.popleft()\n            while queue and nums[i] &gt;= nums[queue[-1]]:\n                queue.pop()\n            # enque\n            queue.append(i)\n            res.append(nums[queue[0]])\n\n        return res\n</code></pre>","tags":["Array","Queue","Sliding Window","Monotonic Queue","Heap (Priority Queue)"]},{"location":"leetcode/24-swap-nodes-in-pairs/","title":"24 Swap Nodes in Pairs","text":"","tags":["Linked List","Recursion"]},{"location":"leetcode/24-swap-nodes-in-pairs/#approach-1-recursion-approach","title":"Approach 1: recursion approach","text":"<pre><code># Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:\n        # base case\n        if not head or not head.next:\n            return head\n\n        # define node to be swapped\n        first_node = head\n        second_node = head.next\n\n        # swapping\n        first_node.next = self.swapPairs(second_node.next)\n        second_node.next = first_node\n\n        return second_node\n</code></pre>","tags":["Linked List","Recursion"]},{"location":"leetcode/24-swap-nodes-in-pairs/#approach-2-iteration-approach-use-of-three-pointer","title":"Approach 2: iteration approach (use of three pointer)","text":"<p>\u6211\u4e00\u5f00\u59cb\u7684\u5199\u7684\u4ee3\u7801\u6ca1\u6709\u8003\u8651\u5230rejoining previous node with newly swapped node.\u53ea\u8003\u8651\u4e86\u7528two pointer swap.</p> <p>swapping elements in array\u4e0b\u610f\u8bc6\u7684\u60f3\u5230\u4e24\u70b9\uff1a</p> <ul> <li>two pointer technique</li> </ul> <p>swapping elements in linked list, \u8981\u8003\u8651\u5230rejoining,</p> <ul> <li>3 pointer technique</li> </ul> <p>swapping and rejoining phase\u56fe\u89e3</p> <p></p> <p>update pointer\u56fe\u89e3, \u8981\u77e5\u9053swap node\u4e4b\u540e\uff0cpointer <code>left</code> and <code>right</code> \u8fd8\u662f\u6307\u5411\u539f\u6765\u7684node, \u6240\u4ee5\u968f\u7740node\u4f4d\u7f6e\u7684\u6539\u53d8\uff0c\u4e5f\u5728\u6539\u53d8.</p> <p></p> <p>complexity</p> <ul> <li>Time complexity: \\(O(n)\\), you only scan once</li> <li>Space complexity: \\(O(1)\\)</li> </ul>","tags":["Linked List","Recursion"]},{"location":"leetcode/24-swap-nodes-in-pairs/#code","title":"Code","text":"<pre><code># Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:\n        # three pointer technique, \u5728swap\u7684\u65f6\u5019\uff0c\u9700\u8981\u7b2c\u4e09\u4e2apointer\n\n        # check for edge cases\n        if head is None or head.next is None:\n            return head\n\n        # set up a dummy node \n        dummy = ListNode(None)\n        dummy.next = head\n\n        # initialze three nodes\n        prev = dummy\n\n        while head and head.next:\n            # advanced left and right node from the\n            left = head\n            right = head.next\n\n            # swap nodes and rejoin\n            left.next = right.next\n            right.next = left\n            prev.next = right\n\n            # update the prev and head node for the next time step\n            prev = left\n            head = prev.next\n\n\n            # update head to the new position\n        return dummy.next\n</code></pre>","tags":["Linked List","Recursion"]},{"location":"leetcode/24-swap-nodes-in-pairs/#codeiteration-with-only-two-pointer","title":"Code(iteration with only two pointer)","text":"<p>\u8fd9\u4e2a\u6bd4\u8f83\u5de7\u5999\uff0c\u8282\u7ea6\u4e86\u4e00\u4e2apointer, \u4f46\u6211\u5e76\u4e0d\u63a8\u8350\uff0c\u56e0\u4e3a\u4f1a\u8ba9\u4ee3\u7801\u770b\u8d77\u6765\u66f4\u590d\u6742,\u548cthree pointer method\u6709\u4e00\u4e2a\u533a\u522b: - <code>while head and head.next</code> in three pointer, <code>while curr and curr.next</code> in two pointer, \u524d\u8005\u662f\u9700\u8981\u4e0d\u65adupdate <code>prev</code> and <code>head</code> pointer\u6240\u4ee5\u624d\u5224\u5b9a<code>while head</code>, \u540e\u8005\u662f\u53eaupdate <code>curr</code> and <code>prev</code>. \u672c\u8d28\u4e0a\u5dee\u4e0d\u591a, \u4f46\u7528\u524d\u8005\u7684\u65b9\u6cd5\uff0chead pointer\u7531\u4e8e\u4e0d\u65adupdate, \u4f1a\u6307\u5411<code>None</code>, \u4e5f\u5c31\u662f\u6539\u53d8\u4e86input.</p> <p>\u5177\u4f53\u56fe\u89e3\u5982\u4e0b,\u5de6\u8fb9\u662fthree pointer, \u53f3\u8fb9\u53ea\u7528\u4e86\u4fe9pointer</p> <p></p> <p>\u4ee3\u7801\u5982\u4e0b <pre><code># Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:\n        # set up a dummy ListNode\n        dummyNode = ListNode(None)\n        dummyNode.next = head\n\n        # set up two pointers for swapping and rejoining\n        prev = dummyNode\n        curr = head\n\n        # \u5047\u8bbedummy node\u4e3anode0, \u4e4b\u540e\u7684node\u547d\u540d\u4e3anode1,2,3...\n        while curr and curr.next:\n            # \u76f4\u63a5\u5f00\u59cbswap\u4e86 \n\n            # connect node0 with node 2\n            prev.next = curr.next\n            # connect node 1 with node 3\n            curr.next = prev.next.next\n            # connect node 2 with node 1\n            prev.next.next = curr\n            # end: \u73b0\u5728\u7684\u987a\u5e8f\u662f node 0, node 2, node 1 and curr points to node 1\n\n            # reset pointer for next time step\n            prev = curr\n            curr = curr.next\n\n        return dummyNode.next\n</code></pre></p>","tags":["Linked List","Recursion"]},{"location":"leetcode/242-valid-anagram/","title":"Intuition","text":"<p>\u5224\u65ad\u4e24\u4e2astring\u662f\u5426\u4e92\u4e3aanagram\u7684\u4f9d\u636e\u4e3a, \u5176\u4e2d\u6bcf\u4e2a<code>char</code>\u51fa\u73b0\u7684 \u6b21\u6570\u90fd\u76f8\u540c\u5373\u53ef, \u90a3\u53ea\u9700\u8981\u6784\u5efa\u4e00\u4e2ahash\u6765\u50a8\u5b58key-value pair: - <code>key</code>: character in the string. \u4f8b\u5b50 s= 'abcd'\u5219\u8fd9\u4e2ahash\u4e00\u5171\u6709\u56db\u4e2akey - <code>value</code>: the occurance of the key in the string. \u4f8b\u5b50 s= 'abcc'\u5219 </p> <pre><code>hash = {\n    'a' :1,\n    'b' :1,\n    'c': 2 #\u4ee3\u8868\u51fa\u73b0\u4e86\u4e24\u6b21\n}\n</code></pre> <p>Harry potter: <code>I am Lord Voldemort</code> and <code>Tom Marvolo Riddle</code> \u5f7c\u6b64\u5c31\u662fanagram.</p>"},{"location":"leetcode/242-valid-anagram/#approach","title":"Approach","text":"<pre><code>graph LR\n    s &amp; t --&gt; function\n    function --&gt; |s and t\u5f7c\u6b64\u4e92\u4e3aanagram|True\n    function --&gt; |s and t\u5f7c\u6b64\u4e0d\u4e92\u4e3aanagram|False</code></pre> <p>\u5177\u4f53\u6b65\u9aa4\u5982\u4e0b\uff1a - \u6784\u5efa\u4e00\u4e2aempty hash - traverse through string <code>s</code>, \u5c06\u6bcf\u4e2acharacter\u51fa\u73b0\u7684\u6b21\u6570\u7d2f\u52a0\u5230value\u4e0a - traverse through string <code>t</code>, \u6bcf\u4e2astring t \u4e2dchar\u51fa\u73b0\u4e00\u6b21\uff0chash \u5bf9\u5e94\u7684value \u51cf\u53bb1</p>"},{"location":"leetcode/242-valid-anagram/#complexity","title":"Complexity","text":"<p>\u5047\u8bbes\u548ct\u7684\u5927\u5c0f\u7cfb\u6570\u7528\u4e00\u4e2a<code>n</code></p> <ul> <li>Time complexity: \\(O(n) + O(n) + O(n) \\approx O(n)\\)</li> </ul> <ul> <li>Space complexity: \\(O(n)\\) \u9700\u8981\u6784\u5efa\u4e00\u4e2ahash;  </li> </ul>"},{"location":"leetcode/242-valid-anagram/#code","title":"Code","text":"<pre><code>class Solution:\n    def isAnagram(self, s: str, t: str) -&gt; bool:\n\n        # hash\u50a8\u5b58key-value pair \n        # key: every distinct char\n        # value: \u8be5char\u5728string\u4e2d\u51fa\u73b0\u7684\u603b\u6b21\u6570\n        hashtable = {}\n\n        # iterate through string s \n        for i in range(len(s)):\n            # \u5224\u65ad\u8be5char\u662f\u5426\u5728\u91cc\u9762, \u5982\u679c\u5728\uff0c\u7d2f\u52a0\u4e00\u6b21\n            if s[i] in hashtable.keys():\n                hashtable[s[i]] += 1\n            else:\n                # \u8be5char\u7b2c\u4e00\u6b21\u51fa\u73b0 \n                hashtable[s[i]] = 1\n\n        for j in range(len(t)):\n            if t[j] in hashtable.keys():\n                hashtable[t[j]] -= 1\n            else:\n                # \u5728string t\u4e2d\u53d1\u73b0\u4e86new char, \u4e0d\u662fanagram\n                return False\n\n        # \n        for item in hashtable:\n            # \u5982\u679c\u6709\u54ea\u4e00\u4e2avalue, \u4e0d\u662f0, \u5219\u8bf4\u660e\u591a\u51fa\u73b0\u4e86\u6216\u8005\u5c11\u51fa\u73b0\u4e86\u4e00\u6b21\n            if hashtable[item] != 0:\n                return False\n\n        return True\n</code></pre>"},{"location":"leetcode/243-shortest-word-distance/","title":"Intuition","text":"<p>\u601d\u8def\u53ea\u60f3\u5230brute force, \u8fd8\u7528\u5230\u4e86auxillary data structure <code>list()</code>, \u4f18\u5316\u601d\u8def\u662fone-pass solution, \u7531\u4e8e\u4f60\u53ea\u611f\u5174\u8da3\u6700\u77ed\u8ddd\u79bb\uff0c\u4f60\u53ea\u9700\u8981traverse one time, \u6bcf\u4e00\u6b21\u90fdupdate\u6700\u65b0\u7684match word\u7684\u4fe1\u606f\uff0c\u8fd9\u6837\u7684\u8bdd\u4f60\u6bcf\u6b21\u6bd4\u8f83\u7684\u90fd\u662f\u8ddd\u79bb\u6700\u8fd1\u7684\u4e24\u4e2amatches\u7684\u8ddd\u79bb\uff0c\u5c31\u7f29\u5c0f\u4e86search space;</p>"},{"location":"leetcode/243-shortest-word-distance/#approach","title":"Approach","text":"<ul> <li>\u8bbe\u7f6e\u4e09\u4e2aint <code>i</code>,<code>j</code> for word in wordsDict match word1 and word2's index, respectively. <code>minimumLength</code> for minimum length</li> <li>traverse the array once \u7136\u540e\u5206\u522b\u5224\u65ad\u548cupdate\u4f60match word1 and word2\u7684\u4fe1\u606f;</li> <li>\u6bd4\u8f83;</li> </ul>"},{"location":"leetcode/243-shortest-word-distance/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: O(nm), n is the length of the Array, m is the total length of the String word1 and word2 (\u7531\u4e8e\u9700\u8981\u6bd4\u8f83\u6765\u7740)</li> </ul> <ul> <li>Space complexity: O(1)</li> </ul>"},{"location":"leetcode/243-shortest-word-distance/#code","title":"Code","text":"<pre><code>class Solution {\n    public int shortestDistance(String[] wordsDict, String word1, String word2) {\n        // one pass Solution\n        // traverse the soluton one time only\n        int i = -1;\n        int j = -1;\n        int minimumLength = wordsDict.length;\n\n        for (int index = 0; index &lt; wordsDict.length; index++) {\n            // mark occurence of word1\n            if (wordsDict[index].equals(word1)) {\n                i = index;\n            }\n\n            // mark occurence\n            if (wordsDict[index].equals(word2)) {\n                j = index;\n            }\n\n            //always comparing the closest occurence of both words\n            if (i != -1 &amp;&amp; j != -1){\n                // emulate math.abs()\n                int currentLength = i - j;\n                if (currentLength &lt; 0) {\n                    currentLength *= -1;\n                }\n\n                // update current length\n                if (currentLength &lt; minimumLength) {\n                    minimumLength = currentLength;\n                }\n\n                // optimization, no need to go further if minimumLength is one\n                if (minimumLength == 1) {\n                    return minimumLength;\n                }\n            }\n        }\n\n\n        return minimumLength;\n    }\n}\n</code></pre> <p>Follow-up: what about max distance? how to decrease search space</p>"},{"location":"leetcode/2441-largest-possible-integer/","title":"2441 Largest Positive Integer That Exists With Its Negative","text":"","tags":["Array","Hash Table","Two Pointers","Sorting"]},{"location":"leetcode/2441-largest-possible-integer/#approach-1-sorting-two-pointers","title":"Approach 1: Sorting + two pointers","text":"<pre><code>from heapq import heapify, heappush,heappop\nclass Solution:\n    def findMaxK(self, nums: List[int]) -&gt; int:\n        \"\"\"\n        objective:\n        - find the largest positive negative pair (1,-1)\n        observation:        \n        - it doesn't contain zero\n        solution 1:\n        - maintain a max heap and a min heap, keep popping the \n        the last value until meet be the same, O(n) in time &amp; space.\n        solution 2:\n        - sort it, then two pointer O(nlogn) O(1)\n        \"\"\"\n        nums.sort()\n\n        l,r = 0,len(nums)-1\n        found = False\n        res = None\n        while l &lt; r:\n            # not possible case\n            if nums[l] &gt;0 or nums[r] &lt; 0:\n                break         \n            # base case\n            if nums[l] == -nums[r]:\n                found = True\n                res = nums[r]\n                break\n\n            # going the absolutely smaller one\n            if abs(nums[l]) &lt; abs(nums[r]):\n                r -= 1\n            else:\n                l += 1\n        if found:\n            return res\n        else:\n            return -1\n</code></pre>","tags":["Array","Hash Table","Two Pointers","Sorting"]},{"location":"leetcode/2444-count-subarrays-with-fixed-bounds/","title":"2444 Count Subarrays With Fixed Bounds","text":"<p>\u53cd\u601d</p> <p>\u6bd4\u8d5b\u65f6\u7684\u9519\u8bef\u662f\u60f3, \u6211\u60f3\u5230\u4e86monotonic queue or heap, \u4f46\u6211\u9009\u62e9\u4e86heap+hashmap\u7684\u65b9\u5f0f\u6765\u89e3\u51b3\uff0c\u4f46\u88ab\u600e\u4e48pop historical heap properly\u7ed9\u5361\u4f4f\u4e86. hard\u7684sliding window, \u5728constrains\u4e3a\\(10^5\\), \u9996\u5148\u8fd8\u662f\u8003\u8651O(n)\u89e3\u6cd5\uff0c\u90a3\u4e48\u5c31\u53ea\u53ef\u80fd\u662fmonotonic queue or sliding window with two pointers\u4e86. </p>","tags":["Array","Queue","Sliding Window","Monotonic Queue"]},{"location":"leetcode/2444-count-subarrays-with-fixed-bounds/#approach-1-sliding-window","title":"Approach 1 Sliding Window","text":"<p>Hard\u7ea7\u522b\u7684sliding window, \u901a\u5e38involve three pointers, \u4e14\u6bcf\u4e00\u4e2a\u5b50\u95ee\u9898\u901a\u5e38involve\u88ab\u4e09\u6307\u9488\u5206\u5272\u540e\u7684subarray\u8fdb\u884cmanipulation. \u8fd9\u9898\u7ef4\u62a4\u7684\u4e09\u6307\u9488\u662f:</p> <ul> <li><code>left_bound</code>: \u7528\u6765\u8bb0\u5f55\u4e0dvalid\u7684subarray\u7684\u5de6\u8fb9\u754c\uff0c\u4e5f\u5c31\u662f\u9047\u5230value outside of minK and maxK\u7684\u65f6\u5019\uff0c\u6211\u4eec\u9700\u8981\u5c06left_bound\u66f4\u65b0\u5230\u5f53\u524d\u7684right. \u8fd9\u4e00\u6b65\u7684\u539f\u56e0\u662f\uff0c\u6211\u4eec\u5e76\u4e0d\u4fdd\u8bc1minK and maxK\u662farray-level\u7684min\u548cmax, \u6240\u4ee5\u6709\u53ef\u80fd\u6709\u6bd4\u5176\u66f4\u5927\u6216\u66f4\u5c0f\u7684\u6570.</li> <li><code>min_position</code>: \u7528\u6765\u8bb0\u5f55most recent value == minK\u7684index</li> <li><code>max_position</code>: \u7528\u6765\u8bb0\u5f55most recent value == maxK\u7684index</li> </ul> <p></p> <p>\u901a\u8fc7\u4e0a\u8ff0\u4e09\u6307\u9488\uff0c\u6211\u4eec\u53ef\u4ee5\u5206\u89e3\u5b50\u95ee\u9898,\u6bcf\u4e00\u6b65\u53c8\u53ef\u4ee5\u5206\u6210\u4e24\u4e2a\u5c0f\u95ee\u9898 (n*2\u4e2atotal):</p> <ul> <li>\u5728\u4ee50\u4f4d\u7ed3\u5c3e\u7684index\u4e4b\u4e2d\uff0c\u627e\u51fa\u7b26\u5408\u6761\u4ef6\u7684\u6700\u5927subarray - \u7b26\u5408\u6761\u4ef6\u7684\u6700\u5c0fsubarray</li> <li>\u5728\u4ee51\u4f4d\u7ed3\u5c3e\u7684index\u4e4b\u4e2d\uff0c\u627e\u51fa\u7b26\u5408\u6761\u4ef6\u7684\u6700\u5927subarray - \u7b26\u5408\u6761\u4ef6\u7684\u6700\u5c0fsubarray</li> <li>...</li> <li>\u5728\u4ee5n-1\u4f4d\u7ed3\u5c3e\u7684index\u4e4b\u4e2d\uff0c\u627e\u51fa\u7b26\u5408\u6761\u4ef6\u7684\u6700\u5927subarray - \u7b26\u5408\u6761\u4ef6\u7684\u6700\u5c0fsubarray</li> </ul> <p>rephrase\u4e00\u4e0b\u6211\u4eec\u7684\u5b50\u95ee\u9898:</p> <ul> <li>\u4ee50\u4e3a\u7ed3\u5c3e\u7684subarray\u4e2d\uff0c<ul> <li>\u627e\u51fa\u4e00\u4e2a\u6700\u5927\u7684array such that \u8fd9\u4e2aarray\u4e2d\u7684min and max is <code>minK</code> and <code>maxK</code> respectively</li> <li>\u627e\u51fa\u4e00\u4e2a\u6700\u5c0f\u7684array such that \u8fd9\u4e2aarray\u4e2d\u7684min and max is <code>minK</code> and <code>maxK</code> respectively</li> </ul> </li> <li>\u4ee51\u4e3a\u7ed3\u5c3e\u7684subarray\u4e2d\uff0c<ul> <li>\u627e\u51fa\u4e00\u4e2a\u6700\u5927\u7684array such that \u8fd9\u4e2aarray\u4e2d\u7684min and max is <code>minK</code> and <code>maxK</code> respectively</li> <li>\u627e\u51fa\u4e00\u4e2a\u6700\u5c0f\u7684array such that \u8fd9\u4e2aarray\u4e2d\u7684min and max is <code>minK</code> and <code>maxK</code> respectively</li> </ul> </li> <li>...</li> </ul> <p>\u6700\u5927\u7684array\u53ef\u4ee5\u7528<code>left_bound</code>\u6765\u8ba1\u7b97\uff0c\u6700\u5c0f\u7684array\u53ef\u4ee5\u7528most recent <code>min_position</code> and <code>max_position</code>\u6765\u8ba1\u7b97.</p> <p>At <code>right = 10</code>\u7684\u56fe\u89e3\u5982\u4e0b,</p> <p></p>","tags":["Array","Queue","Sliding Window","Monotonic Queue"]},{"location":"leetcode/2444-count-subarrays-with-fixed-bounds/#code-implementation","title":"Code Implementation","text":"<pre><code>class Solution:\n    def countSubarrays(self, nums: List[int], minK: int, maxK: int) -&gt; int:\n        \"\"\"\n        observation:\n        - \u6ca1\u6709\u63d0minK and maxK are array-level min and max, \u6240\u4ee5\u6709\u53ef\u80fd\u6709\u6bd4\u5176\u66f4\u5927\u6216\u66f4\u5c0f\u7684\u6570\n        Break it down:\n        - find the maximum subarray ending at index 0 that the max and min of this subarray is equal to minK and maxK\n        \"\"\"\n        res = 0\n        left_bound = -1\n        min_position = max_position = -1\n\n        for right,num in enumerate(nums):\n            # we found outside, we remove them all\n            if num &lt; minK or num &gt; maxK:\n                left_bound = right\n\n            if num == minK:\n                min_position = right\n            if num == maxK:\n                max_position = right\n\n            res += max(0,min(min_position,max_position) - left_bound)\n\n        return res\n</code></pre>","tags":["Array","Queue","Sliding Window","Monotonic Queue"]},{"location":"leetcode/2485-find-the-pivot-integer/","title":"2485 Find the Pivot Integer","text":"<p>Brute force\u4e3alinear scan, \u7136\u540e\u66b4\u529b\u6c42\u548c, O(n^2). \u4f46\u662f\u8fd9\u9898\u6709\u4e00\u4e2atrick, \u5c31\u662f\u53ef\u4ee5\u7528prefix sum\u6765\u4f18\u5316.</p>","tags":["Math","Prefix Sum"]},{"location":"leetcode/2485-find-the-pivot-integer/#approach-1-prefix-sum","title":"Approach 1 Prefix Sum","text":"<p>\u8fd9\u9898\u7684pivot integer, \u5c31\u662f\u627e\u5230\u4e00\u4e2aindex \\(x\\), \u4f7f\u5f97\u8fd9\u4e2aindex\u5de6\u8fb9\u7684\u548c\u7b49\u4e8e\u53f3\u8fb9\u7684\u548c. \u6ee1\u8db3\u7684\u6761\u4ef6\u662f  $$ \\begin{equation} 1 + 2 + 3 + ... + x = x + (x+1) + (x+2) + ... + n \\end{equation} $$ \u662f\u4e00\u4e2aboth ends inclusive\u7684range sum. <code>[i...x] == [x .. n]</code>, \u5728linear scan\u65f6\u5019\uff0c\u53ef\u4ee5maintain\u4e24\u4e2a\u53d8\u91cf</p> <ul> <li>prefix_sum: \u4ece1\u5230i\u7684\u548c</li> <li>suffix_sum: \u4ecei\u5230n\u7684\u548c</li> </ul> <p>\u6bcf\u6b21\u66f4\u65b0\u65f6, prefix_sum\u52a0\u4e0a\u5f53\u524dindex, suffix_sum\u7531\u4e8e\u9700\u8981\u4fdd\u6301inclusive, suffix_sum\u7684\u66f4\u65b0\u9700\u8981\u51cf\u53bbprevious index. \u5982\u679c\u4e24\u8005\u76f8\u7b49, \u5219\u8fd4\u56de\u5f53\u524dindex.</p> <pre><code>class Solution:\n    def pivotInteger(self, n: int) -&gt; int:\n        # 1 + 2 ... + x == x + (x+1) + ... + n\n        # at most 1 pivot index, else return -1\n\n        prefix = 0\n        suffix = (1 + n)*n//2\n\n        for i in range(1,n+1):\n            prefix += i\n            suffix -= (i-1)\n            if prefix == suffix:\n                return i\n\n        return -1\n</code></pre>","tags":["Math","Prefix Sum"]},{"location":"leetcode/2487-remove-nodes-from-linked-list/","title":"2487 Remove Nodes From Linked List","text":"<p>\u4e24\u4e2a\u89e3\u6cd5:</p> <ul> <li>monotonic stack, \u7ef4\u62a4\u4e00\u4e2a\u5355\u8c03\u9012\u51cf\u7684stack, \u7528\u6765\u5b58\u50a8\u4fdd\u7559\u7684node, \u4e4b\u540erebuild. \u65f6\u95f4\u590d\u6742\u5ea6O(n), \u7a7a\u95f4\u590d\u6742\u5ea6O(n)</li> <li>reverse, \u6700\u4f18\u89e3\uff0c\u4f46\u662f\u9700\u8981modify input linked list in-place. \u65f6\u95f4\u590d\u6742\u5ea6O(n), \u7a7a\u95f4\u590d\u6742\u5ea6O(1)</li> </ul>","tags":["Linked List","Stack","Recursion","Monotonic Stack"]},{"location":"leetcode/2487-remove-nodes-from-linked-list/#approach-1-monotonic-stack","title":"Approach 1: Monotonic Stack","text":"","tags":["Linked List","Stack","Recursion","Monotonic Stack"]},{"location":"leetcode/2487-remove-nodes-from-linked-list/#code-implementation","title":"Code Implementation","text":"<pre><code># Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def removeNodes(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:\n        stack = []\n        curr = head\n\n        while curr:\n            while stack and curr.val &gt; stack[-1].val:\n                stack.pop()\n            stack.append(curr)\n            curr = curr.next\n        # rebuild the linkedlist\n        dummy = ListNode(None,None)\n        curr = dummy\n\n        for node in stack:\n            curr.next = node\n            curr = node\n        return dummy.next\n</code></pre>","tags":["Linked List","Stack","Recursion","Monotonic Stack"]},{"location":"leetcode/2487-remove-nodes-from-linked-list/#approach-2-reverse","title":"Approach 2: Reverse","text":"<p>\u5bf9\u4e8e\u6bcf\u4e00\u4e2anode\u6765\u8bf4\uff0c\u662f\u5426\u9700\u8981\u5220\u9664\uff0c\u53ea\u9700\u8981\u770b\u5b83\u7684\u53f3\u8fb9\u662f\u5426\u6709\u6bd4\u5b83\u66f4\u5927\u7684node\u5373\u53ef\uff0c\u5982\u4e0b\u56fe,</p> <p></p> <p>\u663e\u7136\u53d1\u7740traverse\u6bd4\u8f83\u65b9\u4fbf\uff0c\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5:</p> <ul> <li>\u5148reverse linked list</li> <li>\u4ece\u5de6\u5230\u53f3traverse, \u5982\u679c\u53f3\u8fb9\u6709\u6bd4\u5f53\u524dnode\u66f4\u5927\u7684node, \u5219\u5220\u9664\u5f53\u524dnode</li> <li>\u6700\u540e\u518dreverse\u56de\u6765</li> </ul>","tags":["Linked List","Stack","Recursion","Monotonic Stack"]},{"location":"leetcode/2487-remove-nodes-from-linked-list/#code-implementation_1","title":"Code Implementation","text":"<pre><code># Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def removeNodes(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:\n        def reverse(head):\n            prev,curr = None,head\n            while curr:\n                temp = curr.next\n                curr.next = prev\n                prev,curr = curr,temp\n            return prev\n\n        head = reverse(head)\n        curr = head\n        curr_max = curr.val\n\n        # curr\u662f\u5fc5\u7136\u4f1a\u88ab\u4fdd\u7559\u4e0b\u6765\u7684\n        while curr.next:\n            if curr.next.val &lt; curr_max:\n                # \u5220\u6389curr.next\n                curr.next = curr.next.next\n            else:\n                # \u66f4\u65b0curr_max, \u8d70\u4e00\u683c\n                curr_max = curr.next.val\n                curr = curr.next                \n        return reverse(head)\n</code></pre>","tags":["Linked List","Stack","Recursion","Monotonic Stack"]},{"location":"leetcode/25-reverse-nodes-in-k-groups/","title":"Problem","text":"<p>Given the head of a linked list, reverse the nodes of the list k at a time, and return the modified list.</p> <p>k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is.</p> <p>You may not alter the values in the list's nodes, only nodes themselves may be changed.</p> <p>Example 1:</p> <p></p> <pre><code>Input: head = [1,2,3,4,5], k = 2\nOutput: [2,1,4,3,5]\n</code></pre> <p>Example 2:</p> <p></p> <pre><code>Input: head = [1,2,3,4,5], k = 3\nOutput: [3,2,1,4,5]\n</code></pre> <p>Constraints:</p> <ul> <li>The number of nodes in the list is <code>n</code>.</li> <li><code>1 &lt;= k &lt;= n &lt;= 5000</code></li> <li><code>0 &lt;= Node.val &lt;= 1000</code></li> </ul>"},{"location":"leetcode/25-reverse-nodes-in-k-groups/#intuition","title":"Intuition","text":"<p>The problem is asking for reverse sub-linked list, in sub-groups. The first question is to determine the number of sub-groups. My train of thought is illustrated in the image below</p> <p></p> <p>To determine the length of linked list, we do this <pre><code># step1: traver to get the length\ndummy = ListNode(None,head)\n\nll_length = 0\n\ncurr = head\nwhile curr:\n    ll_length += 1\n    curr = curr.next\n</code></pre></p> <p>After we determine the linked list length, we could easier get the number of groups and number of left out nodes</p> <pre><code># step2: compute necessary infos\nnum_of_groups = ll_length//k\nnum_of_left_out_nodes = ll_length%k\n</code></pre> <p>Since we need to reverse for every sub-group, there must exist a nested loop structure,  <pre><code># iterate among all groups\nfor _ in range(num_of_groups):\n            # iterate within the group\n            for i in range(k):\n</code></pre></p> <p>Now, after we reverse our linked list classically, we need to do two things: - connect dummy node with node 2 - connect node 1 with node 3</p> <p></p> <p>If we use more generalized form, for connecting and stitching <code>group i</code>, we need to - connect the tail node of <code>group i-1</code> with the starting node after reversal - connect the starting node of <code>group i</code> before traversal.</p> <p>Summarize them and their updating strategy in the table |variable name|description|initial condition|updating strategy| |-|-|-|-| |<code>last_group_tail_node</code>|-|<code>dummy</code>|<code>start_node</code>| |<code>start_node</code>|-|<code>head</code>|<code>curr</code>|</p> <p>Note: \u539f\u6765\u7684<code>start_node</code>\u5728reverse\u4e4b\u540e\uff0c\u53d8\u6210\u4e86tail node of the sub-group.</p>"},{"location":"leetcode/25-reverse-nodes-in-k-groups/#code","title":"Code","text":"<pre><code># Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -&gt; Optional[ListNode]:\n        # step1: traver to get the length\n        dummy = ListNode(None,head)\n\n        ll_length = 0\n\n        curr = head\n        while curr:\n            ll_length += 1\n            curr = curr.next\n        # step2: compute necessary infos\n        num_of_groups = ll_length//k\n        num_of_left_out_nodes = ll_length%k\n\n        # step3:         \n        curr = head\n        last_group_tail_node = dummy \n        start_node = head\n        for _ in range(num_of_groups):\n            prev = None\n            for i in range(k):\n                temp = curr.next\n                curr.next = prev\n                prev = curr\n                curr = temp\n\n            last_group_tail_node.next = prev\n            last_group_tail_node = start_node\n            start_node.next = curr\n            start_node = curr\n\n        return dummy.next\n</code></pre>"},{"location":"leetcode/2516-take-k-of-each-characters-from-left-and-right/","title":"2516 Take K of Each Characters from Left and Right","text":""},{"location":"leetcode/2516-take-k-of-each-characters-from-left-and-right/#approach-1-sliding-window","title":"Approach 1 Sliding Window","text":"<p>\u8fd9\u4e00\u9898\u7684\u903b\u8f91\u662f\uff0c\u4f60\u9700\u8981\u627e\u5230\u6700\u5c11\u64cd\u4f5c\u6b21\u6570\u6765\u4fdd\u8bc1\u6bcf\u4e2a\u5b57\u7b26\"a\", \"b\", \"c\"\u81f3\u5c11\u88ab\u5220\u9664k\u6b21\uff0c\u4f46\u4f60\u7684\u64cd\u4f5c\u53ea\u80fd\u4ece\u5de6\u8fb9\u6216\u8005\u53f3\u8fb9\u5f00\u59cb\u5220\u9664\u5b57\u7b26. \u4f60\u53ef\u4ee5\u628a\u8fd9\u4e2a\u95ee\u9898\u8f6c\u5316from</p> <ul> <li>minimum number of operations to take at least k of each char \"a\", \"b\", \"c\"</li> </ul> <p>To its equivalent problem</p> <ul> <li>find the maximum window that satisfies the condition</li> </ul> <p>That's do a dry run with the following example</p> <pre><code>s = \"aabaaaacaabc\" k = 2\n{\n    \"a\": 8,\n    \"b\": 2,\n    \"c\": 2,\n}\n</code></pre> <p>We can subtract k from each character and we get the target</p> <pre><code>{\n    \"a\": 6, &lt;=6\n    \"b\": 0, &lt;=0\n    \"c\": 0  &lt;=0\n}\n</code></pre> <p>We have our two pointer and </p> <ul> <li>if limit has not been reached, we move right pointer</li> <li>if limit has been reached, we move left pointer</li> </ul> <p>\u7b97\u6cd5\u5982\u4e0b:</p> <ul> <li>edge case: k == 0, return 0</li> <li>\u8bbe\u7f6e\u4e00\u4e2a\u8ba1\u6570\u5668target, \u7528\u6765\u8bb0\u5f55\u6bcf\u4e2a\u5b57\u7b26\u7684\u6570\u91cf, \u5982\u679c\"a\",\"b\" or \"c\"\u4e2d\u6709\u4e00\u4e2a\u5b57\u7b26\u6ca1\u6709\u51fa\u73b0, \u6216\u8005\u51cf\u53bbk\u4e4b\u540e\u5c0f\u4e8e0, \u90a3\u4e48\u76f4\u63a5\u8fd4\u56de-1</li> <li>Initialize \u5de6\u53f3\u6307\u9488, \u4e00\u4e2a\u8ba1\u6570\u5668\u548c\u4e00\u4e2a\u7a97\u53e3\u5927\u5c0f<code>window</code></li> </ul> <pre><code>from collections import Counter\nclass Solution:\n    def takeCharacters(self, s: str, k: int) -&gt; int:\n        if k == 0:\n            return 0\n\n        target = Counter(s)\n        for key in \"abc\":\n            if key not in target:\n                return -1\n            target[key] -= k\n            if target[key] &lt; 0:\n                return -1\n\n        left = 0\n        n = len(s)\n\n        count = {char: 0 for char in 'abc'}\n        window = 0\n        for right in range(n):\n            count[s[right]] += 1\n            while left &lt;= right and (count['a'] &gt; target['a'] or count['b'] &gt; target['b'] or count['c'] &gt; target['c']):\n                # we remove left pointer\n                count[s[left]] -= 1\n                left += 1\n            if left &gt; right:\n                # empry-string\n                window = max(right-left,window)\n            else:\n                # non-empty window \n                window = max(right-left+1,window)\n\n        return n - window\n</code></pre> <p>\u8fd9\u5176\u4e2d\u6709\u5f88\u591a\u903b\u8f91\u53ef\u4ee5\u8fdb\u884c\u4f18\u5316, \u6bd4\u5982:</p> <ul> <li>\u53ea\u9700\u8981\u68c0\u67e5<code>right</code> pointer\u521a\u585e\u8fdb\u6765\u7684\u6570\u636e\u5373\u53ef</li> </ul> <pre><code>from collections import Counter\nclass Solution:\n    def takeCharacters(self, s: str, k: int) -&gt; int:\n        if k == 0:\n            return 0\n\n        target = Counter(s)\n        for key in \"abc\":\n            if key not in target:\n                return -1\n            target[key] -= k\n            if target[key] &lt; 0:\n                return -1\n\n        left = 0\n        n = len(s)\n\n        count = {char: 0 for char in 'abc'}\n        window = 0\n        for right in range(n):\n            count[s[right]] += 1\n            # \u53ea\u9700\u8981\u8003\u8651\u521a\u52a0\u8fdb\u53bb\u7684\u5373\u53ef\n            while count[s[right]] &gt; target[s[right]]:\n                # we remove left pointer\n                count[s[left]] -= 1\n                left += 1\n            window = max(window,right-left+1)\n        return n - window\n</code></pre>"},{"location":"leetcode/252-meeting-rooms/","title":"252 Meeting Rooms","text":"<p>\u6ca1\u5565\u53ef\u8bf4\u7684, sort by start time and then linear scan.</p>","tags":["Array","Sorting"]},{"location":"leetcode/252-meeting-rooms/#approach-1","title":"Approach 1","text":"<pre><code>class Solution:\n    def canAttendMeetings(self, intervals: List[List[int]]) -&gt; bool:\n        # sort by the meeting start time, nlogn\n        intervals.sort(key = lambda x: x[0])\n\n        for i in range(1,len(intervals)):\n            if intervals[i][0] &lt; intervals[i-1][1]:\n                return False\n\n        return True\n</code></pre>","tags":["Array","Sorting"]},{"location":"leetcode/253-meeting-rooms-II/","title":"253 Meeting Rooms II","text":"<p>\u8fd9\u9898\u662finterval\u625b\u628a\u5b50\u9898\u76ee,\u51e0\u79cd\u4e3b\u8981\u89e3\u6cd5</p> <ul> <li>line sweep</li> <li>heap</li> </ul>","tags":["Array","Two Pointers","Greedy","Sorting","Heap (Priority Queue)","Prefix Sum","Line Sweep"]},{"location":"leetcode/253-meeting-rooms-II/#approach-1-line-sweep","title":"Approach 1 Line Sweep","text":"<p>\u8fd9\u9898\u548c\u6570\u98de\u673a\u4e00\u6478\u4e00\u6837, \u5c5e\u4e8einterval\u7684\u9f3b\u7956\u9898\u76ee\u3002\u4ee3\u7801\u601d\u8def\u5982\u4e0b</p> <ul> <li>\u6784\u5efa\u4e00\u4e2a<code>rooms</code>\u6570\u7ec4\uff0c\u5927\u5c0f\u662fintervals\u76842\u500d\uff0c\u6bcf\u4e2a\u5143\u7d20\u662f\u4e00\u4e2atuple of (time,cost)\u3002time\u662f\u4f1a\u8bae\u5f00\u59cbor\u7ed3\u675f\u7684\u65f6\u95f4\u3002cost\u662f1\u8868\u793a\u5f00\u59cb\uff0c-1\u8868\u793a\u7ed3\u675f</li> <li>sort by time ascendingly, if tie, we sort by cost ascendingly (end meeting first). \u8fd9\u548c\u6570\u98de\u673a\u90a3\u9898\uff0c\u98de\u673a\u964d\u843d\u4f18\u5148\u4e8e\u8d77\u98de\u4e00\u6837. \u5148\u7ed3\u7b97\u7ed3\u675f\u65f6\u95f4\uff0c\u518d\u7ed3\u7b97\u5f00\u59cb\u65f6\u95f4\uff0c\u8fd9\u6837\u6709\u5229\u4e8e\u65e0\u7f1d\u8854\u63a5(\u4e0a\u4e00\u4e2ameeting\u521a\u5f00\u5b8c\uff0c\u76f4\u63a5\u5f00\u4e0b\u4e00\u4e2a\uff0c\u4e0d\u9700\u8981\u65b0\u5efa\u4e00\u4e2aroom)</li> <li>\u7ef4\u62a4\u4e00\u4e2aglobal extremum\uff0c\u518d\u7ef4\u62a4\u4e00\u4e2aaccumulative_cost.</li> <li>\u904d\u5386rooms\uff0c\u66f4\u65b0accumulative\uff0c\u7136\u540e\u66f4\u65b0global extremum if necessary</li> </ul> <p>complexity analysis</p> <p>\\(O(nlogn)\\) in time due to sorting and \\(O(n)\\) in space</p> <pre><code>class Solution:\n    def minMeetingRooms(self, intervals: List[List[int]]) -&gt; int:\n        # since we only interested in the time when the meeting starts and ends\n        # size 2n with [(time,cost),(time,cost),....]\n        rooms = []\n        for start,end in intervals:\n            rooms.append((start,1))\n            rooms.append((end,-1))\n\n        # pass in a tuple as key, so we first sort by time, if tie, we sort by cost (start meeting first)\n        rooms.sort(key = lambda x: (x[0],x[1]))\n\n        res = 0\n        count = 0\n        for _,cost in rooms:\n            count += cost\n            res = max(res,count)\n        return res\n</code></pre>","tags":["Array","Two Pointers","Greedy","Sorting","Heap (Priority Queue)","Prefix Sum","Line Sweep"]},{"location":"leetcode/253-meeting-rooms-II/#approach-2-heap","title":"Approach 2 Heap","text":"<p>complexity analysis</p> <p>\\(O(nlogn)\\) in time due to sorting + linear x heappush and \\(O(n)\\) in space for storing heap</p> <ul> <li>sort intervals by start time</li> <li>\u7ef4\u62a4\u4e00\u4e2amin heap, \u7ef4\u62a4\u6240\u6709\u4f1a\u8bae\u7684\u7ed3\u675f\u65f6\u95f4</li> <li>\u904d\u5386intervals\uff0c\u505a\u51fa\u5224\u5b9a<ul> <li>\u5982\u679c\u5f53\u524d\u4f1a\u8bae\u7684\u5f00\u59cb\u65f6\u95f4\u5927\u4e8e\u7b49\u4e8eheap\u7684\u6700\u5c0f\u503c\uff0c\u8bf4\u660e\u6709room available\uff0cpop\u51fa\u6765\u3002\u53cd\u4e4b, \u8bf4\u660efrist available room\u8fd8\u6ca1\u6709\u7ed3\u675f\u5462\uff0c\u518d\u5f00\u4e00\u4e2a\u623f.</li> <li>\u5224\u5b9a\u4e4b\u540e\uff0c\u4e0d\u7ba1\u600e\u4e48\u6837\u90fd\u9700\u8981assign\u4e00\u4e2a\u65b0\u7684room.</li> </ul> </li> <li>traverse\u5b8cintervals, \u7b49\u4e8e\u6240\u6709\u7684\u4f1a\u8bae\u8bf7\u6c42\u90fd\u5904\u7406\u5b8c\u4e86\uff0c\u8bf7\u6c42\u5b8c\u4e4b\u540e\uff0cheap\u91cc\u9762\u7684\u5143\u7d20\u4e2a\u6570\u5c31\u662f\u6700\u5c0f\u7684room\u6570\u91cf\u4e86</li> </ul> <p>\u4e3a\u4ec0\u4e48return len(heap)</p> <p>heap\u91cc\uff0c\u6211\u4eec\u6bcf\u4e00\u4e2aiteration, \u80af\u5b9a\u4f1apush\u4e00\u4e2a\u5143\u7d20\u8fdb\u53bb\uff0c\u9009\u62e9\u6027\u7684pop\u4e00\u4e2a\u5143\u7d20\u51fa\u6765\u3002\u4e5f\u5c31\u662f\u8bf4heap\u7684\u5927\u5c0f\u53ea\u4f1a\u589e\u4e0d\u4f1a\u51cf\u3002\u6240\u4ee5heap\u7684\u5927\u5c0f\u5c31\u662f\u6700\u5c0f\u7684room\u6570\u91cf\u4e86. \u4e24\u4e2a\u6781\u9650\u60c5\u51b5\u662f\u6240\u6709\u4f1a\u8bae\u90fd\u4e0d\u91cd\u53e0\uff0c\u90a3\u4e48\u8fd9\u4e2aheap\u6ca1\u6709pop\u4e00\u6b21\u3002</p> <pre><code>from heapq import heapify,heappush,heappop\nclass Solution:\n    def minMeetingRooms(self, intervals: List[List[int]]) -&gt; int:\n        intervals.sort(key = lambda x:x[0])\n\n        # \u7ef4\u62a4\u4e00\u4e2amin heap, \u91cc\u9762\u653e\u7740\u6240\u6709\u4f1a\u8bae\u7684\u7ed3\u675f\u65f6\u95f4\n        rooms = []\n        heappush(rooms,intervals[0][1])\n\n        for curr_start,curr_end in intervals[1:]:\n            # knock knock, room available?\n            if curr_start &gt;= rooms[0]:\n                # room available\u4e86\n                heappop(rooms)\n            # assign a new room\n            heappush(rooms,curr_end)\n\n        return len(rooms)\n</code></pre>","tags":["Array","Two Pointers","Greedy","Sorting","Heap (Priority Queue)","Prefix Sum","Line Sweep"]},{"location":"leetcode/2540-minimum-common-value/","title":"2540 Minimum Common Value","text":"<p>\u7b2c\u4e00\u601d\u8def\u662fhash map, \u770b\u5230\u662fsorted array, \u53ef\u4ee5\u7528two pointers\u6216\u8005binary search\u6765\u505a\u3002two pointers\u6bd4\u8f83\u7b80\u5355\uff0c\u5c31\u5148\u505a\u4e86two pointers.</p>","tags":["Array","Hash Table","Two Pointers","Binary Search"]},{"location":"leetcode/2540-minimum-common-value/#approach-1-two-pointers-1-pass","title":"Approach 1 two pointers 1 pass","text":"<pre><code>class Solution:\n    def getCommon(self, nums1: List[int], nums2: List[int]) -&gt; int:\n        # nums1 and nums2 are sorted\n        p1 = p2 = 0\n        m,n = len(nums1),len(nums2)\n        while p1 &lt; m and p2 &lt; n:\n            if nums1[p1] == nums2[p2]:\n                return nums1[p1]\n            elif nums1[p1] &gt; nums2[p2]:\n                p2 += 1\n            else:\n                p1 += 1\n\n        return -1\n</code></pre>","tags":["Array","Hash Table","Two Pointers","Binary Search"]},{"location":"leetcode/2540-minimum-common-value/#approach-2-binary-search","title":"Approach 2 Binary Search","text":"<pre><code>class Solution:\n    def getCommon(self, nums1: List[int], nums2: List[int]) -&gt; int:\n\n        def binary_search(target, nums):\n            left = 0\n            right = len(nums) - 1\n            while left &lt;= right:\n                mid = left + (right - left) // 2\n                if nums[mid] &gt; target:\n                    right = mid - 1\n                elif nums[mid] &lt; target:\n                    left = mid + 1\n                else:\n                    return True\n            return False \n\n        # Binary search should be done on the larger array\n        # If nums1 is longer, call getCommon with the arrays swapped\n        if len(nums1) &gt; len(nums2): \n            return self.getCommon(nums2, nums1)\n\n        # Search for each element of nums1 in nums2\n        # Return the first common element found\n        for num in nums1:\n            if binary_search(num, nums2):\n                return num\n\n        # Return -1 if there are no common elements\n        return -1\n</code></pre>","tags":["Array","Hash Table","Two Pointers","Binary Search"]},{"location":"leetcode/255-verify-preorder-sequence-in-binary-search-tree/","title":"255 Verify Preorder Sequence in Binary Search Tree","text":"","tags":["Array","Stack","Tree","Binary Search Tree","Recursion","Monotonic Stack","Binary Tree"]},{"location":"leetcode/255-verify-preorder-sequence-in-binary-search-tree/#approach-1-recursion","title":"Approach 1: Recursion","text":"<p>\u6bd4\u8f83intuitive\u7684\u4e00\u4e2a\u89e3\u662f\uff0c\u5229\u7528BST\u6027\u8d28, for every single node <code>X</code></p> <ul> <li>left subtree of node <code>X</code> contains only nodes with values less than <code>X</code></li> <li>right subtree of node <code>X</code> contains only nodes with values greater than <code>X</code></li> </ul> <p>\u6bd4\u5982\u8bf4\u5bf9\u4e8e</p> <p></p> <pre><code>class Solution:\n    def verifyPreorder(self, preorder: List[int]) -&gt; bool:\n        \"\"\"\n        observation:\n        - pre-order traversal, \u8bb0\u5f55\u7b2c\u4e00\u6b21\u8bbf\u95eenode\u7684\u6570\u5b57\n        \"\"\"\n        def dfs(lo,hi):\n            nonlocal i\n            # base case, reach the end without failing\n            if i == len(preorder):\n                return True\n\n            root = preorder[i]\n            if root &lt; lo or root &gt; hi:\n                return False\n\n            i += 1\n            left = dfs(lo,root)\n            right = dfs(root, hi)\n\n            # \u6709\u4e00\u4e2a\u627e\u5230\u4e86\u5373\u53ef\n            return left or right\n\n        i = 0\n        return dfs(-inf,inf)\n</code></pre>","tags":["Array","Stack","Tree","Binary Search Tree","Recursion","Monotonic Stack","Binary Tree"]},{"location":"leetcode/257-binary-tree-paths/","title":"Problem","text":"<p>Given the <code>root</code> of a binary tree, return all root-to-leaf paths in any order.</p> <p>A leaf is a node with no children.</p> <p>Example 1: <pre><code>    1\n   / \\\n  2   3\n   \\\n    5\n</code></pre> <pre><code>Output: [\"1-&gt;2-&gt;5\" ,\"1-&gt;3\"]\n</code></pre></p>"},{"location":"leetcode/257-binary-tree-paths/#algorithm","title":"Algorithm","text":"<p>The solution makes use of a stack data structure to traverse the binary tree in a depth-first manner. It maintains a stack of tuples, where each tuple contains a node and the path to that node from the root.</p> <p>It then iteratively pops a tuple from the stack, checks if the node is a leaf node, and if so, appends the path to the list of paths. If the node is not a leaf node, it pushes its left and right children onto the stack with their respective paths.</p> <p>The function returns the list of paths once the stack is empty.</p> <pre><code># DFS # stack of tuples\n\nTime complexity: O(n), each node visits exactly once\nSpace complexity: O(n)\n</code></pre>"},{"location":"leetcode/257-binary-tree-paths/#_1","title":"\u6027\u80fd\u4f18\u5316","text":"<p>\u9898\u76ee\u4e2d\u5c06 <pre><code>if node.left:\n    # use str().join(iterable)\n    stack.append((node.left, '-&gt;'.join([path, str(node.left.val)])))\n</code></pre> \u6539\u5199\u4e3a <pre><code>if node.left:\n    # use +\n    stack.append((node.left, path + '-&gt;' + str(node.left.val)))\n</code></pre></p> <p>The reason is that in python, it uses - <code>stack memory</code>: to manage function calls - <code>heap memory</code>: to store objects (garbage collector goes here)</p> <p></p> <p>Since <code>str()</code> in Python is designed to be immutable, therefore if we use <code>path + \"-&gt;\" + str(node.left.val)</code>, we create intermediate string variables, which will be stored in the heap.</p> <p>As for the reason why the <code>str()</code> has been designed as immutable, there are two folds: - In multi thread process, two thread may access the same string variables and do modification on it. If it's mutable, the state of string thread A accessing might not be the same as what thread B has seen. - Also, it simplifies the implementation of certain operations, such as string concatenation and substring operations. Because strings are immutable, the original string can be left unchanged while a new string is created with the desired modifications.</p> <p>\u4f46\u4e5f\u4e0d\u662f\u6240\u6709\u65f6\u5019\u90fd\u5fc5\u987b\u8981\u7528<code>.join(iterable)</code>, \u968f\u7740join\u6027\u80fd\u597d\uff0c\u4f46\u662f<code>+</code>\u5b83readability\u66f4\u9ad8\uff0c\u5982\u679c\u662fone-time use, \u4e0d\u59a8\u7528<code>+</code>. I choose readability over performance 99% of the case</p>"},{"location":"leetcode/257-binary-tree-paths/#code","title":"Code","text":"<pre><code># Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def binaryTreePaths(self, root: Optional[TreeNode]) -&gt; List[str]:\n        paths = []\n        stack = [(root, str(root.val))]\n\n        while stack:\n            # unpack stack\n            node, path = stack.pop()\n            # reach leaf node\n            if not node.left and not node.right:\n                # \u53ea\u5728reach leaf node\u65f6\uff0c\u5199\u5165\n                paths.append(path)\n\n            if node.left:\n                stack.append((node.left, '-&gt;'.join([path, str(node.left.val)])))\n                # stack.append((node.left, path + '-&gt;' + str(node.left.val)))\n\n            if node.right:\n                stack.append((node.right, '-&gt;'.join([path, str(node.right.val)])))\n                # string immutable, the above\n                # stack.append((node.right, path + '-&gt;' + str(node.right.val)))\n\n        return paths\n</code></pre>"},{"location":"leetcode/257-binary-tree-paths/#reference","title":"Reference","text":"<ul> <li>python memory management</li> </ul>"},{"location":"leetcode/26-remove-duplicates-from-sorted-array/","title":"26 Remove Duplicates from Sorted Array","text":"<pre><code>class Solution:\n    def removeDuplicates(self, nums: List[int]) -&gt; int:\n        # remove in-place\n        remain = len(nums)\n        left = 1\n        prev = nums[0]\n\n        while left &lt; len(nums):\n            if prev == nums[left]:\n                nums[left-1] = \"_\"\n\n            prev = nums[left]        \n            left += 1\n\n        while \"_\" in nums:\n            nums.remove(\"_\")\n\n        return remain\n</code></pre>","tags":["array","two pointers"]},{"location":"leetcode/266-palindrome-permutation/","title":"\u6700\u521d\u4ee3\u7801","text":"<p>\u6211\u4e00\u5f00\u59cb\u7684\u4ee3\u7801\u5982\u4e0b\u5c06string\u8fdb\u884c\u5206\u7c7b\u8ba8\u8bba: - \u5947\u6570string, \u53ea\u6709\u4e00\u4e2a\u5b57\u7b26\u5141\u8bb8\u51fa\u73b0\u5947\u6570\u6b21 - \u5076\u6570string, \u6bcf\u4e00\u4e2a\u5b57\u7b26\u51fa\u73b0\u7684frequencies\u90fd\u662f\u5076\u6570\u6b21</p> <pre><code>class Solution:\n    def canPermutePalindrome(self, s: str) -&gt; bool:\n        # step1. permutation\n        # step2. palindrome\n\n        # craete a hashtable and count frequencies\n        hashtable = {}\n        for char in s:\n            if char not in hashtable.keys():\n                hashtable[char] = 1\n            else:\n                hashtable[char] += 1\n\n        # \u4e24\u79cdconditions\u662fpalindrom\u7684\u6761\u4ef6:\n        # odd number of string, \u5176\u4e2d\u6709\u4e00\u4e2ax%2 == 1, \u5269\u4e0b\u7684\u90fd\u6ee1\u8db3y%2 == 0\n        # even number of string, \u90a3\u4e48\u6bcf\u4e2aitem\u90fd\u6ee1\u8db3y%%2 == 0:\n        if len(s) % 2 == 0:\n            # \u5148\u770b\u5076\u6570case\n            for key,value in hashtable.items():\n                if value % 2 != 0:\n                    return False\n        else:\n            # \u518d\u770b\u5947\u6570case\n            pointer = 0\n            for key,value in hashtable.items():\n                if value%2 == 1:\n                    pointer += 1\n\n            if pointer &gt; 1:\n                return False\n\n        return True\n</code></pre>"},{"location":"leetcode/266-palindrome-permutation/#_2","title":"\u6539\u826f\u4ee3\u7801","text":"<p>\u501f\u9274valid parathesis, \u53ef\u4ee5\u5c06\u4e0a\u8ff0\u5947\u6570\u5076\u6570\u6761\u4ef6\u7efc\u5408\u4e00\u4e0b, \u53ea\u53d1\u73b0\u4e00\u4e2aunparid element inside the string.</p>"},{"location":"leetcode/266-palindrome-permutation/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: \\(O(1)\\)</li> </ul> <ul> <li>Space complexity: \\(O(2)\\)</li> </ul>"},{"location":"leetcode/266-palindrome-permutation/#code","title":"Code","text":"<pre><code>class Solution:\n    def canPermutePalindrome(self, s: str) -&gt; bool:\n        # \u4e4b\u524d\u7684\u601d\u8def:\n        # \u4e24\u79cdconditions\u662fpalindrom\u7684\u6761\u4ef6:\n        # odd number of string, \u5176\u4e2d\u6709\u4e00\u4e2ax%2 == 1, \u5269\u4e0b\u7684\u90fd\u6ee1\u8db3y%2 == 0\n        # even number of string, \u90a3\u4e48\u6bcf\u4e2aitem\u90fd\u6ee1\u8db3y%%2 == 0:\n\n        # \u5229\u7528\u8fd9\u4e2a\u601d\u8def\uff0c\u518d\u548cvalid parathensis\u4e2d\u7684\u601d\u8def\u7ed3\u5408\u4e00\u4e0b\n        # \u5947\u6570\u548c\u5076\u6570\u8fd9\u4e24\u4e2a\u6761\u4ef6\u7684\u4e2d\u548c\u6761\u4ef6\u5c31\u662f\uff0c\u6ee1\u8db3\u53ea\u6709\u4e00\u4e2a\u5355\u8eab\u6c49,\u5269\u4e0b\u90fd\u662f\u60c5\u4fa3\n\n        unpaired = set()\n\n        for char in s:\n            if char not in unpaired:\n                # \u6ca1\u627e\u5230pair, \u5148\u53bb\u91cc\u9762\u7b49\u7740\u5427\n                unpaired.add(char)\n            else:\n                # \u6ee1\u8db3\u4e00\u4e2apair, \u6d88\u6d88\u4e50\n                unpaired.remove(char)\n\n\n        return len(unpaired) &lt;= 1\n</code></pre>"},{"location":"leetcode/268-missing-number/","title":"268 Missing Number","text":"<p>\u8fd9\u9898\u89e3\u6cd5\u5f88\u591a,</p> <ul> <li>sorting</li> <li>hashmap</li> <li>bit manipulation (optimal)</li> <li>rolling sum (optimal)</li> </ul> <p>\u91cd\u70b9\u7406\u89e3bit manipulation\u7684\u89e3\u6cd5\uff0c\u56e0\u4e3a\u8fd9\u4e2a\u89e3\u6cd5\u662fO(n) time, O(1) space\u7684\u89e3\u6cd5. \u8fd9\u9898\u5229\u7528\u7684\u6027\u8d28\u662fXOR\u7684\u6027\u8d28 <code>a^a=0</code>, <code>a^0=a</code>. \u548c\u81ea\u7136\u6570 <code>0,1,2,...,n</code>\u5b58\u5728array\u4e4b\u4e2d\u540e\uff0cindex\u548cvalue\u662f\u4e00\u6837\u7684\u6027\u8d28. \u8fd9\u4e2a\u60f3\u6cd5\u53ef\u4ee5generalize\u5230\u66f4\u5e7f\u4e49\u7684array\u60c5\u51b5.</p>","tags":["Array","Hash Table","Bit Manipulation","Sorting","Math"]},{"location":"leetcode/268-missing-number/#approach-1-hash-table","title":"Approach 1: Hash Table","text":"<p>\u60f3\u5230\u601d\u8def\u662f\u7528hashset\u6765\u5b58\u50a8\u6240\u6709\u73b0\u6709\u7684\u6570\u5b57, \u7136\u540e\u6211\u4eec\u77e5\u9053\u6211\u4eecexpected\u7684\u6570\u5b57\u662f<code>0,1,2,...,n</code>, \u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u4ece0\u5f00\u59cb\u5f80\u540e\u627e, \u5982\u679c\u627e\u5230\u4e86\u4e00\u4e2a\u6570\u5b57\u4e0d\u5728hashset\u91cc\u9762, \u90a3\u4e48\u5c31\u8fd4\u56de\u8fd9\u4e2a\u6570\u5b57.</p> <p>\u8fd9\u4e2a\u89e3\u6cd5\u8981\u8003\u8651\u4e00\u4e2a <pre><code>class Solution:\n    def missingNumber(self, nums: List[int]) -&gt; int:\n        # gaussian\n        nums_set = set(nums)\n        n = len(nums)\n\n        # scan through candidate's lower and upper bound\n        lower,upper = 0, n\n        while lower&lt;=upper:\n            if lower not in nums_set:\n                return lower\n            lower += 1\n</code></pre></p>","tags":["Array","Hash Table","Bit Manipulation","Sorting","Math"]},{"location":"leetcode/268-missing-number/#approach-2-sorting","title":"Approach 2: Sorting","text":"<p>\u540c\u7406\uff0c\u6211\u4eec\u53ef\u4ee5\u5148sort\u8fd9\u4e2a\u6570\u7ec4\uff0c\u7136\u540e\u6bd4\u8f83\u4ece0\u5f00\u59cb\u7684expected\u6570\u5b57\u548csort\u540e\u7684\u6570\u7ec4\uff0c\u5982\u679c\u6709\u4e0d\u4e00\u6837\u7684\uff0c\u90a3\u4e48\u5c31\u8fd4\u56de\u8fd9\u4e2a\u6570\u5b57.</p> <pre><code>class Solution:\n    def missingNumber(self, nums: List[int]) -&gt; int:\n        nums.sort()\n\n        expected = 0\n        for num in nums:\n            if num != expected:\n                return expected\n            expected += 1\n\n        # if reaches here, missing last val\n        return expected\n</code></pre>","tags":["Array","Hash Table","Bit Manipulation","Sorting","Math"]},{"location":"leetcode/268-missing-number/#follow-up-solve-it-with-on-time-o1-space","title":"Follow-up: solve it with O(n) time, O(1) space","text":"","tags":["Array","Hash Table","Bit Manipulation","Sorting","Math"]},{"location":"leetcode/268-missing-number/#approach-3-bit-manipulation","title":"Approach 3: Bit Manipulation","text":"<p>\u8fd9\u9898\u6b63\u597d\u7528\u521a\u5b66\u7684bit manipulation\u7684\u6280\u5de7\u6765\u89e3\u51b3\uff0c\u6211\u4eec\u77e5\u9053<code>XOR</code>\u7684\u6027\u8d28\u662f\uff0c<code>a^a=0</code>, \u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u7528<code>XOR</code>\u6765\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898. \u6211\u4eec\u5148\u6765\u601d\u8003\u4e0b\u56fe\u7684\u7b2c\u4e00\u4e2a\u6846, </p> <p></p> <p>\u5047\u8bbe\u6211\u4eec\u6709\u4e00\u4e2asorted <code>nums = [0,1,3]</code>, \u6211\u4eec\u8981\u628a\u5b83\u8865\u9f50\uff0c\u5c31\u9700\u8981</p> <ul> <li>\u6269\u5bb9array size by 1, \u90a3\u6700\u5927\u7684index\u4e3an.</li> <li>\u627e\u5230missing value</li> <li>shift \u6240\u6709\u7684\u6570\u5b57\uff0c\u817e\u51fa\u7a7a\u95f4</li> <li>replace missing value</li> </ul> <p>\u8865\u9f50\u4e4b\u540e\u7684array\u662f<code>[0,1,2,3]</code>, \u6ce8\u610f\u5230\u4e86\u5417? index == array. \u8fd9\u4e2a\u6027\u8d28\u53ef\u4ee5\u7528\u6765\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898. \u6211\u4eec\u53ef\u4ee5\u7528<code>XOR</code>\u6765\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898. \u65e2\u7136\u6211\u4eec\u77e5\u9053<code>XOR</code>\u7684\u6027\u8d28\u662f<code>a^a=0</code>, \u6211\u4eec\u8fd8\u7f3a\u4e00\u4e2amissing value\u548c\u4e00\u4e2a\u6700\u5927index <code>n</code>, \u90a3\u4e48\u6211\u4eec\u628a\u8fd9\u4e9b\u90fd\u8fde\u7eed<code>XOR</code>\u4e00\u4e0b\uff0c\u5c31\u80fd\u5f97\u5230missing value\u4e86.</p> <p>\u518d\u6765\u770b\u4e0b\u56fe\u7684\u7b2c\u4e8c\u4e2a\u6846,\u56e0\u4e3a<code>XOR</code>\u6709\u4ea4\u6362\u7387\uff0c\u6240\u4ee5order doesn't matter if we scan entire array. \u7528\u8fd9\u4e2a\u4f8b\u5b50</p> <pre><code>Input: nums = [3,0,1]\nOutput: 2\nExplanation: n = 3 since there are 3 numbers, so all numbers are in the range [0,3]. 2 is the missing number in the range since it does not appear in nums.\n</code></pre> <p>\u6211\u4eec\u521d\u59cb\u5316\u6211\u4eec\u7684missing index\u4e3a<code>n = len(nums)</code>, \u7136\u540e\u6211\u4eec\u5f00\u59cb\u904d\u5386\u6574\u4e2a\u6570\u7ec4\uff0c\u6211\u4eec\u7528<code>XOR</code>\u6765\u66f4\u65b0missing index, <code>missing_i ^= i ^ val</code>, \u5982\u4e0b\u65b9\u7a0b\u5c55\u5f00,</p> \\[ \\begin{align} \\text{missing value} &amp;= 3 \\oplus (0 \\oplus 3) \\oplus (1 \\oplus 0) \\oplus (2 \\oplus 1)\\\\                      &amp;= (0 \\oplus 0) \\oplus (1 \\oplus 1) \\oplus 2 \\oplus (3 \\oplus 3)\\\\                      &amp;= 0 \\oplus 0 \\oplus 2 \\oplus 0\\\\                      &amp;= 2 \\end{align} \\] <pre><code>class Solution:\n    def missingNumber(self, nums: List[int]) -&gt; int:\n        # if we have n = len(nums), then the value ranging from 0... n-1\n        # we now that if it's sorted, the complete nums will be index == values\n        # index ^ value == 0, \u73b0\u5728\u518d\u52a0\u4e0adistributive law, \u6211\u4eec\u53ef\u4ee5\u518d\u5206\u914d\n\n        missing_i = len(nums)\n        for i,val in enumerate(nums):\n            missing_i ^= i ^ val\n\n        return missing_i\n</code></pre>","tags":["Array","Hash Table","Bit Manipulation","Sorting","Math"]},{"location":"leetcode/268-missing-number/#approach-4-math-gauss-formula","title":"Approach 4: Math (Gauss' Formula)","text":"<p>\u9ad8\u65af\u6c42\u548c\u516c\u5f0ffor \u7b49\u5dee\u6570\u5217\uff0c\u9996\u9879+\u672b\u9879*\u9879\u6570/2. \u6b65\u9aa4\u5982\u4e0b</p> <ul> <li>\u6839\u636e\\(0,1,2,...,n\\)\u7684\u7b49\u5dee\u6570\u5217\u6c42\u548c\u516c\u5f0f\uff0c\u6c42\u51fa\\(0,1,2,...,n\\)\u7684\u548c</li> <li>\u904d\u5386\u6570\u7ec4\uff0c\u51cf\u53bb\u6570\u7ec4\u4e2d\u7684\u6bcf\u4e00\u4e2a\u6570</li> <li>\u6700\u540e\u5269\u4e0b\u7684\u5c31\u662fmissing number</li> </ul> <p>\u4f46\u7b2c\u4e00\u6b65\uff0c\u6211\u4eec\u53ef\u4ee5\u4e0d\u7528memorize\u5f0f\uff0c\u53cd\u6b63\u6211\u4eec\u90fd\u662f\u8981linear solution, \u76f4\u63a5rolling both actual sum and expected sum\u5c31\u597d\u4e86.</p> <pre><code>class Solution:\n    def missingNumber(self, nums: List[int]) -&gt; int:\n        # gaussian\n        expected_sum = 0\n        actual_sum = 0\n        rolling = 1\n        for num in nums:\n            actual_sum += num\n            expected_sum += rolling\n            rolling += 1\n        return expected_sum - actual_sum\n</code></pre>","tags":["Array","Hash Table","Bit Manipulation","Sorting","Math"]},{"location":"leetcode/268-missing-number/#xor","title":"\u601d\u8003: XOR","text":"<p>\u9664\u4e86<code>index == val</code>\u65f6, \u4efb\u4f55val\u80fd\u7528index\u8868\u793a\u51fa\u6765\u7684\u5f62\u5f0f\uff0c\u90fd\u53ef\u4ee5. \u5982\u4e0b\u56fe\u6240\u793a, </p> <p></p> <p>\u4f60\u53ea\u9700\u8981\u5199\u51fa\u53cd\u51fd\u6570\uff0c\u628aval\u8f6c\u5316\u4e3aindex\u5c31\u597d\u4e86.</p>","tags":["Array","Hash Table","Bit Manipulation","Sorting","Math"]},{"location":"leetcode/2730-find-the-longest-semi-repetitive-substring/","title":"2730 Find the Longest Semi-Repetitive Substring","text":"","tags":["String","Sliding Window"]},{"location":"leetcode/2730-find-the-longest-semi-repetitive-substring/#approach-1-sliding-window","title":"Approach 1 Sliding Window","text":"<p>\u62c6\u5206\u5b50\u95ee\u9898,\u627e\u5230:</p> <ul> <li>\u4ee5index 0\u4e3a\u7ec8\u70b9\u7684\uff0c\u7b26\u5408\u6761\u4ef6\u7684\u6700\u957fsubstring</li> <li>\u4ee5index 1\u4e3a\u7ec8\u70b9\u7684\uff0c\u7b26\u5408\u6761\u4ef6\u7684\u6700\u957fsubstring</li> <li>...</li> <li>\u4ee5index n-1\u4e3a\u7ec8\u70b9\u7684\uff0c\u7b26\u5408\u6761\u4ef6\u7684\u6700\u957fsubstring</li> </ul> <pre><code>class Solution:\n    def longestSemiRepetitiveSubstring(self, s: str) -&gt; int:\n        \"\"\"\n        observation:\n            - \u7ef4\u62a4\u4e00\u4e2acounter, \u8ba1\u7b97num_of_consectuive_pairs if prev == curr\n            - sliding window with two pointers\n        \u601d\u8def\n        - edge case\n        - initialize prev at index 0\n        - iterate from index 1 to n-1\n            - compare prev with curr\n            - while num_of_pairs &gt;= 2\n                - move left pointer until it doesn't\n        Dry run:\n            - index 0\n            - index 1\n            - index 2 522\n            - index 3 5223\n            - index 4\n                - 52233\n                - 2233\n                - 233 (found it)\n        \"\"\"\n        if len(s) == 1:\n            return 1\n\n        res = 0\n        prev = s[0]\n        pairs = 0\n        left = 0\n\n        for right,curr in enumerate(s[1:],1):\n            if curr == prev:\n                pairs += 1\n\n            while pairs == 2 and left &lt; right:\n                if s[left] == s[left+1]:\n                    pairs -= 1                     \n                left += 1\n\n            res = max(res,right - left + 1)\n            prev = curr\n\n        return res\n</code></pre>","tags":["String","Sliding Window"]},{"location":"leetcode/2739-total-distance-traveled/","title":"2739 Total Distance Traveled","text":"","tags":["Math","Simulation"]},{"location":"leetcode/2739-total-distance-traveled/#approach-1-on","title":"Approach 1 O(n)","text":"<pre><code>class Solution:\n    def distanceTraveled(self, mainTank: int, additionalTank: int) -&gt; int:\n        total = 0\n        used_in_main = 0\n        while mainTank &gt; 0:\n            mainTank -= 1\n            total += 10\n            used_in_main += 1\n            # check if we can refill or not\n            if used_in_main %5 == 0:\n                if additionalTank &gt; 0:\n                    additionalTank -= 1\n                    mainTank += 1            \n        return total\n</code></pre>","tags":["Math","Simulation"]},{"location":"leetcode/2739-total-distance-traveled/#approach-2-o1-lee","title":"Approach 2 O(1) lee","text":"<p>Lee\u771f\u7684\u725b, solution here.</p> <p>\u5047\u8bbe\u6211\u4eec\u6709mainTank (M) = 13, additionalTank (A) = 3.</p> <p>\u6211\u4eec\u603b\u5171\u80fd\u8dd1\u7684\u6570\u91cf\u53ef\u4ee5\u5206\u4e3a\u4e24\u90e8\u5206:</p> <ul> <li>mainTank\u81ea\u5e26\u7684, \\(M\\)</li> <li>\u7531\u4e8e\u6211\u4eec\u8dd1\u7684\u597d\uff0cadditionalTank\u8865\u5145\u7684, x = f(M,A)</li> </ul> <p>\u96be\u70b9\u5728\u4e8e\u600e\u4e48\u5224\u5b9af(M,A)\u7684\u5173\u7cfb\u5f0f.</p> <pre><code>M  M  M  M  M   A  M  M  M  M   A   M  M  M  M   A\n1 [2  3  4  5]  6 [7  8  9 10]  11 [12 13 14 15] 16\n</code></pre> <p>\u6211\u4eec\u5728simulate\u7684\u65f6\u5019\uff0cmainTank\u7684\u7b2c\u4e00\u5347\u6cb9\u8981\u4f5c\u4e3a<code>pseudo-oil-from-additional-tank</code>, \u8fd9\u6837\uff0c\u4f60\u5c31\u5728<code>M-1</code>\u4e2d\u5bfb\u627e\uff0c\u6700\u591a\u80fd\u7ec4\u6210\u51e0\u4e2a<code>4</code>\u7684\u500d\u6570. \u56e0\u6b64\uff0c\u6211\u4eec\u53ef\u4ee5\u5f97\u5230:</p> \\[ \\begin{aligned} x &amp;= f(M,A) = min(\\frac{M-1}{4}, A) \\\\ \\text{total} &amp;= (M + x) * 10 \\end{aligned} \\] <p>where x is the number of additionalTank we can use, and total is the total distance we can travel.</p> <pre><code>class Solution:\n    def distanceTraveled(self, mainTank: int, additionalTank: int) -&gt; int:\n        return (mainTank + min((mainTank-1)//4, additionalTank)) * 10\n</code></pre>","tags":["Math","Simulation"]},{"location":"leetcode/2740-find-the-value-of-the-partition/","title":"2740 Find the value of the partition","text":"","tags":["Array","Sorting"]},{"location":"leetcode/2740-find-the-value-of-the-partition/#approach-1-sort","title":"Approach 1 Sort","text":"<p>Adjacency minimum.</p> <pre><code>class Solution:\n    def findValueOfPartition(self, nums: List[int]) -&gt; int:\n        nums.sort()\n        smallest = max(nums)\n        for i in range(1,len(nums)):\n            diff = abs(nums[i] - nums[i-1])\n            smallest = min(smallest,diff)\n\n        return smallest\n</code></pre>","tags":["Array","Sorting"]},{"location":"leetcode/2748-number-of-beautiful-pairs/","title":"2748 Number of Beautiful Pairs","text":"<p>\u8003\u70b9\u6bd4\u8f83\u6570\u5b66.</p>","tags":["Array","Math","Number Theory"]},{"location":"leetcode/2748-number-of-beautiful-pairs/#approach-1","title":"Approach 1","text":"<p>\u590d\u4e60\u4e86\u4e09\u4e2a\u77e5\u8bc6\u70b9:</p> <ul> <li><code>math.gcd(a,b)</code> \u6c42\u6700\u5927\u516c\u7ea6\u6570 (greatest common divisor), if <code>gcd(a,b) == 1</code> \u8bf4\u660ea,b\u4e92\u8d28</li> <li>last digit of a number <code>num % 10</code></li> <li>first digit of a number <code>num // 10 until num &lt; 10</code></li> </ul> <pre><code>import math\nclass Solution:\n    def countBeautifulPairs(self, nums: List[int]) -&gt; int:\n        \"\"\"\n        1. enumeration\n        2. math.gcd()\n        \"\"\"\n        pairs = 0\n        for j, num in enumerate(nums):\n            # last digit for nums[j]\n            last_digit = num % 10\n            for i in range(j):\n                first_digit = nums[i]\n                # get first digit\n                while first_digit &gt;= 10:\n                    first_digit //= 10\n                pairs += math.gcd(last_digit,first_digit) == 1\n        return pairs\n</code></pre>","tags":["Array","Math","Number Theory"]},{"location":"leetcode/278-first-bad-version/","title":"Intuition","text":"<p>Binary search\u7b97\u6cd5\u5f88\u7b80\u5355\uff0c\u4f46\u662fimplement\u8d77\u6765\u7684\u95ee\u9898\u6709\u5f88\u591a, \u66f4\u591a\u7ec6\u8282\u53ef\u4ee5\u770b powerful ultimate binary search template. \u975e\u5e38\u597d\u7684\u603b\u7ed3</p> <p>\u8fd9\u4e9b\u4e5f\u662f\u5f88\u56f0\u60d1\u6211\u7684\u95ee\u9898\uff0c\u5982\u4e0b: - <code>right = mid</code> or <code>right = mid - 1</code>? - <code>left = mid</code> or <code>left = mid + 1</code> - <code>while left &lt; mid</code> or <code>while left &lt;= mid</code>? - <code>return left</code> or <code>return left-1</code></p> <p>\u4ee5\u4e0a\u7684\u8fd9\u4e9bboundary\u7684\u5212\u5206\uff0c\u771f\u7684\u975e\u5e38\u8ba9\u6211confusing, \u8fd9\u4e2a\u4f5c\u8005\u603b\u7ed3\u7684\u4e07\u80fd\u5957\u7528\u6a21\u7248\u975e\u5e38\u6f02\u4eae template\u5982\u4e0b <pre><code>def binary_search(array) -&gt; int:\n    def condition(value) -&gt; bool:\n        pass\n\n    left,right = min(search_space), max(search_space)\n\n    while left &lt; right:\n        mid = left + (right - left)//2\n        if condition(mid):\n            right = mid\n        else:\n            left = mid +1\n\n    return left \n</code></pre> \u4e4b\u540e\u53ea\u9700\u8981\u7528\u8fd9\u4e2a\u6a21\u7248\u6539\u5c31\u53ef\u4ee5\u4e86, \u6709\u4ee5\u4e0b\u51e0\u70b9\u9700\u8981\u6ce8\u610f\uff1a - <code>mid = left + (right - left)//2</code>, \u4e3b\u8981\u4e3a\u4e86\u9632\u6b62data overflow - <code>while left &lt; right</code>, <code>right = mid</code>, <code>left = mid + 1</code> \u4ee5\u53ca<code>mid = left + (right - left)//2</code> \u8fd9\u4e2a\u7ec4\u5408\u6709\u4ee5\u4e0b\u51e0\u4e2a\u7279\u70b9\uff1a   - \u6536\u655b\u65f6\u7279\u70b9: \u5f53<code>left</code>\u548c<code>right</code>\u7684\u5dee\u503c\u4e3a1\u65f6\uff0c<code>mid</code>\u548c<code>left</code>\u5c31\u4e00\u6837\uff0c\u8fd9\u65f6\u5019\u6709\u4e24\u79cd\u53ef\u80fd:     - \u4e0d\u6ee1\u8db3\u6761\u4ef6(\u6ca1\u627e\u5230target), \u6267\u884c<code>left = mid + 1</code>, \u90a3\u8fd9\u6837, <code>left == right</code>, \u4e0b\u4e00\u6b21check <code>while</code>\u6761\u4ef6\u65f6\u5019\uff0c\u5c31\u8fc7\u4e0d\u4e86\u4e86\uff1b     - \u6ee1\u8db3\u6761\u4ef6(\u627e\u5230target)\u65f6,  \u4e0d\u76f4\u63a5<code>return mid</code>,\u800c\u662f\u6267\u884cright = mid, \u4e3a\u4ec0\u4e48\uff0c\u56e0\u4e3a\u8fd9\u6837\u7684\u8bdd<code>right == left == mid</code>\u4e09\u8005\u90fd\u76f8\u7b49\uff0c<code>return left</code> \u5373\u53ef </p> <p>\u66f4\u65b0\u4e8e2022/02/21</p> <p>\u4e0a\u8bc9\u6a21\u7248\u8fd8\u662f\u4e0d\u591f\u597d\uff0c\u57fa\u4e8e\u6b64\u6211\u53c8\u627e\u5230\u4e00\u4e2a\u65b0\u6a21\u7248from geekforgeek, \u66f4\u52a0intuitive\u4e00\u70b9 <pre><code>// Java implementation of iterative Binary Search\nclass BinarySearch {\n    // Returns index of x if it is present in arr[],\n    // else return -1\n    int binarySearch(int arr[], int x)\n    {\n        int l = 0, r = arr.length - 1;\n        while (l &lt;= r) {\n            int m = l + (r - l) / 2;\n\n            // Check if x is present at mid\n            if (arr[m] == x)\n                return m;\n\n            // If x greater, ignore left half\n            if (arr[m] &lt; x)\n                l = m + 1;\n\n            // If x is smaller, ignore right half\n            else\n                r = m - 1;\n        }\n\n        // if we reach here, then element was\n        // not present\n        return -1;\n    }\n\n    // Driver method to test above\n    public static void main(String args[])\n    {\n        BinarySearch ob = new BinarySearch();\n        int arr[] = { 2, 3, 4, 10, 40 };\n        int n = arr.length;\n        int x = 10;\n        int result = ob.binarySearch(arr, x);\n        if (result == -1)\n            System.out.println(\"Element not present\");\n        else\n            System.out.println(\"Element found at \"\n                               + \"index \" + result);\n    }\n}\n</code></pre></p>"},{"location":"leetcode/278-first-bad-version/#approach-binary-search","title":"Approach: Binary search","text":""},{"location":"leetcode/278-first-bad-version/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: \\(O(logn)\\)</li> </ul> <ul> <li>Space complexity: \\(O(1)\\)</li> </ul>"},{"location":"leetcode/278-first-bad-version/#code","title":"Code","text":"<pre><code># The isBadVersion API is already defined for you.\n# def isBadVersion(version: int) -&gt; bool:\n\n\nclass Solution:\n    def firstBadVersion(self, n: int) -&gt; int:\n        # intuition, binary seaech O(logn)\n        left = 1\n        right = n\n\n        while left &lt; right:\n            # update mid points to middle of the search space, need to consider overflow\n            # Example: left = 2**31 - 3, right = 2**31 -1\n            mid = left + (right - left)//2\n\n            # bad path\n            if isBadVersion(mid):\n                # \u4e2d\u4f4d\u6570\u662fbad version, search space\u5728\u5de6\u8fb9,update\u53f3\u6307\u9488\n                right = mid \n            else:\n                # \u4e2d\u4f4d\u6570\u662fgood version, search space\u5728\u53f3\u8fb9\uff0cupdate\u5de6\u6307\u9488\n                left = mid + 1\n\n\n\n        return left\n</code></pre>"},{"location":"leetcode/2785-sort-vowels-in-a-string/","title":"2785 Sort Vowels in a String","text":"<p>\u7ed9\u4e00\u4e2astring, \u628a\u5176\u4e2d\u7684\u5143\u97f3(\u5305\u62ec\u5927\u5c0f\u5199\u517110\u4e2a)\u5b57\u6bcd\u6309\u7167ascending\u987a\u5e8f\u91cd\u65b0\u6392\u5e8f\uff0c\u5176\u5b83\u5b57\u6bcd\u4fdd\u6301\u5728<code>s</code>\u4e2d\u539f\u6765\u7684\u4f4d\u7f6e\u3002</p>","tags":["String","Sorting"]},{"location":"leetcode/2785-sort-vowels-in-a-string/#approach-1-heap","title":"Approach 1 Heap","text":"<p>\u7b2c\u4e00\u4e2a\u60f3\u5230\u7684\u601d\u8def\u5c31\u662f</p> <ul> <li>\u521b\u5efa\u4e00\u4e2amin heap\uff0c\u6765\u7ef4\u62a4a tuple of (\u5143\u97f3\u5b57\u6bcd,\u5bf9\u5e94index), \u540c\u65f6maintain\u4e00\u4e2alist\u6765\u8bb0\u5f55\u6240\u6709\u7684\u5143\u97f3\u5b57\u6bcd\u7684index</li> <li>one pass to build the heap and the list</li> <li>second pass <ul> <li>\u9047\u5230\u5143\u97f3\u5b57\u6bcd\uff0c\u4ecemin heap\u4e2dpop\u51fa\u6765\uff0cappend\u5230\u7ed3\u679c\u4e2d</li> <li>\u975e\u5143\u97f3\u5b57\u6bcd\uff0c\u76f4\u63a5append <code>s[i]</code>\u5230\u7ed3\u679c\u4e2d</li> </ul> </li> </ul>","tags":["String","Sorting"]},{"location":"leetcode/2785-sort-vowels-in-a-string/#code-implementation","title":"Code Implementation","text":"<pre><code>from heapq import heapify,heappush,heappop\nclass Solution:\n    def sortVowels(self, s: str) -&gt; str:\n        # a, e, i, o, u\n        # \"lEetcOde\"\n        # (E,1),(e,2),(O,5),(e,7)\n        # sort them into\n        # (E,1),(0,5),(e,2),(e,7)\n        # 1. mark all vowels indexs and non-vowels index into two arrays\n        # 2. append them into a heap\n        # 3. rebuild it from scratch\n\n        vowel_indexes = set()\n        vowels = set(['a','e','i','o','u','A','E','I','O','U'])\n        heap = []\n        for i,c in enumerate(s):\n            if c in vowels:\n                vowel_indexes.add(i)\n                heappush(heap,(c,i))\n\n\n        res = []\n        for i in range(len(s)):\n            if i in vowel_indexes:\n                vowel,_ = heappop(heap)\n                res.append(vowel)\n            else:\n                res.append(s[i])\n\n        return \"\".join(res)\n</code></pre>","tags":["String","Sorting"]},{"location":"leetcode/2785-sort-vowels-in-a-string/#approach-2-countingbucket-sort","title":"Approach 2 Counting/Bucket Sort","text":"<p>\u548cbucket sort\u4e00\u6837\uff0c\u5f53\u503c\u57df\u7684search space\u6bd4\u5143\u7d20\u57df\u5c0f\u5f88\u591a\u65f6\u5019\uff0c\u6211\u4eec\u53ef\u4ee5\u628a\u5143\u7d20\u57dfn, \u8f6c\u5316\u4e3a\u503c\u57df\u3002\u8fd9\u4e00\u9898\u5c31\u662f\u8fd9\u6837\u7684\u4f8b\u5b50\uff0c\u6211\u4eec\u7684\u503c\u57df\u662f10\u4e2a\u5143\u97f3\u5b57\u6bcd. \u5927\u5927\u7b80\u5316\u4e86\u641c\u7d22\u7a7a\u95f4.</p> <ul> <li>\u521b\u5efa\u4e00\u4e2ahash table\u6765\u8bb0\u5f55\u6bcf\u4e2a\u5143\u97f3\u5b57\u6bcd\u7684\u51fa\u73b0\u6b21\u6570 (that's why it's called counting sort)</li> <li>one pass to build the hash table</li> <li>second pass <ul> <li>\u9047\u5230\u5143\u97f3\u5b57\u6bcd\uff0c\u4ecehash table\u4e2d, \u6839\u636esorted 10\u4e2avowels\u4e2d\uff0c\u6309\u987a\u5e8f\u627e\u5230\u7b2c\u4e00\u4e2a\u51fa\u73b0\u6b21\u6570\u5927\u4e8e0\u7684\u5143\u97f3\u5b57\u6bcd\uff0cappend\u5230\u7ed3\u679c\u4e2d</li> <li>\u975e\u5143\u97f3\u5b57\u6bcd\uff0c\u76f4\u63a5append <code>s[i]</code>\u5230\u7ed3\u679c\u4e2d</li> </ul> </li> </ul>","tags":["String","Sorting"]},{"location":"leetcode/2785-sort-vowels-in-a-string/#code-implementation_1","title":"Code Implementation","text":"<pre><code>from collections import Counter\nclass Solution:\n    def sortVowels(self, s: str) -&gt; str:\n        counter = Counter(s)\n        sorted_vowels = ['A','E','I','O','U','a','e','i','o','u',]\n\n        res = []\n        # O(n)\n        for i,c in enumerate(s):\n            # O(10*10), could use a set(sorted_vowels), but one less variable to maintain\n            if c in sorted_vowels:                \n                for vowel in sorted_vowels:\n                    if counter[vowel] &gt; 0:\n                        res.append(vowel)\n                        counter[vowel] -= 1\n                        break\n            else:\n                res.append(s[i])\n\n        return \"\".join(res)\n</code></pre>","tags":["String","Sorting"]},{"location":"leetcode/279-perfect-squares/","title":"279 Perfect Squares","text":"","tags":["Dynamic Programming","Math","Breadth-First Search"]},{"location":"leetcode/279-perfect-squares/#approach-0-brute-force","title":"Approach 0: Brute Force","text":"<p>Assuming we have perfect squares, \\(a_n = n^2\\) <pre><code>Perfect squares: 1, 4, 9, 16, 25, 36, 49... \n</code></pre> Given target <code>n</code>, \u6211\u4eec\u9700\u8981\u6c42\u7684\u662f\u6700\u5c11\u7684perfect squares\u7684\u4e2a\u6570\u6765\u6ee1\u8db3\u8fd9\u4e9b\u4e4b\u548c\u7b49\u4e8e<code>n</code>.</p> \\[ \\begin{align} n &amp;= n_1 a_1 + n_2 a_2 + n_3 a_3 + ... + n_i a_i \\\\  &amp;= n_{1} 1^2 + n_{2} 2^2 + n_{3} 3^2 + ... + n_{i} i^2 \\\\  &amp;= n_{1} 1 + n_{2} 4 + n_{3} 9 + ... + n_{i} i^2 \\end{align} \\] <p>where \\(n_i\\) is the number for the perfect square \\(a_i\\), and \\(a_n\\) the perfect square itself.</p> <p>\u5148\u6765\u4e2a\u66b4\u529b\u641c\u7d22, \u5982\u679c\u6211\u4eec\u4ece0, \u5f00\u59cb\u4e0d\u65ad\u52a0\u4e0a, \u5982\u4e0b\u56fe\u6240\u793a</p> <p></p> <p>\u4f60\u4f1a\u53d1\u73b0\uff0c\u5230\u7b2c\u4e09\u5c42\uff0c\u5c31\u5df2\u7ecf\u6709\u5f88\u591a\u91cd\u590d\u6027\u8ba1\u7b97\u4e86\uff0c\u6709\u91cd\u590d\u6027\u8ba1\u7b97\u5c31\u6709\u4f18\u5316\u7a7a\u95f4\uff0c\u800c\u4e14\u6c42\u7684\u662fleast (\u4ee3\u8868\u6c42\u6781\u503c\u95ee\u9898)\uff0c\u90a3\u4e5f\u5c31\u662f\u4e00\u4e2a\u4f18\u5316\u95ee\u9898, \u4f18\u5316\u95ee\u9898\u5c31\u6709\u592a\u591a\u4e86method\u4e86\uff0c\u4f46\u8fd9\u4e2a\u95ee\u9898\u53ef\u4ee5\u5206\u89e3\u4e3a\u5b50\u95ee\u9898\uff0c\u5982\u4e0b\u56fe,</p> <p></p> <p>\u6240\u4ee5\u53ef\u80fd\u6027\u53ea\u6709\u4e24\u79cd\uff0cdp or greedy.</p>","tags":["Dynamic Programming","Math","Breadth-First Search"]},{"location":"leetcode/279-perfect-squares/#vs","title":"\u8d2a\u5fc3 vs \u52a8\u6001\u89c4\u5212","text":"<p>\u4f18\u5316\u95ee\u9898\u6709\u4e24\u79cd\u53ef\u80fd: - \u8d2a\u5fc3 - \u52a8\u6001\u89c4\u5212</p> <p>\u8fd9\u91cc\u5fc5\u7136\u662f\u52a8\u6001\u89c4\u5212, \u56e0\u4e3a\u8d2a\u5fc3\u662f\u6bcf\u4e00\u6b65\u4fdd\u8bc1\u6700\u4f18\uff0c\u800c\u4e14\u8d2a\u5fc3\u4e0d\u9700\u8981\u56de\u6eaf\uff0c\u4e3e\u4e2a\u4f8b\u9898\u4e2d\u7684\u4f8b\u5b50,  <pre><code>input: n = 12\noutput: 3\nexplain: 12 = 4 + 4 + 4\n</code></pre></p> <p>\u5982\u679c\u662f\u8d2a\u5fc3, \u5fc5\u7136\u662f\u6bcf\u4e00\u6b65\u90fd\u9009\u62e9\u6700\u5927\u7684perfect square, \u7b2c\u4e00\u6b65\u5c31\u9009\u62e9\\(3^2\\), \\(12 - 9 = 3\\), \u7b2c\u4e8c\u6b65\u53ea\u80fd\u8d70\\(1^2\\), \\(3 - 1 = 2\\), \u7b2c\u4e09\u548c\u7b2c\u56db\u6b65\u4e5f\u4e00\u6837\uff0c\u6700\u540e\u7b54\u6848\u662f4 (9, 4, 1, 1)\u5e76\u4e0d\u662f\u6700\u4f18\u89e3.</p> <p>\u6392\u51fa\u4e86\u8d2a\u5fc3\uff0c\u7b54\u6848\u5fc5\u5b9a\u662f\u52a8\u6001\u89c4\u5212\uff0c\u90a3\u4e48\u6211\u4eec\u5c31\u53ef\u4ee5\u5f00\u59cb\u5206\u6790\u52a8\u6001\u89c4\u5212\u7684\u89e3\u6cd5\u4e86.</p>","tags":["Dynamic Programming","Math","Breadth-First Search"]},{"location":"leetcode/279-perfect-squares/#approach-1-dp-bottom-up","title":"Approach 1: DP bottom-up","text":"","tags":["Dynamic Programming","Math","Breadth-First Search"]},{"location":"leetcode/279-perfect-squares/#dp-definition","title":"DP definition","text":"<p>DP is defined as,  <pre><code>dp[i]: the least number of perfect squares numbers that sum to i\n</code></pre></p>","tags":["Dynamic Programming","Math","Breadth-First Search"]},{"location":"leetcode/279-perfect-squares/#initialization","title":"Initialization","text":"<p>all the values in array <code>dp</code> are initialized to <code>n</code>, except <code>dp[0] = 0</code>. 0 is just the padding left boundary for the array.</p>","tags":["Dynamic Programming","Math","Breadth-First Search"]},{"location":"leetcode/279-perfect-squares/#state-transition-function","title":"State Transition Function","text":"<p>\u6211\u4eec\u77e5\u9053\u4ee5\u4e0b\u89c4\u5f8b,\u5982\u679c\u6c42n, \u90a3\u4e48 <pre><code>dp[0] = 0\ndp[1] = 1\ndp[2] = 2\ndp[3] = 3\ndp[4] = 1\n...\n</code></pre> \u8fd9\u4e4b\u95f4\u7684\u4f9d\u8d56\u5173\u7cfb\u5176\u5b9e\u662f, recall the graph, \u6bcf\u5f80\u4e0b\u63a8\u4e00\u6b65\uff0c\u90fd\u4f9d\u8d56\u4e8e\u4e0a\u4e00\u6b65\u5b58\u5728\u7684\u7ed3\u679c\uff0c\u800c\u6bcf\u4e00\u5c42\u4e2d\u95f4\u7684\u5dee\u503c\uff0c\u6b63\u597d\u662f\u4e00\u4e2aperfect square, \u6211\u4eec\u662f\u4ece\u4e0a\u5f80\u4e0b\u63a8\u7684 <pre><code>dp[\u4e0b\u4e00\u5c42\u7ed3\u679c] = dp[\u4e0a\u4e00\u5c42\u7ed3\u679c] + 1\n\u4e0a\u4e00\u5c42\u7ed3\u679c - perfect square = \u4e0b\u4e00\u5c42\u7ed3\u679c\n</code></pre></p> <p>\u5177\u4f53\u5982\u4e0b\u56fe\u6240\u793a\uff1a</p> <p></p> <p><code>DP[12]</code> \u4e5f\u5c31\u662f\u6211\u4eec\u8981\u6c42\u7684\u4ef7\u503c\uff0c\u4f9d\u8d56\u4e8e<code>DP[11]</code>, <code>DP[8]</code> and <code>DP[3]</code>, \u800c\u4e3a\u4ec0\u4e48\u662f<code>3, 8, 11</code>\u5462\uff0c\u662f\u7531<code>12 - perfect square</code>\u5f97\u5230\u7684\uff0c\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u5f97\u5230\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b\u5982\u4e0b\uff1a</p> \\[ dp[i] = \\min_{1 \\leq s \\leq i} \\{ dp[i - s^2] + 1 \\} \\quad \\forall \\quad i - s^2 \\geq 0 \\] <p>\u63a5\u4e0b\u6765\u6211\u4eec\u53ea\u9700\u8981\u4e0d\u65ad\u4ece\u4e0b\u5f80\u4e0a\u63a8\u5373\u53ef.</p> <pre><code>class Solution:\n    def numSquares(self, n: int) -&gt; int:\n        # DP[i]: the least number of perfect squares numbers that sum to i\n        # initialization:\n        # DP[0...n] == n, DP[0] = 0\n        # 1^2 + 1^2 + ... + 1^2 = 12 * 1^2 = 12\n        # state transition function (could propogate from multiple fronts)\n\n        DP = [n for _ in range(n+1)]\n        DP[0] = 0\n\n        # \u88ab\u51cf\u6570(target) - square = remaining\n        for target in range(1, n + 1):\n            for s in range(1, target + 1):\n                square = s * s\n                remaining = target - square \n                if remaining &lt; 0:\n                    break\n                # propogate\n                DP[target] = min(DP[target], 1 + DP[remaining])\n\n        return DP[n]\n</code></pre>","tags":["Dynamic Programming","Math","Breadth-First Search"]},{"location":"leetcode/2799-count-complete-subarrays-in-an-array/","title":"2799 Count Complete Subarrays in an Array","text":"","tags":["Array","Sliding Window","Hash Table"]},{"location":"leetcode/2799-count-complete-subarrays-in-an-array/#approach-1-sliding-window","title":"Approach 1: Sliding Window","text":"<p>\u7ef4\u62a4\u4e00\u4e2ahashmap, \u5206\u89e3\u5b50\u95ee\u9898:</p> <ul> <li>\u4ee50\u4e3a\u7ed3\u5c3e\u7684subarray\u6709\u591a\u5c11\u4e2a</li> <li>\u4ee51\u4e3a\u7ed3\u5c3e\u7684subarray\u6709\u591a\u5c11\u4e2a</li> <li>...</li> <li>\u4ee5n-1\u4e3a\u7ed3\u5c3e\u7684subarray\u6709\u591a\u5c11\u4e2a</li> </ul> <p>\u8fd9\u4e2a\u53ef\u4ee5\u8f6c\u5316\u4e3a:</p> <ul> <li>\u4ee50\u7ed3\u5c3e\u7684\uff0c\u7b26\u5408\u6761\u4ef6\u7684\u6700\u77edsubarray, \u83b7\u5f97\u5b50\u6570\u7ec4\u9996\u5c3e\uff0cleft and right.</li> <li>\u4ee51\u7ed3\u5c3e\u7684\uff0c\u7b26\u5408\u6761\u4ef6\u7684\u6700\u77edsubarray, \u83b7\u5f97\u5b50\u6570\u7ec4\u9996\u5c3e\uff0cleft and right.</li> <li>...</li> <li>\u4ee5n-1\u7ed3\u5c3e\u7684\uff0c\u7b26\u5408\u6761\u4ef6\u7684\u6700\u77edsubarray, \u83b7\u5f97\u5b50\u6570\u7ec4\u9996\u5c3e\uff0cleft and right.</li> </ul> <p>\\(\\sum\\)\u540e\u5c31\u662f\u7b54\u6848.</p> <p>complexity</p> <ul> <li>time: \\(O(n)\\)</li> <li>space: \\(O(n)\\)</li> </ul> <pre><code>from collections import defaultdict\nclass Solution:\n    def countCompleteSubarrays(self, nums: List[int]) -&gt; int:\n        uniques = len(set(nums))\n        hashmap = defaultdict(int)\n        left = 0\n        res = 0\n        for right,num in enumerate(nums):\n            # update hashmap\n            hashmap[num] += 1\n\n            while len(hashmap) == uniques:               \n                if hashmap[nums[left]] == 1:\n                    # if we delete nums[left], we no longer complete\n                    break\n                hashmap[nums[left]] -= 1\n                left += 1\n\n            if len(hashmap) == uniques:\n                res += left + 1\n\n        return res\n</code></pre>","tags":["Array","Sliding Window","Hash Table"]},{"location":"leetcode/28-find-the-index-of-the-first-occurrence-in-a-string/","title":"28 Find the Index of the First Occurrence in a String","text":"<p>\u4f5c\u4e3a\u4e00\u4e2aKMP\u7684\u5f15\u5b50.</p>","tags":["Two Pointers","String","String Matching"]},{"location":"leetcode/28-find-the-index-of-the-first-occurrence-in-a-string/#approach-1-brute-force","title":"Approach 1: Brute Force","text":"<pre><code>class Solution:\n    def strStr(self, haystack: str, needle: str) -&gt; int:\n        n,m = len(haystack),len(needle)\n        i = j = 0\n        while i &lt; n and j &lt; m:\n            if haystack[i] == needle[j]:\n                # matching cases\n                i += 1\n                j += 1\n            else:\n                # not matching cases, \u7531\u4e8e\u6bd4\u4e86j\u6b21\uff0c\u6240\u4ee5\u5148backtack by j, \u7136\u540e\u518d\u6bd4\u8f83\u4e0b\u4e00\u4e2aindex by increment by 1\n                i = i - j + 1\n                j = 0\n\n        if j == m:\n            return i - j\n        else:\n            return -1\n</code></pre>","tags":["Two Pointers","String","String Matching"]},{"location":"leetcode/28-find-the-index-of-the-first-occurrence-in-a-string/#approach-2-kmp","title":"Approach 2: KMP","text":"<pre><code>class Solution:\n    def strStr(self, haystack: str, needle: str) -&gt; int:\n        def get_pi(pattern):\n            m = len(pattern)\n            pi = [0] * m\n            for i in range(1,m):\n                # assign candidate\n                j = pi[i-1]\n\n                while j &gt; 0 and pattern[i] != pattern[j]:\n                    j = pi[j-1]\n                # \u5230\u4e86\u8fd9\u91cc\u4fe9\u53ef\u80fd\uff0cj==0 or pattern[i] == pattern[j]\n                if pattern[i] == pattern[j]:\n                    pi[i] = j+1\n                else:\n                    # reach j == 0\n                    pi[i] = j\n            return pi\n\n        n,m = len(haystack),len(needle)\n        pi = get_pi(needle)\n        j = 0\n        for i in range(n):\n            while j &gt; 0 and haystack[i] != needle[j]:\n                j = pi[j-1]\n            if haystack[i] == needle[j]:\n                j += 1\n            if j == m:\n                return i - j + 1\n\n        return -1\n</code></pre>","tags":["Two Pointers","String","String Matching"]},{"location":"leetcode/2824-count-pairs-whose-sum-is-less-than-target/","title":"2824 Count Pairs Whose Sum is Less than Target","text":"<p>\u8fd9\u9898\u5f88\u591a\u4eba\u7528binary search, \u4f46\u662f\u6211\u611f\u89c9\u4f1a\u7be1\u6539\u9898\u610f. \u8981\u6c42\u662ffind the number of pairs in <code>nums</code> such that <code>(i,j)</code> where <code>0&lt;=i&lt;j&lt;n</code> and <code>nums[i]+nums[j] &lt; target</code>. </p> <p>\u5982\u679c\u4e3a\u4e86\u7528binary search, \u4f60sort\u4e86, (i,j)\u7684index\u5c31\u4e0d\u5bf9\u4e86. </p>","tags":["Array","Two Pointers","Binary Search","Sorting"]},{"location":"leetcode/2824-count-pairs-whose-sum-is-less-than-target/#approach-1-brute-force","title":"Approach 1 Brute Force","text":"<p>Note</p> <ul> <li>time complexity is \\(O(n^2)\\)</li> <li>space complexity is \\(O(1)\\)</li> </ul> <pre><code>class Solution:\n    def countPairs(self, nums: List[int], target: int) -&gt; int:\n        n = len(nums)\n        res = 0\n        for i in range(n):\n            for j in range(i+1,n):\n                if nums[i] + nums[j] &lt; target:\n                    res += 1\n        return res        \n</code></pre>","tags":["Array","Two Pointers","Binary Search","Sorting"]},{"location":"leetcode/2824-count-pairs-whose-sum-is-less-than-target/#approach-2-binary-search","title":"Approach 2 Binary Search","text":"<p>\u7559\u7740\u7ed9\u672a\u6765\u7684\u81ea\u5df1.</p>","tags":["Array","Two Pointers","Binary Search","Sorting"]},{"location":"leetcode/283-Move-Zeros/","title":"Approach 1: two pointer technique","text":""},{"location":"leetcode/283-Move-Zeros/#problem","title":"Problem","text":"<p>\u9996\u5148\u8f6c\u6362\u9898\u5e72\u4e2d\u7684\u6761\u4ef6, - move all 0's to the end of array - all the non-zero elements must retain their original order.</p> <p>\u8fd9\u4e00\u6b65\u8f6c\u6362\u5f88\u91cd\u8981\uff0c\u53ef\u4ee5\u65b9\u4fbf\u4f60\u5224\u65ad\u95ee\u9898. \u9996\u5148, \u8fd9\u4fe9\u6761\u4ef6\u662fmutually exculusive\u7684\uff0c\u4e5f\u5c31\u53ef\u4ee5\u5206\u5f00\u5b8c\u6210\uff1b</p>"},{"location":"leetcode/283-Move-Zeros/#intuition","title":"Intuition","text":"<p>\u8fd9\u4e00\u9898two pointer technique\uff0c\u7531\u4e8e\u6211\u4eec\u60f3\u8981move 0 to the right hand side of array, \u540c\u65f6non-zero element retain order at left hand side of the array, \u6709\u4e00\u4e2a\u64cd\u4f5c\u80fd\u540c\u65f6\u8fbe\u6210\u4ee5\u4e0a\u8fd9\u4e24\u4ef6\u4e8b:</p> <p>\u64cd\u4f5c: pointer\u5411\u53f3scan\u7684\u8fc7\u7a0b\u4e2d,\u5c06\u4f60\u9047\u5230\u7684\u4e00\u4e2anon-zero element,\u505c\u4e0b\u6765\uff0c\u5411\u5de6scan,\u4e0e\u6bcf\u4e00\u4e2a0\u8fdb\u884c\u6362\u4f4d\uff0c\u76f4\u5230\u9047\u5230\u53e6\u4e00\u4e2anon-zero element. \u8fd9\u65f6pointer\u7ee7\u7eed\u5411\u524d\u8d70;</p> <p>\u6211\u539f\u5148\u4e5f\u662f\u8fd9\u4e2a\u601d\u8def, \u627e\u5230\u975e0 element,\u4f46\u6211\u662fiterative\u7684\u8ba91\u548c\u6bcf\u4e00\u4e2a0,\u505a\u4e00\u6b21\u4ea4\u6362\u4f4d\u7f6e\uff0c\u6211\u5f53\u65f6\u7684\\(O(n^2)\\)\u7684\u89e3\u6cd5click here. \u4e3a\u4ec0\u4e48\u8fd9\u4e2a\u64cd\u4f5c\u4e0defficient\u7684\u539f\u56e0\uff0c\u5c31\u5728\u4e8e\u6211\u5728swap non-zero with zero elements\u7684\u65f6\u5019\uff0c\u4e0d\u6b62\u4ea4\u6362\u4e86\u4e00\u6b21\u4f4d\u7f6e;</p> <p>\u6700\u4f18\u89e3\u662f\uff0c\u6211\u53ef\u4ee5\u53ea\u4ea4\u6362\u4e00\u6b21\u4f4d\u7f6e, \u4e5f\u5c31\u662f\u5982\u4e0b\u64cd\u4f5c</p> <p>\u64cd\u4f5c: pointer\u5411\u53f3scan\u7684\u8fc7\u7a0b\u4e2d,\u5c06\u4f60\u9047\u5230\u7684\u4e00\u4e2anon-zero element,\u505c\u4e0b\uff0c\u7136\u540e\u4e0e\u4e00\u4e2a\u5728\u6700\u5de6\u4fa7\u76840 (\u5982\u679c\u4e0e\u7b2c\u4e8c\u4e2a0\u4ea4\u6362\uff0c\u5219\u8fd8\u67090\u5728\u8fd9\u4e2anon-zero element\u5de6\u4fa7)\u8fdb\u884c\u4f4d\u7f6e\u4ea4\u6362.</p> <p>\u8981\u5b8c\u6210\u4ee5\u4e0a\u8fd9\u4e2a\u64cd\u4f5c\uff0c\u4f60\u9700\u8981\u4e24\u4e2a\u4fe1\u606f\uff0c\u9047\u5230\u7684\u7b2c\u4e00\u4e2anon-zero element, \u6700\u5de6\u4fa7\u76840, \u8fd9\u4e5f\u5c31\u662ftwo pointer comes in\u7684\u5730\u65b9: - <code>slow pointer</code>: stays at the leading 0 and waiting to be swapped. - <code>fast pointer</code>: looking for the first non-zero element.</p> <p>\u5f80\u524d\u8d70\u7684\u903b\u8f91: - <code>slow pointer</code>: moves forward by one, if current value is not zero. Stays at that location and waits for being swapped. - <code>fast pointer</code>: just traverse forward by one.</p> <p>\u6240\u4ee5\u53ef\u4ee5\u6839\u636e\u6b64\uff0c\u53ef\u4ee5\u5199\u51fa\u4ee5\u4e0b\u4ee3\u7801</p>"},{"location":"leetcode/283-Move-Zeros/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: \\(O(n)\\)</li> </ul> <ul> <li>Space complexity: \\(O(1)\\)</li> </ul>"},{"location":"leetcode/283-Move-Zeros/#code","title":"Code","text":"<pre><code>class Solution:\n    def moveZeroes(self, nums: List[int]) -&gt; None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        # two-pointer technique:\n        # slow pointer: points to the location of \"leading zero\" \u6700\u5de6\u8fb9\u76840\n        # fast pointer\uff1atraverse forward and looking for non-zero\n        # Note: fast pointer\u6b63\u5e38traverse, slow pointer \u6b63\u5e38traverse\u76f4\u5230\u53d1\u73b0zero, \u5219\u505c\u6b62\n\n        slow = 0\n        for fast in range(len(nums)):\n            if nums[fast] != 0 and nums[slow] == 0:\n                # swap \n                nums[fast],nums[slow] = nums[slow],nums[fast]\n\n            # slow pointer \u5f80\u524d\u8d70\u4e00\u6b65\n            if nums[slow] != 0:\n                slow += 1\n</code></pre>"},{"location":"leetcode/2831-find-the-longest-equal-subarray/","title":"2831 Find the longest equal subarray","text":"<p>\u6df1\u5ea6\u597d\u9898\uff0c\u5220\u9664\u81f3\u591ak\u4e2a\u5143\u7d20\uff0c\u4f7f\u5f97subarray\u4e2d\u7684\u5143\u7d20\u76f8\u7b49\uff0c\u6c42\u6700\u957f\u7684\u7b26\u5408\u6761\u4ef6\u7684subarray\u957f\u5ea6.</p>","tags":["Array","Sliding Window","Hash Table"]},{"location":"leetcode/2831-find-the-longest-equal-subarray/#approach-1-sliding-window-on-in-time-space","title":"Approach 1: Sliding Window (O(n) in time &amp; space)","text":"<p>equal subarray\u4e00\u5b9a\u7b26\u5408\u5176\u4e2d\u6240\u6709\u5143\u7d20\u90fd\u76f8\u540clike [A A A A A A]. \u65e2\u7136\u5982\u6b64\uff0c\u90a3\u4e48\u9996\u5c3e\u5fc5\u7136\u4e5f\u76f8\u540c\uff0c\u90fd\u662fA. \u90a3\u4e48\u6839\u636e\u8fd9\u4e2a\uff0c\u6211\u4eec\u770b\u4ee5\u4e0b\u7684\u6570\u7ec4\uff0c</p> <p><pre><code>0. 1.2 3 4 5 6  7 8 9 10 11 12\nX [A X X A X A] X X X A  X  X\n   i         j\n</code></pre> \u56e0\u6b64\uff0c\u6211\u4eec\u53ef\u4ee5\u82b1\u8d39O(n)\u7684\u7a7a\u95f4\u6784\u9020\u4e00\u4e2ahash map, \u8bb0\u5f55\u6bcf\u4e00\u4e2a\u4e0d\u540c\u5143\u7d20\u51fa\u73b0\u8fc7\u7684indices.</p> <p><pre><code>{\n    \"A\" : [1, 4, 6, 10],\n    \"X\" : ....\n}\n</code></pre> \u7136\u540e\u6211\u4eec\u904d\u5386\u5176\u4e2d\u6bcf\u4e00\u4e2aspace\u5373\u53ef, </p> <pre><code> 0 1 2  3\n[1,4,6,10]\n\ntotal # elements - #A\n(4 - 1 + 1) - (1 - 0 + 1) &gt; k\n</code></pre> <p>Algorithm:</p> <ul> <li>one pass to create such hashmap</li> <li>iterate all items() in the hashmap where len() &gt;= 2.<ul> <li>initialize left,right = 0,1</li> <li>move left pointer when we need to delete more than k</li> <li>move right pointer when can delete more!</li> </ul> </li> </ul> <p>Warning</p> <p>\u6ca1\u60f3\u5230\u5427\uff0c\u8fd9\u4e2a\u9898\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u8fd8\u662fO(n)\u7684\uff0c\u904d\u5386hashmap\u65f6\uff0c\u6211\u4eec\u7d2f\u52a0\u8d77\u6765\uff0c\u5176\u5b9e\u4e5f\u53ea\u8d70\u4e86\u4e00\u904d\uff0c\u6240\u4ee5\u662fO(n) + O(n) \\(\\approx\\) O(n)\u7684. Two pass solution.</p> <pre><code>from collections import defaultdict\nclass Solution:\n    def longestEqualSubarray(self, nums: List[int], k: int) -&gt; int:\n        hashmap = defaultdict(list)\n        res = 0\n        for i,num in enumerate(nums):\n            hashmap[num].append(i)\n\n        for _,ids in hashmap.items():\n            # edge case\n            if len(ids) == 1:\n                res = max(res,1)\n                continue\n            left = 0\n            for right in range(1,len(ids)):\n                if (ids[right] - ids[left] + 1) - (right - left + 1) &gt; k:\n                    left += 1\n\n            # right out of index by 1\n            res = max(res,right - left + 1)\n        return res\n</code></pre> <p>We can cut down some redundant logic,</p> <pre><code>from collections import defaultdict\nclass Solution:\n    def longestEqualSubarray(self, nums: List[int], k: int) -&gt; int:\n        \"\"\"\n        equal subarray\u4e00\u5b9a\u7b26\u5408\u5176\u4e2d\u6240\u6709\u5143\u7d20\u90fd\u76f8\u540clike [A A A A A A], \n        \u65e2\u7136\u5982\u6b64\uff0c\u90a3\u4e48\u9996\u5c3e\u5fc5\u7136\u4e5f\u76f8\u540c\uff0c\u90fd\u662fA. \u90a3\u4e48\u6839\u636e\u8fd9\u4e2a\uff0c\u6211\u4eec\u770b\u4ee5\u4e0b\u7684\u6570\u7ec4\uff0c\n        0. 1.2 3 4 5 6  7 8 9 10 11 12\n        X [A X X A X A] X X X A  X  X\n           i         j\n        \u56e0\u6b64\uff0c\u6211\u4eec\u53ef\u4ee5\u82b1\u8d39O(n)\u7684\u7a7a\u95f4\u6784\u9020\u4e00\u4e2ahash map, \u8bb0\u5f55\u6bcf\u4e00\u4e2a\u4e0d\u540c\u5143\u7d20\u51fa\u73b0\u8fc7\u7684indices.\n        {\n            \"A\" : [1, 4, 6, 10],\n            \"X\" : ....\n        }\n        \u7136\u540e\u6211\u4eec\u904d\u5386\u5176\u4e2d\u6bcf\u4e00\u4e2aspace\u5373\u53ef, \n         0 1 2 3\n        [1,4,6,10]\n        total # elements - #A\n        (4 - 1 + 1) - (1 - 0 + 1) &gt; k\n\n        Algorithm:\n        - one pass to create such hashmap\n        - iterate all items() in the hashmap where len() &gt;= 2.\n            - initialize left,right = 0,1\n            - move left pointer when we need to delete more than k\n            - move right pointer when can delete more!\n        \"\"\"\n        hashmap = defaultdict(list)\n        res = 0\n        for i,num in enumerate(nums):\n            hashmap[num].append(i)\n\n        for ids in hashmap.values():\n            left = 0\n            for right in range(len(ids)):\n                if (ids[right] - ids[left] + 1) - (right - left + 1) &gt; k:\n                    left += 1\n\n            # right out of index by 1\n            res = max(res,right - left + 1)\n        return res            \n</code></pre>","tags":["Array","Sliding Window","Hash Table"]},{"location":"leetcode/2831-find-the-longest-equal-subarray/#approach-2-on-in-time-o1-in-space","title":"Approach 2: O(n) in time &amp; O(1) in space","text":"<p>Some intuition:</p> <ul> <li>delete at most k elements from the subarray, \u4e5f\u5c31\u662f\u4f60\u53ef\u4ee5delete up to k elements.</li> <li>optimal solution <code>[num,num,num]</code> has element <code>num</code>. It must be in the element shows up with maximum frequency so far.</li> </ul> <p>\u6211\u4eecdecompose\u4e00\u4e0b\u8fd9\u4e2a\u95ee\u9898:</p> <ul> <li>\u627e\u5230\u4ee5index 0\u4e3a\u7ed3\u5c3e\u7684\uff0c\u91cc\u9762\u5305\u542b\u622a\u6b62\u52300\u4e3a\u6b62\u51fa\u73b0\u6700\u591a\u6b21\u6570\u7684\u5143\u7d20x, \u4e14\u80fd\u591f\u5220\u9664\u81f3\u591ak\u4e2a\u5143\u7d20</li> <li>\u627e\u5230\u4ee5index 1\u4e3a\u7ed3\u5c3e\u7684\uff0c\u91cc\u9762\u5305\u542b\u622a\u6b62\u52301\u4e3a\u6b62\u51fa\u73b0\u6700\u591a\u6b21\u6570\u7684\u5143\u7d20x, \u4e14\u80fd\u591f\u5220\u9664\u81f3\u591ak\u4e2a\u5143\u7d20</li> <li>...</li> <li>\u627e\u5230\u4ee5index n-1\u4e3a\u7ed3\u5c3e\u7684\uff0c\u91cc\u9762\u5305\u542b\u622a\u6b62\u5230n-1\u4e3a\u6b62\u51fa\u73b0\u6700\u591a\u6b21\u6570\u7684\u5143\u7d20x, \u4e14\u80fd\u591f\u5220\u9664\u81f3\u591ak\u4e2a\u5143\u7d20</li> </ul> <p>Tip</p> <p><code>max_freq</code>\u7684\u5b9a\u4e49\u4e3a\uff0c\u4ee50\u4e3a\u8d77\u70b9\uff0cright\u4e3a\u7ed3\u5c3e\u7684subarray\u4e2d\u51fa\u73b0\u6700\u591a\u6b21\u6570\u7684\u5143\u7d20\u7684\u9891\u7387. \u6216\u8005\u8bf4historical max frequency\uff0c\u5e76\u4e0d\u662f\u76ee\u524dsubarray\u4e2d\u7684\u6700\u5927\u9891\u7387.</p> <pre><code>from collections import Counter\nclass Solution:\n    def longestEqualSubarray(self, nums: List[int], k: int) -&gt; int:\n        max_freq = 0\n        left = 0\n        count = Counter()\n\n        for right,num in enumerate(nums):\n            count[num] += 1\n            max_freq = max(max_freq,count[num])\n            # when \u9700\u8981\u5220\u9664\u7684\u6570\u5b57 &gt;  \u81f3\u591a\u88ab\u5220\u9664k; too many to delete\n            # \u79fb\u52a8left pointer, \u4f46\u4e3a\u4ec0\u4e48\u53ea\u79fb\u52a8\u4e00\u6b21?\n            if right - left + 1 - max_freq &gt; k:\n                count[nums[left]] -= 1\n                left += 1\n\n        return max_freq\n</code></pre> <p>\u6709\u51e0\u4e2a\u95ee\u9898\u9700\u8981\u89e3\u7b54\u4e00\u4e0b:</p> <ul> <li>\u79fb\u52a8\u5de6\u6307\u9488\uff0c\u4e14update hashmap, \u6211\u4eec\u51cf\u5c11\u7684\u5143\u7d20<code>nums[left]</code>\u96be\u9053\u51cf\u5c11max_freq\u5417\uff1f<ul> <li>\u65e0\u6240\u8c13\uff0c\u53cd\u6b63<code>res = max_freq</code> at end of the day. Nothing changes.</li> </ul> </li> </ul>","tags":["Array","Sliding Window","Hash Table"]},{"location":"leetcode/2831-find-the-longest-equal-subarray/#_1","title":"\u76f8\u5173\u9898\u76ee","text":"<p>According to vlad and lee:</p> <ul> <li>2808 minimum seconds to equalize a circular array</li> <li>404 longest repeating character replacement</li> <li>2054 maximize the confusion of an exam</li> </ul>","tags":["Array","Sliding Window","Hash Table"]},{"location":"leetcode/2831-find-the-longest-equal-subarray/#reference","title":"Reference","text":"<ul> <li>vlad</li> <li>lee<ul> <li>someone explains lee's solution.</li> </ul> </li> <li>wisdom peak</li> </ul>","tags":["Array","Sliding Window","Hash Table"]},{"location":"leetcode/2864-maximum-odd-binary-number/","title":"2864 Maximum Odd Binary Number","text":"<p>Bit manipulation + Greedy. but i used the hashmap</p>","tags":["Math","String","Greedy"]},{"location":"leetcode/2864-maximum-odd-binary-number/#approach-1-hashmap","title":"Approach 1 Hashmap","text":"<pre><code>class Solution:\n    def maximumOddBinaryNumber(self, s: str) -&gt; str:\n        # odd number, last digit must be 1\n        c = collections.Counter(s)\n\n        num_of_ones = c[\"1\"]\n        res = []\n\n\n        while num_of_ones &gt; 1:\n            print(num_of_ones)\n            res.append(\"1\")\n            num_of_ones -= 1\n\n        num_of_zeros = c[\"0\"]\n        while num_of_zeros &gt; 0:\n            res.append(\"0\")\n            num_of_zeros -= 1\n\n        res.append(\"1\")\n\n        return \"\".join(res)    \n</code></pre>","tags":["Math","String","Greedy"]},{"location":"leetcode/287-find-the-duplicate-number/","title":"287 Find the Duplicate Number","text":"<p>\u8fd9\u9898\u6709\u4fe9constraint:</p> <ul> <li>You must not modify the array (assume the array is read only).</li> <li>You must use only constant, O(1) extra space.</li> </ul> <p>Follow up:</p> <ul> <li>How can we prove that at least one duplicate number must exist in nums?</li> <li>Can you solve the problem without modifying the array nums?</li> </ul> <p>\u8003\u5bdftwo pointers\u7684flyod cycle detection on linked list\u7684\u601d\u60f3\uff0c\u4f46\u662f\u5c06\u6570\u7ec4\u770b\u6210\u4e00\u4e2alinked list\uff0c\u6570\u7ec4\u7684index\u662fnode\uff0c\u6570\u7ec4\u7684\u503c\u662fnext\u6307\u9488\u6307\u5411\u7684node, similar to 142 Linked List Cycle II.</p>","tags":["Array","Two Pointers","Binary Search","Bit Manipulation"]},{"location":"leetcode/287-find-the-duplicate-number/#approach-1-two-pointers","title":"Approach 1: Two Pointers","text":"<p>\u6ca1\u7406\u89e3\uff0cechoxiaolee\u7684\u7b54\u6848.</p> <pre><code>class Solution:\n    def findDuplicate(self, nums: List[int]) -&gt; int:\n        if len(nums) == 1:\n            return -1\n\n        slow = nums[0]\n        fast = nums[nums[0]]\n\n        while slow != fast:\n            slow = nums[slow]\n            fast = nums[nums[fast]]\n\n        fast = 0\n        while fast != slow:\n            fast = nums[fast]\n            slow = nums[slow]\n\n        return slow\n</code></pre>","tags":["Array","Two Pointers","Binary Search","Bit Manipulation"]},{"location":"leetcode/287-find-the-duplicate-number/#approach-2-binary-search","title":"Approach 2 Binary Search","text":"<pre><code>class Solution:\n    def findDuplicate(self, nums: List[int]) -&gt; int:\n        # 'low' and 'high' represent the range of values of the target\n        low = 1\n        high = len(nums) - 1\n\n        while low &lt;= high:\n            cur = (low + high) // 2\n            count = 0\n\n            # Count how many numbers are less than or equal to 'cur'\n            count = sum(num &lt;= cur for num in nums)\n            if count &gt; cur:\n                duplicate = cur\n                high = cur - 1\n            else:\n                low = cur + 1\n\n        return duplicate\n</code></pre>","tags":["Array","Two Pointers","Binary Search","Bit Manipulation"]},{"location":"leetcode/2958-length-of-longest-subarray-with-at-most-k-frequency/","title":"2958 Length of Longest Subarray with at Most K Frequency","text":"<p>classic sliding window problem.</p>","tags":["Array","Hash Table","Sliding Window"]},{"location":"leetcode/2958-length-of-longest-subarray-with-at-most-k-frequency/#approach-1-sliding-window","title":"Approach 1 Sliding Window","text":"<pre><code>from collections import defaultdict\nclass Solution:\n    def maxSubarrayLength(self, nums: List[int], k: int) -&gt; int:\n        \"\"\"\n        maximum freq &lt;= k &lt;--&gt; good, \n        intuition:\n            - subarray --&gt; sliding window + hash table as the counter\n        traverse the right pointer, maintain a counter, a global max, you wish to update it every step\n        and update global_max = max(global_max,local_max) if necessary, until global_max &gt; k, \n        you try to remove the left pointer and those char are already in the hashtable key space        \n        \"\"\"\n        res = 0        \n        hashtable = defaultdict(int)\n        left = 0\n\n        for right,num in enumerate(nums):\n            hashtable[num] += 1\n\n            while hashtable[num] &gt; k and left &lt; right:\n                hashtable[nums[left]] -= 1            \n                left += 1\n\n            # if reach here, we must have a subarray that's good\n            res = max(res,right - left + 1)\n\n        return res\n</code></pre>","tags":["Array","Hash Table","Sliding Window"]},{"location":"leetcode/2962-count-subarrays-where-max-element-appears-at-least-k-times/","title":"2962 Count Subarrays Where Max Element Appears at Least K Times","text":"<p>\u6700\u4f18\u89e3O(n), O(1)</p>","tags":["Array","Sliding Window"]},{"location":"leetcode/2962-count-subarrays-where-max-element-appears-at-least-k-times/#approach-1-sliding-window","title":"Approach 1 Sliding Window","text":"<p>\u5148\u8bb2O(n), O(n)\u7684\u89e3\u6cd5, \u628a\u8fd9\u4e2a\u95ee\u9898\u5206\u89e3\u3002\u6211\u4eec\u628a\u7b26\u5408\u6761\u4ef6\u7684\u6240\u6709subarray, \u53d8\u4e3a</p> <ul> <li>\u627e\u5230\u6700\u77ed\u7684subarray, \u6ee1\u8db3\u4ee5index 0\u7ed3\u5c3e\u4e14\u7b26\u5408\u6700\u5927\u503c\u51fa\u73b0\u6b21\u6570\u5927\u4e8e\u7b49\u4e8ek</li> <li>\u627e\u5230\u6700\u77ed\u7684subarray, \u6ee1\u8db3\u4ee5index 1\u7ed3\u5c3e\u4e14\u7b26\u5408\u6700\u5927\u503c\u51fa\u73b0\u6b21\u6570\u5927\u4e8e\u7b49\u4e8ek</li> <li>...</li> <li>\u627e\u5230\u6700\u77ed\u7684subarray, \u6ee1\u8db3\u4ee5index n-1\u7ed3\u5c3e\u4e14\u7b26\u5408\u6700\u5927\u503c\u51fa\u73b0\u6b21\u6570\u5927\u4e8e\u7b49\u4e8ek</li> </ul> <p>\u6211\u4eec\u53ef\u4ee5\u7528\u4e00\u4e2ahashmap\u6765\u8bb0\u5f55\u6bcf\u4e2a\u6570\u5b57\u51fa\u73b0\u7684\u6b21\u6570\uff0c\u7136\u540e\u7528sliding window\u5373\u53ef.</p> <pre><code>from collections import defaultdict\nclass Solution:\n    def countSubarrays(self, nums: List[int], k: int) -&gt; int:\n        array_max = max(nums)\n        res = 0\n        left = 0\n        hashmap = defaultdict(int)\n\n        for right,num in enumerate(nums):\n            hashmap[num] += 1            \n            while hashmap[array_max] &gt;= k and left &lt; right:\n                if nums[left] == array_max and hashmap[array_max] == k:\n                    break\n                hashmap[nums[left]] -= 1\n                left += 1\n\n            if hashmap[array_max] &gt;= k:                \n                res += left + 1\n        return res\n</code></pre> <p>\u7136\u540e\u505a\u4e00\u4e0b\u4f18\u5316\uff0c\u6211\u4eec\u53d1\u73b0\u6211\u4eec\u53ea\u5173\u5fc3max element\u7684\u4e2a\u6570\uff0c\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u7528\u4e00\u4e2amax_counter\u6765\u8bb0\u5f55max element\u7684\u4e2a\u6570\uff0c\u8fd9\u6837\u6211\u4eec\u5c31\u53ef\u4ee5\u7528O(1)\u7684\u7a7a\u95f4\u590d\u6742\u5ea6\u6765\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898, instead of a hashmap.</p> <pre><code>from collections import defaultdict\nclass Solution:\n    def countSubarrays(self, nums: List[int], k: int) -&gt; int:\n        array_max = max(nums)\n        res = 0\n        left = 0\n        max_counter = 0\n\n        for right,num in enumerate(nums):\n            if num == array_max:\n                max_counter += 1\n\n            # \u627e\u5230\u4ee5right\u7ed3\u5c3e\uff0c\u6ee1\u8db3\u6761\u4ef6\u7684\u6700\u77edsubarray\n            while max_counter &gt;= k:\n                if nums[left] == array_max:\n                    if max_counter == k:\n                        break\n                    else:\n                        max_counter -= 1\n                left += 1            \n            if max_counter &gt;= k:\n                res += left + 1\n        return res\n</code></pre>","tags":["Array","Sliding Window"]},{"location":"leetcode/2971-find-polygon-with-the-largest-perimeter/","title":"2971 Find Polygon With The Largest Perimeter","text":"<p>Warning</p> <p>\u8fd9\u9898\u5bf9\u6211\u7684\u6700\u5927\u6536\u83b7\u5728\u4e8e\u7406\u89e3why greedy works.</p> <p>\u8fd9\u4e2a\u95ee\u9898\u7684\u7684solution, \u5fc5\u7136\u4f1a\u5b58\u5728\u4e8e\u4ee5\\(num[i]\\)\u4e3a\u6700\u957f\u8fb9\u7684 \\(where\\quad i = 0,1,2,...,n-1\\)\u6700\u5927\u5468\u957f\u7684\u591a\u8fb9\u5f62\u4e4b\u4e2d. \u629b\u5f00\u4ee5\\(nums[0]\\) and \\(nums[1]\\) \u4e3aending element(\u5982\u679csorted, \u6700\u540e\u7684\u4e5f\u662f\u6700\u957f\u7684)\u7684base case\u7684\u8bdd, \u90a3\u4e00\u5171\u5c31\u6709n-2\u4e2a\u5b50\u95ee\u9898.</p>","tags":["Array","Greedy","Sorting","Prefix Sum"]},{"location":"leetcode/2971-find-polygon-with-the-largest-perimeter/#approach-1-sorting-prefix-sum","title":"Approach 1 Sorting + Prefix Sum","text":"<p>\u8fd9\u9898\u770bpolygon\u7684\u5f62\u6210\u6761\u4ef6, The longest side of a polygon is smaller than the sum of the other sides, \u7136\u540e\u6c42\u6700\u5927\u5468\u957f\u7684\u591a\u8fb9\u5f62. \u8f6c\u5316\u8fd9\u4e2a\u6761\u4ef6\u4e3a\u6570\u5b66\u516c\u5f0f\uff0c\u6211\u4eec\u5219\u6709, for a poly with k sides, we have</p> \\[ \\begin{equation} \\sum_{i}^{k-1} a_i = a_1 + a_2 + ... + a_{k-1} &gt; a_k \\end{equation} \\] <p>\u5f53\u4f60\u60f3\u5230\u6700\u5927\u8fb9\u8981\u6ee1\u8db3\u5927\u4e8e\u5176\u5b83\u8fb9\u4e4b\u548c\u7684\u65f6\u5019\uff0c\u6211\u7684\u601d\u8def\u76f4\u63a5\u5c31\u8f6c\u79fb\u5230\u662f\u5426\u662fDP\u95ee\u9898\u4e86, \u867d\u7136\u601d\u8def\u9519\u4e86\uff0c\u4f46\u95ee\u9898\u8f6c\u5316\u662f\u5bf9\u7684\u3002\u8981\u6c42\u4e00\u4e2a\u6570\u7ec4<code>nums</code>\u4e2d\u80fd\u7ec4\u6210\u7684polygon with largest parameters, \u8fd9\u4e2a\u95ee\u9898\u7684\u89e3\u5fc5\u7136\u4f1a\u5728\u4ee5\u4e0b\u7684\u5b50\u95ee\u9898\u4e4b\u4e2d:</p> <ul> <li><code>dp[i]</code> : store the largest possible parameters ending with element <code>i</code> (<code>nums[i]</code>) in the array. </li> <li><code>dp[0:2]</code> == -1, since we need at least 3 elements to form a polygon.</li> </ul> <p>\u7136\u540e\u6211\u4eec\u6ce8\u610f\u5230\uff0c\u5728iterate dp, \u6c42\u6bcf\u4e00\u4e2a<code>dp[i]</code>\u65f6\uff0c\u90fd\u9700\u8981\u77e5\u9053<code>nums[0:i]</code>\u7684\u89e3\uff0c\u4e14\u6bcf\u6b21\u589e\u5e45\u4e3aone element <code>nums[i]</code>, \u90a3\u6211\u4eec\u5e72\u8106\u63d0\u524d\u628a\u8fd9\u4e2a\u6570\u5b57\u7684prefix sum\u8ba1\u7b97\u51fa\u6765\u50a8\u5b58\u5728\u6570\u7ec4\u91cc\u4e0d\u5c31\u597d\u4e86?</p> <p>Note</p> <p>\\(O(nlogn) + O(n) \\approx O(nlogn)\\) in time, \\(O(n)\\) in space</p> <pre><code>class Solution:\n    def largestPerimeter(self, nums: List[int]) -&gt; int:\n        # Condition: if sum(a_1...a_{n-1}) &gt; a_n, then it exists.\n        # BFS: O(n!) in time, O(1) in space\n        # 1. sort them\n        # 2. DP[i]: largest possible parameters ending with element i in the array\n        # 3. initial condition: 0s for all. DP[0:2] == 0\n        # 4. state transition function:\n        # 5. we just need to check if nums[i] &lt; sum(prefixes) if yes, output, if no\n        #    we assign as -1\n\n        n = len(nums)\n        nums.sort()\n\n        # initialize the pre-fix sum\n        prefix_sum = [0 for _ in range(n)]\n        prefix = 0\n        for i in range(n):\n            prefix += nums[i]\n            prefix_sum[i] = prefix\n\n        best = -1\n        candidate = -2\n        for i in range(2,n):\n            if nums[i] &lt; prefix_sum[i-1]:\n                candidate = prefix_sum[i]\n\n            best = max(best,candidate)\n\n        return best\n</code></pre>","tags":["Array","Greedy","Sorting","Prefix Sum"]},{"location":"leetcode/2971-find-polygon-with-the-largest-perimeter/#approach-2-prefix-sum-space-optimized","title":"Approach 2 Prefix Sum Space Optimized","text":"<p>\u505a\u9898\u7684\u65f6\u5019\u6ca1\u60f3\u5230\uff0c\u8fd9\u4e2a<code>prefix_sum</code> array\u53ef\u4ee5\u4e0d\u7528\u7b97\uff0c\u53ef\u4ee5\u8282\u7ea6:</p> <ul> <li>\\(O(n)\\) in space, \u56e0\u4e3a\u4e0d\u9700\u8981\u8fd9\u4e2a<code>prefix_sum</code> array\u4e86</li> <li>two pass solution to one pass solution</li> </ul> <p>Note</p> <p>\\(O(nlogn) + O(n) \\approx O(nlogn)\\) in time, \\(O(1)\\) in space</p> <pre><code>class Solution:\n    def largestPerimeter(self, nums: List[int]) -&gt; int:\n        n = len(nums)\n        nums.sort()\n\n        best = -1\n        prefix_sum = 0\n        for i in range(n):\n            if n &gt;= 2:\n                if nums[i] &lt; prefix_sum:\n                    candidate = prefix_sum + nums[i]\n                    best = max(best,prefix_sum + nums[i])\n\n            prefix_sum += nums[i]\n\n        return best\n</code></pre>","tags":["Array","Greedy","Sorting","Prefix Sum"]},{"location":"leetcode/2974-minimum-number-game/","title":"2974 Minimum Number Game","text":"<p>\u5b9e\u9645\u4e0a\u8003\u70b9\u662fsort the top two numbers.</p> <p>Note</p> <p>Do you know why building a heap with heapify costs \\(O(n)\\) time but sorting costs \\(O(nlogn)\\) time?</p> <pre><code>class Solution:\n    def numberGame(self, nums: List[int]) -&gt; List[int]:\n        # n % 2 == 0 and n &gt;= 2\n        # 1. use a min heap to store the candidates. Heapify \n        # a list (essentially sorting it) is O(n)??\n        # 2. pop till empty, each pop is O(logn) and poping n\n        # items, approx to O(n * logn)\n\n        res = []\n        heapq.heapify(nums)\n\n        while nums:\n            alice = heapq.heappop(nums)\n            bob = heapq.heappop(nums)\n            res.append(bob)\n            res.append(alice)\n\n        return res     \n</code></pre>","tags":["Array","Sorting","Heap (Priority Queue)","Simulation"]},{"location":"leetcode/2997-minimum-number-of-operations-to-make-array-XOR-equal-to-k/","title":"2997. Minimum Number of Operations to Make Array XOR Equal to Zero","text":"","tags":["Array","Bit Manipulation"]},{"location":"leetcode/2997-minimum-number-of-operations-to-make-array-XOR-equal-to-k/#approach-1","title":"Approach 1","text":"<p>To understand this problem a little bit better, and we write an example into the following format:</p> <pre><code>[2,1,3,4] \n\n010\n001\n011\n100\n---xor---\n100\n\nk = 1 = 001\n</code></pre> <p>We need to flip bits such that 100 --&gt; 001.That's the essence of the problem. </p> <p>There is a key observation for XOR product:</p> <ul> <li>XOR product for odd number of 1's in the column, the result is 1</li> <li>XOR product for even number of 1's in the column, the result is 0</li> </ul> <p>We just need to traverse every possible column and count the number of bits that need to be flipped. </p> <p>Algorithm</p> <ul> <li>Calculate the XOR of all elements in the array, <code>x</code></li> <li>traverse every bit of <code>x</code> and <code>k</code> and count the number of bits that need to be flipped.</li> </ul> <p>Note</p> <ul> <li>Time Complexity: O(n)</li> <li>Space Complexity: O(1)</li> </ul>","tags":["Array","Bit Manipulation"]},{"location":"leetcode/2997-minimum-number-of-operations-to-make-array-XOR-equal-to-k/#code-implementation","title":"Code Implementation","text":"<pre><code>class Solution:\n    def minOperations(self, nums: List[int], k: int) -&gt; int:\n        \"\"\"\n        1. choose any element (10\u8fdb\u5236 like 3 = 011)\n        2. flip any bit of your choice (011 --&gt; 111), ans = 7\n        Observation:\n        - for odd number of 1's the result is 1\n        - for even number of 1's the result is 0\n        \"\"\"\n        x = 0\n        for num in nums:\n            x ^= num\n\n        count = 0\n\n        for i in range(32):\n            # a: x's i-th bit is set or not\n            # b: k's i-th bit is set or not\n            a = (x &amp; (1 &lt;&lt; i) != 0)\n            b = (k &amp; (1 &lt;&lt; i) != 0)\n            count += (a != b)\n        return count\n</code></pre>","tags":["Array","Bit Manipulation"]},{"location":"leetcode/3-longest-substring-without-repeating-characters/","title":"3 Longest Substring Without Repeating Characters","text":"","tags":["Hash Table","String","Sliding Window"]},{"location":"leetcode/3-longest-substring-without-repeating-characters/#approach-1-brute-force","title":"Approach 1: Brute Force","text":"<p>The brute force would be:</p> <ul> <li>enumerate all substrings, \\(O(n^2)\\)</li> <li>for each substring, check if it has duplicate, comparing <code>len(substring) == len(set(substring))</code><ul> <li><code>set(substring)</code> is O(k) on average, where k is the length of the substring.</li> </ul> </li> </ul> <p>It rounds to \\(O(kn^2)\\) and If we look at the constraint of the problem, </p> <ul> <li><code>0 &lt;= s.length &lt;= 5 * 10^4</code></li> </ul> <p>It's too much so we have to find a better solution.</p>","tags":["Hash Table","String","Sliding Window"]},{"location":"leetcode/3-longest-substring-without-repeating-characters/#approach-2-sliding-window","title":"Approach 2: Sliding Window","text":"<p>Sliding window problem \u6709\u4ee5\u4e0b\u51e0\u4e2a\u6761\u4ef6\u8981\u5224\u65ad\u4f5c\u4e3aframework:</p> <ul> <li>\u9009\u4ec0\u4e48Auxillary DS (data structure)\u505awindow?<ul> <li>sliding windowing, \u53ef\u4ee5\u9009\u7528<code>list()</code>\u6216\u8005<code>set()</code>\u6765\u505a\u8fd9\u4ef6\u4e8b\u60c5\uff0c\u4f46\u662f\u7531\u4e8e\u6211\u4eec\u9700\u8981\u5224\u65ad\u4e00\u4e2acharacter\u662f\u5426\u662fduplicate inside a string\uff0c\u5982\u679c\u7528list\u4f5c\u4e3asliding window, \u8981\u505alinear search \\(O(n)\\), \u7136\u800chashset \u4e3a $O(1), \u6240\u4ee5\u6211\u4eecprefer <code>set()</code>.</li> </ul> </li> <li>\u4ec0\u4e48\u505awindow\u7684boundary?<ul> <li>maintain <code>left</code> and <code>right</code> pointer (sliding window\u53ef\u4ee5\u8bf4\u662f\u53cc\u6307\u9488\u6cd5\u7684variation)</li> </ul> </li> <li>\u6700\u7b80\u5355\u7684case\u662f\u4ec0\u4e48?\u600e\u4e48implement?<ul> <li>simplest case <code>s = sijgopq</code> non-repeating character. \u4e5f\u5c31\u662f\u4f60\u7684sliding window\u7684\u53f3\u8fb9\u754c(right) traverse the string, \u7531\u4e8e\u6ca1\u6709\u9047\u5230\u8fc7repeating char, left pointer stays at index 0. \u6bcf\u4e00\u6b65\u90fdadd <code>s[right]</code> into the hashset. \u540c\u65f6\u4f60\u6bd4\u8f83\u4e00\u4e0b\u73b0\u5728window\u7684\u957f\u5ea6\u548c\u4e0a\u4e00\u4e2a\u65f6\u6b65\u7684window\u957f\u5ea6\u5373\u53ef;</li> </ul> </li> <li>\u6211\u52a0\u4ec0\u4e48\u6761\u4ef6\u53ef\u4ee5\u4ecesimplest case\u6269\u5c55\u5230general case.<ul> <li>\u5f53\u9047\u5230repeating char, <code>while s[right] in hashset</code>, \u53ef\u4ee5pop\u5de6\u6307\u9488\u6307\u5411\u7684current substring\u6700\u5de6\u8fb9\u7684element, \u7136\u540e\u5de6\u6307\u9488\u8fdb\u4e00\u4f4d\uff0c\u518d\u7ee7\u7eed\u5224\u5b9a<code>s[right] in hashset</code></li> </ul> </li> </ul> <p>Note</p> <p>\u7531\u4e8e\u4f60\u7684<code>hashset</code>\u4e2d\u53ea\u6709unique char, \u4f60\u6839\u672c\u4e0dcare its index. \u4f60\u53ea\u7ba1pop\u6389\u8fd9\u4e2aleft pointer\u6307\u5411\u7684char\u5373\u53ef.</p>","tags":["Hash Table","String","Sliding Window"]},{"location":"leetcode/3-longest-substring-without-repeating-characters/#code-implementation","title":"Code Implementation","text":"<pre><code>class Solution:\n    def lengthOfLongestSubstring(self, s: str) -&gt; int:\n        # slding window (dynamic) using hashset\n        left = 0\n        res = 0\n        hashset = set()\n\n        for right in range(len(s)):\n            # \u5224\u65ad\u65b0\u7684char\u662f\u5426\u5728hashset\u4e4b\u4e2d, O(1)\n            while s[right] in hashset:\n                hashset.remove(s[left])\n                left += 1\n            # \u5047\u8bbe\u8fd9\u4e2astring\u6ca1\u6709\u4efb\u4f55\u91cd\u590d\u7684\uff0c\u4f1a\u8fd9\u4e48\u5199\n            hashset.add(s[right]) # \u52a0\u5165\u65b0\u7684char\n\n            # \u6bd4\u8f83\u5f53\u524dsliding window\u5927\u5c0f\u548c\u4ee5\u524d\u7684\u6700\u5927\u957f\u5ea6\u6253\u64c2\u53f0\n            if right - left + 1 &gt; res:\n                res = right - left + 1\n\n        return res\n</code></pre> <p>\u4f60\u4e5f\u53ef\u4ee5\u7ef4\u62a4\u4e00\u4e2adictionary, \u4f46\u6ca1\u6709set clean.</p> <pre><code>from collections import defaultdict\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -&gt; int:\n        \"\"\"\n        sliding window, same direction,\n        maintain a key space\n        \"\"\"\n        left = 0\n        global_max = 0\n        uniques = defaultdict(int)\n        for right,char in enumerate(s):\n            if char not in uniques:\n                uniques[char] += 1\n            else:\n                # we have to move left pointer here\n                uniques[char] += 1\n                while left &lt; right and uniques[char] &gt; 1:\n                    uniques[s[left]] -= 1\n                    if uniques[s[left]] == 0:\n                        del uniques[s[left]]\n                    left += 1\n            # if reach here, everything in window is unique\n            global_max = max(global_max,right - left + 1)\n        return global_max\n</code></pre>","tags":["Hash Table","String","Sliding Window"]},{"location":"leetcode/300-longest-increasing-subsequence/","title":"Longest Increasing Subsequence","text":"<p>LIS, DP\u7684\u7ecf\u5178\u9898\u76ee, \u7ecf\u5178\u4e09\u95ee:</p> <ul> <li>simplest case\u662f\u4ec0\u4e48?</li> <li>input <code>nums</code> size\u4e3a1\uff0c \u6216\u8005\u662f\u6bcf\u4e2a\u6570\u5217\u7684\u5012\u6570\u7b2c\u4e00\u4e2a\u7684length of LIS\u90fd\u53ea\u67091 (imply backwards iteration)</li> <li>DP[i]: cache\u7684\u662f\u4ee5index i\u4e3a\u8d77\u70b9\u7684LIS\u7684\u957f\u5ea6</li> <li>transition function:</li> </ul> <pre><code>class Solution:\n    def lengthOfLIS(self, nums: List[int]) -&gt; int:\n        # Note: LIS\n        # base cases: \n        # DP[i] definition: \u4ee5index i\u4e3a\u8d77\u70b9\u7684LIS\u7684\u957f\u5ea6\n        # transition function: \n\n        # = 1 case\n        if len(nums) == 1: return 1\n\n        # initialize\n        LIS = [1 for _ in range(len(nums))]\n\n        # \u4ece\u5012\u6570\u7b2c\u4e8c\u4e2aindex, \u505abackward iteration\n        for i in range(len(nums) - 2, -1, -1):\n            # \u5728i\u4e0b\u4e00\u4e2aindex\u5f00\u59cbiteration\n            for j in range(i+1, len(nums)):\n                # \u66f4\u65b0DP function\n                if nums[i] &lt; nums[j]:\n                    LIS[i] = max(LIS[i], LIS[j] + 1) \n\n        return max(LIS)\n</code></pre>"},{"location":"leetcode/3005-count-elements-with-maximum-frequency/","title":"3005 Count Elements with Maximum Frequency","text":"<p>One pass solution\u6bd4\u8f83\u5de7\u5999</p>","tags":["Array","Hash Table","Counting"]},{"location":"leetcode/3005-count-elements-with-maximum-frequency/#approach-1-bucket-sort","title":"Approach 1 Bucket Sort","text":"<p>\u5229\u7528bucket sort, \u5148\u8ba1\u7b97counter, \u518d\u6309frequency\u653e\u5165bucket, \u6700\u540e\u4ece\u540e\u5f80\u524d\u627e\u5230\u6700\u5927\u7684frequency, \u7136\u540e\u8fd4\u56de\u6700\u5927\u7684frequency\u7684\u5143\u7d20\u4e2a\u6570 x frequency.</p> <pre><code>from collections import defaultdict\nclass Solution:\n    def maxFrequencyElements(self, nums: List[int]) -&gt; int:\n        # 1. get max frequency\n        # 2. count how many has that frequency\n        counter = defaultdict(int)\n        for num in nums:\n            counter[num] += 1\n\n        res = 0\n        buckets = [[] for _ in range(len(nums)+1)]\n        for element,freq in counter.items():\n            buckets[freq].append(element)\n\n        for i in range(len(buckets)-1,-1,-1):\n            if buckets[i]:\n                return len(buckets[i]) * i\n</code></pre>","tags":["Array","Hash Table","Counting"]},{"location":"leetcode/3005-count-elements-with-maximum-frequency/#approach-2-one-pass","title":"Approach 2 One-Pass","text":"<p>\u6ca1\u6709\u590d\u6742\u5ea6\u7684\u63d0\u5347\uff0c\u4f46\u662fa lot cleaner with one-pass. \u6211\u4eec\u8981\u89e3\u51b3\u7684\u4e09\u4e2a\u95ee\u9898</p> <ol> <li>Counter for storing frequency with auxillary DS like hash table</li> <li>compute max frequency</li> <li>get total frequency = max frequency x number of elements @ max frequency</li> </ol> <p>\u6700intuitive\u7684\u662f\u4e09\u5206\u5316(bro splitting)\uff0c\u4f46\u6211\u4eec\u53ef\u4ee5\u7528one-pass (compound movement)\u6765\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898. \u89e3\u7684\u65f6\u5019\u6ce8\u610f\u8fd9\u4e2a,</p> <ul> <li>\u5f53\u4f60\u9047\u5230\u65b0\u7684max frequency, \u4ee5\u524d\u7684\u8bb0\u5f55no longer matters, just nuke everything and start over.</li> <li>\u5f53\u4f60\u9047\u5230\u76f8\u540c\u7684max frequency, \u4f60\u53ea\u9700\u8981\u589e\u52a0total frequency.</li> </ul> <pre><code>from collections import defaultdict\nclass Solution:\n    def maxFrequencyElements(self, nums: List[int]) -&gt; int:\n        # one-pass\n        # 1. counter in auxillary DS\n        # 2. max frequency\n        # 3. compute max frequency x number of elements @ max frequency\n        counter = defaultdict(int)\n        max_freq = 0\n        total_freq = 0\n\n        for num in nums:\n            # increase counter by 1\n            counter[num] += 1\n            # check if max frequency still hold\n            if counter[num] &gt; max_freq:\n                # update_max_freq and reset total frequency\n                max_freq = counter[num]\n                total_freq = max_freq\n            elif counter[num] == max_freq:\n                # bump up total frequency\n                total_freq += max_freq\n\n        return total_freq\n</code></pre>","tags":["Array","Hash Table","Counting"]},{"location":"leetcode/304-range-sum-query-2D-immutable/","title":"304 Range Sum Query 2D - Immutable","text":"<p>Prefix Sum\u76842D matrix \u6269\u5c55</p> <ul> <li>pre-processing to get prefix sum matrix (the method is similar to DP in 2D)</li> <li>use dp to get the regional sum of interest in O(1) time</li> </ul>","tags":["Prefix Sum","Array","Matrix","Design"]},{"location":"leetcode/304-range-sum-query-2D-immutable/#approach-1-prefix-sum","title":"Approach 1 Prefix Sum","text":"<p>Prefix sum --&gt; 2D\u7684\u601d\u7ef4\u6269\u5c55, intuition is by <code>inclusion-exclusion</code>,</p> <p></p> <p>The idea of inclusion-exclusion is basically,</p> \\[ SUM(ABCD) = SUM(OD) - SUM(OB) - SUM(OC) + SUM(OA) \\] <p>Then we need to pre-processing and compute a matrix such that we can get the accumulative sum from origin (0,0) to (x,y). This idea is exactly like DP in 2D, as illustrated in the figure below,</p> <p></p> <p>The definition of <code>dp[i][j]</code>: regional sum from (0,0) to (i,j) where i and j are the row and column number.</p> <p>Generalize it </p> \\[ dp[i][j] = \\begin{cases} 0 \\quad \\text{if i = 0 or j = 0}\\\\ dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1] + matrix[i][j] \\quad \\text{otherwise}\\\\ \\end{cases} \\] <p>After you have to pre-processed regional sum matrix, the <code>SUM(ABCD)</code> can be computed by information in <code>dp</code> matrix.</p>","tags":["Prefix Sum","Array","Matrix","Design"]},{"location":"leetcode/304-range-sum-query-2D-immutable/#code-implementation","title":"Code Implementation","text":"<pre><code>class NumMatrix:\n    def __init__(self, matrix: List[List[int]]):\n        self.matrix = matrix\n        # number of rows and columns\n        rows,cols = len(matrix),len(matrix[0])\n\n        # initialize prefix sum (but in 2D): (0,0) to (x,y)\u7684regional sum\n        # \u7b2c\u4e00\u884c\u548c\u7b2c\u4e00\u5217\u536bboundary nodes\n        dp = [[0 for _ in range(cols+1)] for _ in range(rows+1)]  \n        for i in range(rows):\n            for j in range(cols):\n                dp[i+1][j+1] = dp[i+1][j] + dp[i][j+1] + matrix[i][j] - dp[i][j]\n\n        self.dp = dp\n    def sumRegion(self, row1: int, col1: int, row2: int, col2: int) -&gt; int:\n        \"\"\"\n        (row1,col1) - upper left\n        (row2,col2) - lower right\n        \"\"\"\n        return self.dp[row2+1][col2+1] - self.dp[row1][col2+1] - self.dp[row2+1][col1] + self.dp[row1][col1]     \n</code></pre> <p>We can also use a matrix of tuple so we don't worry about boundary as well. Although you don't have to deal with boundary, but you cost more time due to it's generally slower to access a hash table than a list.</p> <pre><code>from collections import defaultdict\nclass NumMatrix:\n    def __init__(self, matrix: List[List[int]]):\n        self.matrix = matrix\n\n        dp = defaultdict(int)\n\n        rows,cols = len(matrix),len(matrix[0])\n\n        for i in range(rows):\n            for j in range(cols):\n                dp[(i,j)] = dp[(i-1,j)] + dp[(i,j-1)] - dp[(i-1,j-1)] + matrix[i][j]\n\n        self.dp = dp\n    def sumRegion(self, row1: int, col1: int, row2: int, col2: int) -&gt; int:\n        return self.dp[(row2,col2)] - self.dp[(row2,col1-1)] - self.dp[(row1-1,col2)] + self.dp[(row1-1,col1-1)]        \n</code></pre>","tags":["Prefix Sum","Array","Matrix","Design"]},{"location":"leetcode/3043-find-the-length-of-the-longest-common-prefix/","title":"3043 Find the Length of the Longest Common Prefix","text":"<p>\u6ce8\u610f\u5230\u8fd9\u4e00\u9898\u7684constrains:</p> <ul> <li><code>1 &lt;= arr1.length, arr2.length &lt;= 5 * 10**4</code></li> <li><code>1 &lt;= arr1[i], arr2[i] &lt;= 10**8</code></li> </ul> <p>\u6211\u4eec\u7684approach\u5982\u4e0b:</p> <ul> <li>\u7528\u4e24\u4e2ahashset\u5206\u522b\u5b58\u50a8\u6240\u6709\u53ef\u80fd\u7684prefix for arr1 and arr2.</li> <li>\u5199\u4e00\u4e2a\u51fd\u6570\uff0c\u8f93\u5165\u4e00\u4e2astring, \u8f93\u51fa\u6240\u6709\u53ef\u80fd\u7684prefix. \u7531\u4e8earr1[i],arr2[i] \\(\\in [1,10^8]\\) , \u6240\u4ee5\u6bcf\u4e2a\u6570\u7684prefix\u6700\u591a\u67099\u4e2a. \u6240\u4ee5\u8fd9\u4e2a\u51fd\u6570\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u662f\\(O(9m)\\approx O(m)\\), \u5176\u4e2d\\(m\\)\u662farr\u957f\u5ea6.</li> <li>\u8fd9\u4e24\u4e2aset\u6c42\u4ea4\u96c6</li> <li>\u6c42\u4ea4\u96c6\u4e2d\u7684\u6700\u957f\u7684prefix</li> </ul> <p>Tip</p> <p>\u628a\u8fd9\u4e00\u9898\u60f3\u8c61\u6210\u6570\u636e\u5e93\u4e2d\uff0c\u4e24\u4e2a\u5927\u8868join\u4e4b\u524d\u7684filtering, \u8fd9\u6837\u4f60\u5c31\u4e0d\u9700\u8981\u505afull table scan on both table, \u7136\u540erun cartesian join\u4e86.</p>"},{"location":"leetcode/3043-find-the-length-of-the-longest-common-prefix/#approach-1-hashset","title":"Approach 1 Hashset","text":"<pre><code>class Solution:\n    def longestCommonPrefix(self, arr1: List[int], arr2: List[int]) -&gt; int:\n        # longest common prefix of (x,y) for x,y in zip(arr1,arr2)\n        # if it's a common prefix, then it must be a prefix in both arrays\n        # \u6709\u70b9\u50cffiltering b4 joining two big tables in SQL\n        # to have two hashset to store the all possible prefix in arr1 and arr2, respectively\n        # (1,10,100) (1000) and (1 ,2 ,3) (4) then we find the intersection between a and b. finally we compute for the longest\n        # arr1[i],arr2[i] \\in (1,10**8)\n        # each val in arr1 or arr2, will has maximum of 9 possible prefixes\n\n        def get_all_prefix(word):\n            \"\"\"\n            give all possible prefix of this word\n            \"\"\"\n            prefixes = []\n            left,right = 0,len(word)-1\n            while left &lt;= right:\n                prefixes.append(word[left:right+1])\n                right -= 1\n            return prefixes\n\n        nums1 = [str(ele) for ele in arr1]\n        nums2 = [str(ele) for ele in arr2]\n\n        set1 = set()\n        set2 = set()\n\n\n        for num in nums1:\n            prefixes = get_all_prefix(num)\n            for prefix in prefixes:\n                set1.add(prefix)\n\n        # O(9 * m) = O(m)\n        for num in nums2:\n            prefixes = get_all_prefix(num)\n            for prefix in prefixes:\n                set2.add(prefix)\n\n        # now we have two hashset, we just find the intersection of it\n        candidates = set.intersection(set1,set2)\n\n        # edge case\n        if len(candidates) == 0: return 0\n\n        res = 0\n        for candidate in candidates:\n            res = max(res, len(candidate))\n\n        return res\n</code></pre>"},{"location":"leetcode/3062-winner-of-the-liked-list-game/","title":"3062 Winner of the Linked List Game","text":"","tags":["Linked List"]},{"location":"leetcode/3062-winner-of-the-liked-list-game/#approach-1-traverse","title":"Approach 1 Traverse","text":"<p>Just simply traverse it and you are good to go.</p> <pre><code># Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def gameResult(self, head: Optional[ListNode]) -&gt; str:\n        # traverse with a counter for score\n        scores = {\n            'Odd' : 0,\n            'Even': 0\n        }\n\n        curr = head\n        while curr:\n            even_power = curr.val\n            curr = curr.next\n            odd_power = curr.val\n            if even_power &gt; odd_power:\n                scores['Even'] += 1\n            elif even_power &lt; odd_power:\n                scores['Odd'] += 1\n\n            curr = curr.next\n\n        if scores['Even'] == scores['Odd']:\n            return 'Tie'\n        elif scores['Even'] &gt; scores['Odd']:\n            return 'Even'\n        else:\n            return 'Odd'\n</code></pre>","tags":["Linked List"]},{"location":"leetcode/3066-minimum-operations-to-exceed-threshold-value-II/","title":"3066 Minimum Operations to Exceed Threshold Value II","text":"<p>According to the constraints, we can guess that the time complexity of the solution should be O(nlogn) or O(nlogk) or O(klogk), where k is the maximum value in the array, n is the length of the array.</p> <p>Constraints:</p> <ul> <li><code>2 &lt;= nums.length &lt;= 2 * 10^5</code></li> <li><code>1 &lt;= nums[i] &lt;= 10^9</code></li> <li><code>1 &lt;= k &lt;= 10^9</code></li> </ul> <p>With that in mind, the brute force solution is to do n operations, each time we remove the smallest two elements and add the result back to the array. It will be</p> <ul> <li>\\(O(nlogn)\\) for initial sorting descending</li> <li>linear pass for n operations<ul> <li>removing the smallest two elements at <code>nums[-1]</code>, <code>nums[-2]</code> with coast of 2 * \\(O(1)\\)</li> <li>adding the result back to the array with binary search \\(O(logn)\\)</li> </ul> </li> </ul> <p>It will be \\(O(nlogn)\\) + \\(O(nlogn)\\) \\(\\approx\\) \\(O(nlogn)\\)</p> <p>But there are something easier than accessing the smallest two elements at tail of the array. We can use a heap to maintain the smallest two elements in the array.</p> <pre><code>from heapq import heapify,heappush,heappop\nclass Solution:\n    def minOperations(self, nums: List[int], k: int) -&gt; int:\n        # min(x,y) * 2 + max(x,y) &gt; max(x,y)\n        # we can maintain a sorted array of the after operations vals\n        \"\"\"\n        [1,1,2,4,9] --&gt; [2,4,9]\n                    --&gt; [3]\n        [2,4,9] --&gt; [4,9]\n        [3]     --&gt; [7]\n\n        [4,9] --&gt; [9]\n        [7]   --&gt; [15]\n        \"\"\"        \n        heapify(nums)\n        res = 0\n\n        # at least 2 elements\n        while len(nums) &gt; 1:\n            small = heappop(nums)\n            second_small = heappop(nums)\n\n            if small &gt;= k:\n                break\n            # update \n            curr = small * 2 + second_small\n            heappush(nums,curr)\n            res += 1\n\n        return res\n</code></pre>","tags":["Array","Heap (Priority Queue)","Simulation"]},{"location":"leetcode/3085-minimum-deletions-to-make-string-k-special/","title":"3085 Minimum Deletions to Make String K-Speical","text":"<p>Contest\u7684\u65f6\u5019\u6ca1\u6709\u60f3\u51fa\u6765\uff0c\u60f3\u7684\u662fbucket sort + sliding window\u6765\u4e0d\u65ad\u7f29\u5c0f\u533a\u95f4.</p>"},{"location":"leetcode/3085-minimum-deletions-to-make-string-k-special/#approach-1-lee215","title":"Approach 1 LEE215","text":"<p>lee215\u592a\u5f3a\u4e86\u3002\u89e3\u6cd5\u601d\u8def\u5982\u4e0b, \u901a\u8fc7\u89c2\u5bdf\u53ef\u4ee5\u5f97\u5230\u4ee5\u4e0b\u51e0\u4e2a\u63a8\u8bba:</p> <ul> <li>bucket sort\u4e4b\u540e\uff0cdelete\u6700\u5c0f\u7684frequency, window\u5f80\u53f3\u79fb\u52a8\u76f4\u5230\u9047\u5230\u975e\u7a7a</li> <li>delete\u6700\u5927\u7684frequency, window\u5de6\u79fb\u52a8\u4e00\u683c</li> </ul> <p>\u5177\u4f53\u5982\u4e0b\u56fe\u6240\u793a,</p> <ul> <li>\u5982\u679c\u5220\u6389<code>'a'</code>,  \u6211\u4eec\u7684windows size decreses from 5 to 3 (\u6709\u4e00\u4e2a\u7a7a\u683c)</li> <li>\u5982\u679c\u5220\u6389<code>'d'</code>,  \u6211\u4eec\u7684windows size decreses from 5 to 4</li> </ul> <p></p> <p>\u4e5f\u5c31\u662f\u8bf4\uff0c\u6211\u4eec\u51cf\u53bb\u5de6\u8fb9\u6700\u4f4e\u7684\u9891\u7387\uff0c\u6027\u4ef7\u6bd4\u662f\u6700\u9ad8\u7684\uff0c\u56e0\u4e3a\u8fd9\u6837\u53ef\u4ee5\u6700\u5927\u9650\u5ea6\u7684\u51cf\u5c11\u5220\u9664\u7684\u5b57\u7b26\u6570\u3002\u4f46\u53f3\u8fb9\u7684\u9891\u7387\u6bcf\u6b21\u51cf\u5c111\u90fd\u4f1a\u5bfc\u81f4window size\u51cf\u5c111\u3002\u4f46\u8fd9\u4e2a\u5e76\u4e0d\u80fd\u5e2e\u52a9\u6211\u4eec\u786e\u5b9a\u5230\u5e95\u662f\u632a\u5de6\u8fb9\u8fd8\u662f\u53f3\u8fb9. \u6240\u4ee5\u8fd9\u91cc\uff0c\u6211\u4eec\u4f7f\u7528\u679a\u4e3e\u7684\u65b9\u6cd5, \u66b4\u529b\u6c42\u89e3\u3002\u4f46\u8fd9\u91cc\u5c31\u4e0d\u80fd\u8f6c\u5316\u4e3a\u503c\u57df\uff0c\u7528bucket sort\u4e86. \u770b\u4e0b\u9762\u7684\u4f8b\u5b50,</p> <pre><code>word = \"dabdcbdcdcd\"\nk = 2\ncounter = {\n    \"a\":1,\n    \"b\":2,\n    \"c\":3,\n    \"d\":5\n}\n</code></pre> <p>\u7531\u4e8e\u4e00\u5171\u53ea\u670924\u4e2a\u5b57\u6bcd\uff0c\u6240\u4ee5\u6211\u4eec\u66b4\u529b\u679a\u4e3e\u4e5f\u53ea\u662f24*24\u6b21\uff0c\u6240\u4ee5\u662f\u53ef\u4ee5\u63a5\u53d7\u7684\u3002\u4f46\u6211\u4eec\u679a\u4e3e\u7684\u65f6\u5019\u8981\u8ba1\u7b97\u4ec0\u4e48\u5462? \u6211\u4eec\u9700\u8981\u8ba1\u7b97\u7684\u662f\u4ee5\u4e0b\u56db\u79cd\u60c5\u51b5\uff0c</p> <ul> <li>\u5f53\u5b8c\u5168\u4e0d\u5220\u9664<code>a</code>\u7684\u65f6\u5019\uff0c\u591a\u5c11\u6b21\u64cd\u4f5c\u624d\u80fd\u5220\u5230window size\u4e3a2.</li> <li>\u5f53\u5b8c\u5168\u4e0d\u5220\u9664<code>b</code>\u7684\u65f6\u5019\uff0c\u591a\u5c11\u6b21\u64cd\u4f5c\u624d\u80fd\u5220\u5230window size\u4e3a2.</li> <li>\u5f53\u5b8c\u5168\u4e0d\u5220\u9664<code>c</code>\u7684\u65f6\u5019\uff0c\u591a\u5c11\u6b21\u64cd\u4f5c\u624d\u80fd\u5220\u5230window size\u4e3a2.</li> <li>\u5f53\u5b8c\u5168\u4e0d\u5220\u9664<code>d</code>\u7684\u65f6\u5019\uff0c\u591a\u5c11\u6b21\u64cd\u4f5c\u624d\u80fd\u5220\u5230window size\u4e3a2.</li> </ul> <p>\u7b54\u6848\u5fc5\u5b9a\u5728\u8fd9\u56db\u4e2a\u503c\u4e2d\uff0c\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u679a\u4e3e\u8fd9\u56db\u4e2a\u503c\uff0c\u7136\u540e\u53d6\u6700\u5c0f\u503c\u5373\u53ef\u3002\u90a3\u4f1a\u4e0d\u4f1a\u6709\uff0c</p> <ul> <li>\u6211\u5220\u9664\u4e861\u4e2a<code>a</code>, \u4f46\u662f\u6211<code>a</code>\u8fd8\u662f\u6700\u540e\u7684window\u7684\u5de6\u8fb9\u754c\u7684\u60c5\u51b5\u5462?</li> </ul> <p>\u7b54\u6848\u662f\u5426\u5b9a\u7684\uff0c\u56e0\u4e3a\u4f60delete\u6700\u5c0f\u7684\u9891\u7387\u7684\u5b57\u6bcdby one\uff0c\u90a3\u4e48\u4f60\u7684window\u7684\u5de6\u8fb9\u754c\u5f80\u5de6\u79fb\u52a8by one, \u6700\u540e\u4f60window\u53cd\u800c\u53d8\u5927\u4e86, \u5982\u4e0b\u56fe\u3002\u6240\u4ee5\u8fd9\u60c5\u51b5\u4e0d\u53ef\u80fd</p> <p></p> <p>\u6240\u4ee5\u5f97\u51fa\u7ed3\u8bba\uff0c\u6700\u4f18\u89e3\u5fc5\u7136\u5728\u5b8c\u5168\u4e0d\u5220\u9664\u67d0\u4e2a\u5b57\u6bcd\u7684\u60c5\u51b5\u4e0b\u83b7\u5f97\u3002\u6211\u4eec\u63a5\u4e0b\u6765\u53ea\u9700\u8981\u8ba1\u7b97\u6210\u672c\u5373\u53ef.</p>"},{"location":"leetcode/3085-minimum-deletions-to-make-string-k-special/#code-implementation","title":"Code Implementation","text":"<pre><code>from collections import Counter\nclass Solution:\n    def minimumDeletions(self, word: str, k: int) -&gt; int:\n        counter = Counter(word).values()\n        res = float('inf')\n\n        for min_freq in counter:\n            cost = 0\n            for freq in counter:\n                # \u6bd4min_freq\u5c0f\u7684\uff0c\u5168\u5220\u9664                \n                if freq &lt; min_freq:\n                    cost += freq\n\n                # \u6bd4min_freq\u5927\u4e14freq - min_freq &gt; 2\uff0c\n                # \u5220until min_freq + k. So move from freq --&gt; min_freq + k\n                if freq &gt;= min_freq + k:\n                    cost += freq - (min_freq + k)\n            res = min(res,cost)\n\n        return res        \n</code></pre>"},{"location":"leetcode/3085-minimum-deletions-to-make-string-k-special/#approach-1-but-with-better-explanation","title":"Approach 1 but with better explanation","text":"<p>Haha. This is the first time i comment on Lee215's solution. Gonna keep it here.</p> <p>I am stunned by the clean solution. Legend. It took a normie like me a while to figure out the intuition you explained. So i am dropping my 2 cents here.</p> <p>If you sort your <code>word = \"dabdcbdcdcd\"</code> by frequency, it looks like, <pre><code>0   1   2   3   4   5\n    a   b   c       d\n</code></pre></p> <p>If we have a window spanning from lower to upper frequencies, the size is 4, the intuition by Lee is that</p> <ul> <li>if we delete left char by 1, our window size increases by 1 (not desirable)</li> <li>if we delete right char by 1, our window size decreases by 1 </li> </ul> <p>We want to minimize the window size so it's within <code>k</code>.  Therefore, we can either </p> <ul> <li>delete largest frequency by 1 to decrease the window size by 1 </li> <li>completely delete the smallest char so our window size will decrease and shift right till it bumps into another char on the way. </li> </ul> <p>How to solve is problem relies on brute force (i.e. enumeration) and it's acceptable since we at most have 26 alphabets O(26*26) at most. Our solution must lie in one of the four scenerios,</p> <ul> <li><code>case 1</code>: don't delete any <code>a</code>, and make <code>a</code> as the smallest frequencies (left boundary), \\(cost_a\\) to make the window size as 2</li> <li><code>case 2</code>: don't delete any <code>b</code>, and make <code>b</code> as the smallest frequencies (left boundary), \\(cost_b\\) to make the window size as 2</li> <li><code>case 3</code>: don't delete any <code>c</code>, and make <code>c</code> as the smallest frequencies (left boundary), \\(cost_c\\) to make the window size as 2</li> <li><code>case 4</code>: don't delete any <code>d</code>, and make <code>d</code> as the smallest frequencies (left boundary), \\(cost_d\\) to make the window size as 2</li> </ul> <p>Solution must be \\(\\min_{i \\in \\{a, b, c, d\\}} {cost}_i\\). Why we can't have solution in like </p> <ul> <li><code>case 5</code>: we delete <code>b</code> by 1 and <code>b</code> has smallest frequency and calculate the cost to make window size as 2</li> </ul> <p>It is because moving smallest frequency by 1 will increase the window by one (with an exception when it only appears once). <code>case 5</code> will always be worse than <code>case 2</code>. This is the intuition lee is saying that \"After deletion,the char with the minimum frequency,must not have been deleted, it's same as its original frequency in word.\"</p> <p>Based on this we just need to enumerate all possible cases to keep every distinct char as minimum frequency characters once and </p> <ul> <li>delete all freq less than minimum frequency of that char</li> <li>delete all freq that satisfies <code>freq &gt; min_freq + k</code></li> </ul> <p>I made a slight variation and my code is here.</p> <pre><code>from collections import Counter\nclass Solution:\n    def minimumDeletions(self, word: str, k: int) -&gt; int:\n        freqs = Counter(word).values()\n        res = float('inf')\n\n        for min_freq in freqs:\n            cost = 0\n            for freq in freqs:\n                # less than min_freq, gotta delete them all\n                if freq &lt; min_freq:\n                    cost += freq\n\n                # greater than min_freq and freq - min_freq &gt; 2\uff0c\n                # we have to delete until it is equal to min_freq + k\n                if freq &gt; min_freq + k:\n                    cost += freq - (min_freq + k)\n            res = min(res,cost)\n\n        return res\n</code></pre>"},{"location":"leetcode/3090-maximum-length-substring-with-two-occurrences/","title":"3090 Maximum Length Substring With Two Occurrences","text":"<p>Given a string s, return the maximum length of a  substring such that it contains at most two occurrences of each character.</p> <p>\u5f88\u7ecf\u5178\u7684hash table\u9898\u76ee\u4e86\uff0c </p>","tags":["Sliding Window","Two Pointers","String","Hash Table"]},{"location":"leetcode/3090-maximum-length-substring-with-two-occurrences/#approach-1-sliding-window","title":"Approach 1 Sliding Window","text":"<p>sliding window, \u5e76\u4e14\u7ef4\u62a4\u4e00\u4e2ahashmap with max size 24 for frequency, \u5bf9\u4e8e\u6bcf\u4e00\u4e2aiteration, </p> <ul> <li>traverse the hashmap to see if there is any character with frequency &gt;= 3, if any, we record them in a <code>hash set</code></li> <li><code>\u5de6\u6307\u9488\u79fb\u52a8\u6761\u4ef6</code>: move the left pointer until the frequency of the character in the hashmap is &lt;= 2. \u6700\u7b80\u5355\u7684\u65b9\u6cd5\u662f\u901a\u8fc7hash set\u662f\u5426\u4e3a\u7a7a\u6765\u5224\u65ad\u662f\u5426\u8fd8\u9700\u8981\u7ee7\u7eed\u79fb\u52a8\u5de6\u6307\u9488.</li> </ul> <p>complexity</p> <ul> <li>time: \\(O(24*n)\\approx O(n)\\)</li> <li>space: \\(O(1)\\)</li> </ul> <pre><code>from collections import defaultdict\nclass Solution:\n    def maximumLengthSubstring(self, s: str) -&gt; int:\n        # sliding window, \n        \"\"\"\n        move right, until we find once occurance &gt; 2\n        \"\"\"\n        global_max = 0\n        left = 0\n        hashmap = defaultdict(int)\n        for right,r_char in enumerate(s):\n            hashmap[r_char] += 1\n            candidates = set()\n            for key,freq in hashmap.items():\n                if freq &gt;= 3:\n                    candidates.add(key)\n            # \n            while candidates and left &lt; right:\n                hashmap[s[left]] -= 1\n                if s[left] in candidates and hashmap[s[left]] &lt;= 2:\n                    candidates.remove(s[left])                    \n                left += 1\n\n            # if ever reach here, we can see if it matches\n            global_max = max(global_max,right - left + 1)\n\n        return global_max\n</code></pre>","tags":["Sliding Window","Two Pointers","String","Hash Table"]},{"location":"leetcode/3091-apply-operations-to-make-sum-of-array-greater-than-or-equal-to-k/","title":"3091 Apply Operations to Make Sum of Array Greater than or Equal to K","text":"<p>Greedy approach that humbles me. \u5206\u89e3\u8fd9\u4e2atotal operations into two parts,</p> <pre><code>total_ops = addition_ops + duplication_ops\n</code></pre> <p>\u5148\u6267\u884caddition_ops, \u518d\u6267\u884cduplication_ops, \u56e0\u4e3a\u4e58\u6cd5\u7684\u6548\u679c\u66f4\u5927\uff0c\u6240\u4ee5\u6211\u4eec\u5e0c\u671b\u5148\u628a\u4e58\u6cd5\u7684\u6548\u679c\u6700\u5927\u5316\uff0c\u7136\u540e\u518d\u7528\u52a0\u6cd5\u6765\u586b\u8865\u5dee\u8ddd. </p> <p>Tip</p> <p>\u52a0\u6cd5\u7684\u6548\u679c\u5c31\u50cf\u8bfe\u4f59\u65f6\u95f4\u5b66\u4e60\u57fa\u7840\u77e5\u8bc6\u4e00\u6837\uff0c\u5f53\u4f60\u57fa\u7840\u6253\u597d\u4e86, \u5c06\u6765\u505a\u4e58\u6cd5(\u5b66\u4e60\u5de5\u4f5c\u4e2d\u7528\u7684\u6846\u67b6)\u4f1a\u66f4\u52a0\u5f97\u5fc3\u5e94\u624b.</p> <p>\u4e0d\u641e\u865a\u5934\u5df4\u8111\u7684\uff0c\u770b\u770b\u8bc1\u660e, </p> <pre><code>if addition\n[1] -&gt; [2]\nif duplication\n[1] -&gt; [1,1]\n</code></pre> <p>\u5373\u4f7f\u5728\u7b2c\u4e00\u6b65\u7684\u60c5\u51b5\u4e0b\uff0caddition\u548cduplication\u7684\u5bf9\u4e8e\u63d0\u5347array sum\u7684\u6548\u679c\u90fd\u662f\u4e00\u6837\u7684\u3002\u6240\u4ee5addition\u7684\u552f\u4e00\u76ee\u7684\u662f\u4e3a\u4e86\u84c4\u529b\uff0c\u4e3a\u4e86\u66f4\u597d\u7684duplication. \u53ef\u4ee5\u628a\u5b83\u60f3\u6210\u4e00\u4e2a\u5f00\u53e3\u5411\u4e0b\u7684\u4e8c\u5143\u4e00\u6b21\u51fd\u6570, </p> <p></p> <p>\u53cd\u601d</p> <p>\u6bd4\u8d5b\u7684\u65f6\u5019\u6211\u4e00\u76f4\u5728\u601d\u8003\u7684\u662fO(1)\u89e3\uff0c\u4e8c\u5143\u4e00\u6b21\u65b9\u7a0b\u5f0f\u6c42\u5bfc, \u76f4\u63a5\u60f3\u51fa\u6765\u662f\u5f88\u96be\u7684\uff0c\u5fc5\u987b\u8981\u5f88\u4f1a\u627e\u89c4\u5f8b\u3002\u800c\u6211\u5e94\u8be5\u505a\u7684\uff0c\u662f\u5148\u8003\u8651\u679a\u4e3e\u3002\u6211\u4e3a\u4ec0\u4e48\u8be5\u8003\u8651enumerate\u56e0\u4e3ak &lt; 10^5, it's still reasonable to have O(k) solution. \u5f53\u4f60\u60f3\u660e\u767d\u53ef\u4ee5addition and duplication\u662f\u5148\u540e\u987a\u5e8f\uff0c\u5e76\u4e0d\u4e92\u76f8\u5f71\u54cd\u7684\u65f6\u5019\uff0c\u5c31\u7b80\u5316\u4e86\u5f88\u591a.</p> <p>\u638c\u63e1\u7684\u77e5\u8bc6\u70b9\u662f\uff0c</p> <ul> <li>\u81f3\u5c11\u9700\u8981\u591a\u5c11\u4e2a x \u624d\u80fd\u5927\u4e8ek? <code>ceil(k/x)</code>, \u8fd9\u4e2a\u5f88\u5b9e\u7528.</li> </ul>","tags":["Greedy"]},{"location":"leetcode/3091-apply-operations-to-make-sum-of-array-greater-than-or-equal-to-k/#approach-1-greedy-ok","title":"Approach 1 Greedy O(k)","text":"<p>Larry\u7684\u89e3\u6cd5\u975e\u5e38\u7b80\u5355\uff0cbrute force\u4e00\u4e0b, \u7b97\u6cd5\u5982\u4e0b:</p> <p>\u679a\u4e3e\u51fa\u6240\u6709number of addition\u7684\u53ef\u80fd\u6027(\u6700\u5c11\u4e0d\u52a0<code>0</code> \u5230\u6700\u591a<code>k-1</code>)\uff0c\u7136\u540e\u76f8\u5e94\u7684\u8ba1\u7b97\u51fanumber of duplication\u7684\u6b21\u6570\uff0c\u6700\u540e\u53d6\u6700\u5c0f\u503c</p> <p>linear scan\u6240\u6709\u7684\u53ef\u80fd\u6027:</p> <ul> <li>number of addition: <code>i</code></li> <li>\u90a3\u4e48addition\u540e\u7684\u503c\u5c31\u662f<code>i+1</code> cuz we start from 1</li> <li>\u90a3\u4e48\u4e4b\u540e\u7684solution array\u4e3a<code>[i+1,i+1,i+1,...]</code>, \u6211\u4eec\u8981\u6c42\uff0c\u8981\u591a\u5c11\u4e2a\u8fd9\u4e2a<code>i+1</code> \u624d\u80fd\u8d85\u8fc7<code>k</code>, like <code>math.ceil(k//(i+1))</code></li> <li>\u4f46\u6211\u4eec\u5728addition operations\u540e\uff0c\u6211\u4eec\u7684array\u4e3a<code>[i+1]</code>, \u5df2\u7ecf\u6709\u4e00\u4e2a\u4e86\uff0c\u6240\u4ee5\u53ea\u9700\u8981<code>math.ceil(k//(i+1)) - 1</code>\u4e2aduplication\u64cd\u4f5c.</li> </ul> <p>To visualize this, we populate a solution space of <code>k=300</code>, we can clearly see the parabolic shape of the solution space,</p> <p></p> <pre><code>class Solution:\n    def minOperations(self, k: int) -&gt; int:\n        best = k-1\n\n        for i in range(k):\n            num_of_addition = i\n            # -1\u56e0\u4e3a\u4f60\u5df2\u7ecf\u6709\u4e00\u4e2a\u6570\u5728nums\u4e2d\u4e86\n            # (k+i)//(i+1),\n            \"\"\"\n            addition\u540e\u7684\u503c\u662f i+1 \u6700\u540earray\u662f\n            [i+1 ,i+1 ,i+1 ,i+1 ,....]\n            \u6211\u4eec\u8981\u6c42\uff0c\u8981\u591a\u5c11\u4e2a\u8fd9\u4e2a i+1 \u624d\u80fd\u8d85\u8fc7k, like math.ceil(k//(i+1))\n            \"\"\"\n            num_of_duplication = math.ceil(k/(i+1)) - 1\n            best = min(best,num_of_addition + num_of_duplication)\n        return best\n</code></pre>","tags":["Greedy"]},{"location":"leetcode/3091-apply-operations-to-make-sum-of-array-greater-than-or-equal-to-k/#approach-2-lee-o1","title":"Approach 2 Lee O(1)","text":"<p>Lee\u4e5f\u592a\u53d8\u6001\u4e86, \u6bd4\u8d5b\u4e2d\u60f3\u51fa\u8fd9\u73a9\u610f.</p> <pre><code>class Solution:\n    def minOperations(self, k: int) -&gt; int:\n        v = round(math.sqrt(k))\n        return v + (k - 1) // v - 1\n</code></pre>","tags":["Greedy"]},{"location":"leetcode/3091-apply-operations-to-make-sum-of-array-greater-than-or-equal-to-k/#reference","title":"Reference","text":"<ul> <li>Programming Live with Larry</li> <li>Aryan Mittal</li> </ul>","tags":["Greedy"]},{"location":"leetcode/3092-most-frequent-ids/","title":"3092 Most Frequent IDs","text":"<p>\u6bd4\u8d5b\u65f6\u60f3\u51fa\u6765\u4e86max heap, but\u6211\u5c45\u7136\u5728\u5206\u7c7b\u8ba8\u8bba\u5404\u79cd\u60c5\u51b5\uff0c\u4f46\u4e0d\u7528\u90a3\u4e48\u590d\u6742. Lee215 solution here.</p> <pre><code>Input: nums = [2,3,2,1], freq = [3,2,-3,1]\n\nOutput: [3,3,2,2]\n\nExplanation:\n\nAfter step 0, we have 3 IDs with the value of 2. So ans[0] = 3.\nAfter step 1, we have 3 IDs with the value of 2 and 2 IDs with the value of 3. So ans[1] = 3.\nAfter step 2, we have 2 IDs with the value of 3. So ans[2] = 2.\nAfter step 3, we have 2 IDs with the value of 3 and 1 ID with the value of 1. So ans[3] = 2.\n</code></pre> <p>\u53cd\u601d</p> <p>\u7ef4\u62a4max heap and hash table for ground truth. \u96be\u70b9\u5728\u4e8e\u600e\u4e48\u5b9a\u4e49\u8fd9\u4e2amax heap</p> <ul> <li><code>max_heap[t]</code>: At iteration <code>t</code>, \u6240\u6709\u6700\u597d\u7684\u5386\u53f2\u8bb0\u5f55 including <code>curr</code>. \u4f46\u4e00\u65e6\u5386\u53f2\u8bb0\u5f55\u4e2d\uff0c\u6709\u54ea\u4e9b\u6570\u88ab\u66f4\u65b0\u4e86, \u5c31\u9700\u8981pop\u51fa\u6765, \u4f46\u4e0d\u662f\u73b0\u5728.</li> <li>\u6211\u6bd4\u8d5b\u7684\u65f6\u5019\u90fd\u5728\u5206\u7c7b\u8ba8\u8bba\uff0c\u600e\u4e48\u628a\u8fd9\u4e9b\u9700\u8981\u88ab\u66f4\u65b0\u7684\u6570\u4eceheap\u4e2dpop\u51fa\u6765, \u4f46\u6211\u4eec\u5176\u5b9e\u5e76\u4e0d\u9700\u8981\u9a6c\u4e0apop\u51fa\u6765, \u6211\u4eec\u53ea\u9700\u8981\u5728\u7528\u7684\u65f6\u5019pop\u51fa\u6765\u3002\u600e\u4e48\u5b9a\u4e49\u7528\u7684\u65f6\u5019\uff0c\u5c31\u662f\u6211\u4eec\u5f04\u7684\u65f6\u5019, \u4e5f\u5c31\u662fappend to res\u4e4b\u524d.</li> </ul> <p>\u8fd9\u4e2a\u80cc\u540e\u7684\u601d\u60f3\u5f88\u91cd\u8981\uff0c\u6709\u70b9\u50cflazy evaluation, \u6211\u4eec\u53ea\u5728\u9700\u8981\u7684\u65f6\u5019\u624d\u53bbheappop()\u88abupdate\u540e\u7684\u503c. \u5373\u4f7f\u5386\u53f2\u6570\u636ecluster\u5728heap\u4e2d\uff0cworst case\u4e5f\u53ea\u4f1a\u5360\u636eO(n)\u7684\u7a7a\u95f4. \u65e0\u5173\u7d27\u8981\u7684.</p>","tags":["Heap","Hash Table"]},{"location":"leetcode/3092-most-frequent-ids/#approach-1-max-heap-hash-table","title":"Approach 1: Max Heap + Hash Table","text":"<p>Bookkeeping problem, \u7ef4\u62a4\u4e24\u4e2a\u6570\u636e\u7ed3\u6784,</p> <ul> <li><code>hash table</code>: as the source of truth</li> <li><code>max heap</code>: to keep track of the most frequent id, as a tuple (-freq,id). \u8fd9\u91cc\u50a8\u5b58\u7684\u662f\u5386\u53f2\u6240\u6709\u7684\u6700\u5927\u503c\uff0c\u4e00\u65e6\u88ab\u4fee\u6539\uff0c\u6240\u6709\u5f71\u54cdtop of heap\u7684, \u90fd\u5fc5\u987bpop\u51fa\u6765.</li> </ul> <p>\u6700\u5173\u952e\u7684\u4e00\u70b9\u662f\u60f3\u660e\u767d,</p> <p>\u5f53\u524d\u7684\u6700\u4f18\u89e3\u4e00\u5b9a\u51fa\u73b0\u5728\u4ee5\u4e0b\u4e09\u79cd\u60c5\u51b5\u4e2d:</p> <ul> <li>brand new\u7684\u503c like (freq, id) as (100000, 5)</li> <li>\u88ab\u7be1\u6539id\u7684\u5386\u53f2\u6700\u5927\u503c\u4e2d(\u4e5f\u5c31\u662f\u8bf4\u8981\u628a\u8001\u7684pop\u6389), \u901a\u5e38\u4f34\u968f\u7740positive freq operations.</li> <li>\u6ca1\u6709\u88ab\u7be1\u6539\u8fc7\u7684\u5386\u53f2\u6700\u5927\u503c\u4e2d, \u901a\u5e38\u4f34\u968f\u7740negative freq operations.</li> </ul> <p>\u7b97\u6cd5\u5982\u4e0b,</p> <ul> <li>linear scan the input<ul> <li>update the hash table for source of truth</li> <li>push the (-freq,id) tuple into the max heap.</li> <li>\u53ea\u8981<code>source of truth</code>\u548cmax heap\u7684frequency\u4e0d\u540c\uff0c\u5c31\u5168pop\u51fa\u6765. \u4ee3\u8868\u7684\u610f\u4e49\u662f\uff0c\u5386\u53f2\u6700\u5927\u503c\u7684id\u88ab\u66f4\u65b0\u8fc7\u4e86\uff0c\u6240\u4ee5\u9700\u8981pop\u51fa\u6765\uff0c\u6ca1\u6709\u4ef7\u503c\u4e86. \u8fd9\u65f6\u5019\u51e0\u79cd\u60c5\u51b5:<ul> <li>push\u8fdb\u53bb\u7684\u521a\u597d\u662fheap[0], \u6211\u4eec\u76f4\u63a5\u62ff\u51fa\u6765.</li> <li>push\u8fdb\u53bb\u7684\u4e0d\u662fheap[0], \u4f46\u6211\u4eecmax heap\u4e2d\u4e4b\u524d\u7684\u66f4\u6539\u8fc7\u7684\u5386\u53f2\u6700\u5927\u503c\u5168\u90e8pop\u51fa\u53bb\uff0c\u5269\u4e0b\u7684\u5c31\u662f\u65b0\u7684\u6700\u5927\u503c.</li> </ul> </li> </ul> </li> </ul> <p>Tip</p> <p>heap\u4e00\u5b9a\u4e0d\u4e3a\u7a7a\uff0c\u56e0\u4e3a\u6211\u4eec\u5148heappush(heap,(-count[i],i)), \u6240\u4ee5\u81f3\u5c11\u8fd8\u6709\u521apush\u7684\u503c\u5728\u91cc\u9762.</p> <pre><code>from collections import Counter\nclass Solution:\n    def mostFrequentIDs(self, nums: List[int], freq: List[int]) -&gt; List[int]:\n        # maintain a max heap\n        heap = []\n        count = Counter()\n        res = []\n\n        for i,f in zip(nums,freq):\n            count[i] += f\n            # push in the id\n            heappush(heap,(-count[i],i))\n            # \u53ea\u8981hashmap\u4e2d\u7684\u503c\u548cmax heap\u4e2d\u7684\u503c\u4e0d\u540c\uff0c\u5168pop\u51fa\u6765\n            while heap and count[heap[0][1]] != -heap[0][0]:\n                heappop(heap)\n            res.append(-heap[0][0] if heap else 0)\n\n        return res\n</code></pre> <p>More cleaner</p> <pre><code>from collections import Counter\nclass Solution:\n    def mostFrequentIDs(self, nums: List[int], freq: List[int]) -&gt; List[int]:\n        # maintain a max heap\n        heap = []\n        count = Counter()\n        res = []\n\n        for i,f in zip(nums,freq):\n            count[i] += f\n            # push in the id\n            heappush(heap,(-count[i],i))\n            # \u53ea\u8981hashmap\u4e2d\u7684\u503c\u548cmax heap\u4e2d\u7684\u503c\u4e0d\u540c\uff0c\u5168pop\u51fa\u6765\n            while count[heap[0][1]] != -heap[0][0]:\n                heappop(heap)\n            res.append(-heap[0][0])\n\n        return res\n</code></pre>","tags":["Heap","Hash Table"]},{"location":"leetcode/3095-shortest-subarray-with-OR-at-least-K-I/","title":"3095 Shortest Subarray with OR at Least K I","text":"","tags":["Bit Manipulation"]},{"location":"leetcode/3095-shortest-subarray-with-OR-at-least-K-I/#approach-1-brute-force","title":"Approach 1 Brute Force","text":"<pre><code>class Solution:\n    def minimumSubarrayLength(self, nums: List[int], k: int) -&gt; int:\n        \"\"\"\n        observation:\n        - special \n        - shortest\n        \"\"\"        \n        n = len(nums)\n        res = n+1\n\n        for j in range(n):\n            for i in range(j+1):\n                candidate = 0\n                for stuff in nums[i:j+1]:\n                    candidate |= stuff\n                if candidate &gt;= k:\n                    res = min(res,j - i + 1)\n\n        return res if res != n+1 else -1\n</code></pre>","tags":["Bit Manipulation"]},{"location":"leetcode/3096-minimum-levels-to-gain-more-points/","title":"3096 Minimum Levels to Gain More Points","text":"<p>\u6700\u4f18\u89e3O(n) in time, O(1) in space. Prefix sum\u7684\u9898\u76ee.</p>"},{"location":"leetcode/3096-minimum-levels-to-gain-more-points/#approach-1-prefix-sum","title":"Approach 1 Prefix Sum","text":"<p>Observation:</p> <ul> <li>nums[i] == 0, \u62631\u5206; nums[i] == 1, \u52a01\u5206</li> <li>daniel starting from level 0, and bob starting from where daniel left the game</li> <li>daniel \u548c bob\u81f3\u5c11\u5404\u73a9\u4e00\u6b21</li> </ul> <pre><code>class Solution:\n    def minimumLevels(self, possible: List[int]) -&gt; int:\n        \"\"\"\n        nums[i] == 0 then it's impossible\n\n         0 1 2 3\n        [1,0,1,0]\n\n        we convert it to binary\n        [1,-1,1,-1]\n        Objective:\n        - we tryna find the minimum length of subarray starting at index 0, such that the remaining subarray won't outscore it\n        \"\"\"\n        nums = [-1 if num == 0 else num for num in possible]\n        res = - 1\n        n = len(nums)\n\n        daniel = 0\n        bob = sum(nums)\n        for i,num in enumerate(nums):\n            bob -= num\n            daniel += num\n            if daniel &gt; bob and i != n-1:\n                return i + 1\n\n        return res\n</code></pre> <p>\u8fdb\u884c\u4f18\u5316,</p> <ul> <li>\u53ef\u4ee5\u4e0d\u9700\u8981O(n)\u6570\u7ec4\u6765flip 0 to -1. \u6211\u4eec\u53ef\u4ee5\u76f4\u63a5\u5728\u539f\u6570\u7ec4\u4e0a\u64cd\u4f5c, \u591a\u4e00\u4e9b\u5224\u5b9a\u8bed\u53e5\u7f62\u4e86.</li> </ul> <pre><code>class Solution:\n    def minimumLevels(self, possible: List[int]) -&gt; int:\n        res = - 1\n        n = len(possible)\n\n        daniel = 0\n        # sum(possible): \u591a\u5c11\u4e2a1; n: \u603b\u5171\u591a\u5c11\u4e2a\u6570\u5b57;\n        bob = sum(possible) - 1 * ( n - sum(possible))\n\n        for i,num in enumerate(possible):\n            # daniel\u52a0\u5206\uff0cbob\u51cf\u5206\n            daniel += 1 if num else -1\n            bob += -1 if num else 1\n            if daniel &gt; bob and i != n-1:\n                return i + 1\n\n        return res\n</code></pre>"},{"location":"leetcode/3097-shortest-subarray-with-OR-at-least-K-II/","title":"3097 Shortest Subarray with OR at Least K II","text":"","tags":["Sliding Window","Array","Bit Manipulation"]},{"location":"leetcode/3097-shortest-subarray-with-OR-at-least-K-II/#approach-1-sliding-window","title":"Approach 1: Sliding Window","text":"<p>Some key observation:</p> <ul> <li>\u6211\u4eec\u4e0d\u65ad\u7684or operation, \u5176\u5b9e\u548cprefix_sum\u4e00\u6837\uff0c\u4f60\u53ea\u4f1a\u589e\u52a0\u6216\u4e0d\u53d8\uff0c\u4f46\u4e0d\u4f1a\u51cf\u5c11, \u6697\u793a\u53ef\u80fd\u662fsliding window</li> <li>\u5f53\u4f60\u79fb\u9664\u5de6\u8fb9\u754c\u7684\u65f6\u5019\uff0c\u4f60\u8981undo\u8fd9\u4e2aoperation, \u8fd9\u4e2a\u64cd\u4f5c\u4f1a\u4f7f\u5f97prefix_sum\u51cf\u5c11\u6216\u4e0d\u53d8</li> </ul> <p>\u8fd9\u4e00\u70b9\uff0c\u6211\u4eec\u53ef\u4ee5\u5224\u65ad\u51fa\uff0c\u8fd9\u662f\u4e00\u4e2asliding window\u7684\u9898\u76ee. \u96be\u70b9\u5728\u4e8e\uff0c\u600e\u4e48\u6b63\u786e\u79fb\u9664left pointer. \u601d\u8def\u5982\u4e0b:</p> <ul> <li>look at constrains\u53d1\u73b0<code>0 &lt;= nums[i] &lt;= 10^9</code></li> <li>\\(log_2(10^9) = 30\\) by <code>math.log(10**9,2)</code> \u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u7528\u4e00\u4e2a32 bits\u53ef\u4ee5cover\u6240\u6709\u7684\u6570\u5b57</li> <li>\u6211\u4eec\u53ea\u6709\u4e24\u4e2a\u64cd\u4f5c, prefix or\u64cd\u4f5c\u540e\u6216\u8005nullify\u64cd\u4f5c. \u8fd9\u4e24\u6b21\u64cd\u4f5c\u90fd\u8bb0\u5f55\u4e0b\u6765, increment or decrement the count of the bit involved in the operation</li> <li>\u5f53nullify\u64cd\u4f5c\uff0c\u4f1a\u5bfc\u81f4\u5176\u4e2d\u4e00\u4e2abit\u7684count\u53d8\u4e3a0, \u8fd9\u4e2a\u65f6\u5019\uff0c<code>nullify nums[left]</code>\u624d\u4f1a\u5bf9\u7ed3\u679c\u6709\u5f71\u54cd, \u8fd9\u65f6\u5019\u6211\u4eectoggle bits\u5373\u53ef.</li> </ul>","tags":["Sliding Window","Array","Bit Manipulation"]},{"location":"leetcode/3097-shortest-subarray-with-OR-at-least-K-II/#code-implementation","title":"Code Implementation","text":"<pre><code>class Solution:\n    def minimumSubarrayLength(self, nums: List[int], k: int) -&gt; int:\n        \"\"\"\n        f[i]: the number of times the ith bit is seen in the prefix\n        \"\"\"\n        bits = [0 for _ in range(32)]\n        n = len(nums)\n        prefix = 0\n        left = 0\n        res = n + 1\n        for right in range(n):\n            prefix |= nums[right]\n            for b in range(32):\n                if nums[right] &amp; (1 &lt;&lt; b):\n                    bits[b] += 1\n\n            while prefix &gt;= k and left &lt;= right:\n                res = min(res, right - left + 1)\n                # undo the operation\n                for b in range(32):\n                    if nums[left] &amp; (1 &lt;&lt; b) &gt; 0:\n                        bits[b] -= 1\n                        # \u5982\u679c\u6b63\u597d\u51cf\u6ca1\u4e86, nullify\u8fd9\u4e2aoperation\u624d\u4f1a\u5bf9\u7ed3\u679c\u6709\u5f71\u54cd\n                        if bits[b] == 0:\n                            # toggle b-th digits, \u8fd9\u5c31\u662fnullify operation\n                            prefix ^= (1 &lt;&lt; b)\n                left += 1\n\n        return res if res != n+1 else -1\n</code></pre>","tags":["Sliding Window","Array","Bit Manipulation"]},{"location":"leetcode/3097-shortest-subarray-with-OR-at-least-K-II/#reference","title":"Reference","text":"<ul> <li>Explanation here <ul> <li>for understand the logic</li> </ul> </li> <li>here<ul> <li>for code implementation</li> </ul> </li> <li>larry's video for fun</li> </ul>","tags":["Sliding Window","Array","Bit Manipulation"]},{"location":"leetcode/3099-harshad-number/","title":"3099 Harshad Number","text":"<pre><code>class Solution:\n    def sumOfTheDigitsOfHarshadNumber(self, x: int) -&gt; int:\n        \"\"\"\n        - calculate sum of its digits\n        - if harshad number\n            - return sum of digits\n        - else\n            - return -1\n        \"\"\"\n        res = -1\n        nums = str(x)\n        total_sum = 0\n        for num in nums:\n            total_sum += int(num)\n\n        if x%total_sum == 0:\n            return total_sum\n        else:\n            return -1\n</code></pre>"},{"location":"leetcode/310-minimum-height-tree/","title":"310 Minimum Height Trees","text":"","tags":["Depth-First Search","Breadth-First Search","Graph","Topological Sort"]},{"location":"leetcode/310-minimum-height-tree/#approach-1-bfs","title":"Approach 1 BFS","text":"<p>This solution is illustrated in the following diagram:</p> <p></p> <p>We start from all leaves nodes, and spirally converge to the center of the tree. At the end, the last two nodes are the root of the tree that give the minimum height.</p> <p>Note</p> <p>The stop condition is when the number of nodes is less than or equal to 2. You can think of it as finding the median of odd and even length of the array.</p>","tags":["Depth-First Search","Breadth-First Search","Graph","Topological Sort"]},{"location":"leetcode/310-minimum-height-tree/#code-implementation","title":"Code Implementation","text":"<pre><code>class Solution:\n    def findMinHeightTrees(self, n: int, edges: List[List[int]]) -&gt; List[int]:\n        \"\"\"\n        BFS Solution:\n        n = 4, edges = [[1,0],[1,2],[1,3]]\n        1. build adjacency list\n        {\n            0:[1],\n            1:[0,2,3],\n            2:[1],\n            3:[1],\n        }\n        2. count edge\n        {\n            0:1,\n            1:3,\n            2:1,\n            3:1,\n        }\n        3. maintain a queue that stores leaf node (where edge == 1)\n        4. iterating until the queue's length is less than 2,\n        conducting BFS, we poping the leaf node, reduce the associated\n        nodes (by adj list), then reduce the edge count by 1.\n        Note:\n        - One edge case is that: when n = 1, there is no edges. Since node starting from n-1,\n        so we return [0].\n        \"\"\"\n        if n == 1:\n            return [0]\n\n        adj_list = defaultdict(list)\n        for a,b in edges:\n            adj_list[a].append(b)\n            adj_list[b].append(a)\n\n        edge_count = {}\n        leaves = collections.deque()\n        for node,neighbors in adj_list.items():\n            edge_count[node] = len(neighbors)\n            if len(neighbors) == 1:\n                leaves.append(node)\n\n        while leaves:\n            # base case\n            if n &lt;= 2:\n                return list(leaves)\n            for i in range(len(leaves)):\n                node = leaves.popleft()\n                n -= 1\n                for neighbor in adj_list[node]:\n                    edge_count[neighbor] -= 1\n                    if edge_count[neighbor] == 1:\n                        leaves.append(neighbor)\n</code></pre>","tags":["Depth-First Search","Breadth-First Search","Graph","Topological Sort"]},{"location":"leetcode/3100-water-bottles-II/","title":"3100 Water Bottles II","text":"<p>Simulate the process of drinking water and exchanging bottles.</p> <pre><code>class Solution:\n    def maxBottlesDrunk(self, numBottles: int, numExchange: int) -&gt; int:\n        \"\"\"\n        objective: find the maximum # of bottles you can drink\n        observation:\n        - objective = original bottles + bottles we exchange.\n        - exchange rate goes high by 1 while we drinking it\n        - 1 unit of exchange at a time\n        algorithm:\n        - initiazation we drink all the water\n        - if we have enough empty bottles to exchange\n            - full_bottles++, empty_bottles -= exchange_rate, exchange_rate += 1\n            - until we don't have enough bottles\n        - keeps exchanging \n        - not enough empty bottles, start to drink them all.\n        - continue to exchange until \n        - drink them all\n        \"\"\"\n        res = 0\n        full_bottles = numBottles\n        empty_bottles = 0\n        exchange_rate = numExchange\n\n        while full_bottles != 0:\n            # drinking phase\n            res += full_bottles\n            empty_bottles += full_bottles        \n            full_bottles = 0\n\n            # exchange phase\n            while empty_bottles &gt;= exchange_rate:\n                full_bottles += 1\n                empty_bottles -= exchange_rate\n                exchange_rate += 1\n\n        return res\n</code></pre>"},{"location":"leetcode/3101-count-alternating-subarrays/","title":"3101 Count Alternating Subarrays","text":"<p>Adjacency pairs are alternating if they are different.</p>"},{"location":"leetcode/3101-count-alternating-subarrays/#approach-1-sliding-window","title":"Approach 1 Sliding Window","text":"<pre><code>class Solution:\n    def countAlternatingSubarrays(self, nums: List[int]) -&gt; int:\n        \"\"\"\n        observation:\n        - if a subarray of size n, has n-1 pairs. those pairs are alternating like [0,1,0,1]\n        - nums is either 0 or 1\n        - if a array like [0,1,0,1] then its children [1,0,1] and [0,1] amd [1] is also a subarray\n\n        objective:\n        - find the maximum alternating subarray ending at index 0\n        - find the maximum alternating subarray ending at index 1\n        - ...\n        - find the maximum alternating subarray ending at index n-1\n        dry run of [0,1,1,1]\n        - i = 0, [0]\n        - i = 1, [0,1]\n        - i = 2, [1]\n        - i = 3, [1]\n        dry run of [1,0,1,0]\n        - i = 0, [1]\n        - i = 1, [1,0]\n        - i = 2, [1,0,1]\n        - i = 3, [1,0,1,0]\n        \"\"\"\n        if len(nums) == 1:\n            return 1\n\n        left = 0\n        res = 1\n        prev = nums[left]\n\n        for right,curr in enumerate(nums[1:],1):\n            if curr == prev:\n                left = right\n                res += 1\n                continue\n            prev = curr\n            res += right - left + 1\n\n        return res\n</code></pre>"},{"location":"leetcode/3105-longest-strictly-increasing-or-strictly-decreasing-subarray/","title":"3105 Longest Strictly Increasing or Strictly Decreasing Subarray","text":""},{"location":"leetcode/3105-longest-strictly-increasing-or-strictly-decreasing-subarray/#approach-1","title":"Approach 1","text":"<p>need to maintain two int for recording current longest strictly increasing array and longest strictly decreasing array.</p> <pre><code>class Solution:\n    def longestMonotonicSubarray(self, nums: List[int]) -&gt; int:\n        best_asc = 1\n        best_desc = 1\n        res = 1\n\n        prev = nums[0]        \n        for curr in nums[1:]:\n            if curr == prev:\n                # reset\n                best_asc = 1\n                best_desc = 1\n            elif curr &gt; prev:\n                # increasing, we start to increase\n                best_asc += 1\n                best_desc = 1\n            else:\n                best_desc += 1\n                best_asc = 1\n\n            res = max(res,max(best_asc,best_desc))\n            prev = curr\n\n        return res        \n</code></pre>"},{"location":"leetcode/3106-lexicographically-smallest-string-after-operations-with-constraint/","title":"3106 Lexciographically Smallest String After Operations with Constraint","text":""},{"location":"leetcode/3106-lexicographically-smallest-string-after-operations-with-constraint/#approach-1","title":"Approach 1","text":"<p>we need to find the smallest string <code>t</code> possible w.r.t. original string <code>s</code>. By smaller, we always trying to place smaller alphabet in earlier of the string. For example,</p> <p><pre><code>s = 'zzzba'\n# option 1,replace first char\nt = 'azzba'\n# option 2, replace second char\nt = 'zazba'\n</code></pre> From <code>s</code> to option 1 and option 2, it costs the same distance but t in option_1 is smaller than t in option 2. So intuition is that</p> <ul> <li>it's more cost-effective spend distance on early position of the string</li> </ul> <p>Secondly, since the distance calculation is cyclic and we have 26 alphabet. The maximum distance between 2 character will be 13. U need to construct a helper function for that.</p> <p>Algorithm:</p> <ul> <li>create a <code>helper(a,b)</code> to calculate the distance between character <code>a</code> and <code>b</code></li> <li>maintain a <code>curr</code> for current distance so far. It needs to be smaller than <code>k</code></li> <li>traverse the string from start to end O(n)<ul> <li>iterate over 26 alphabets O(26) to find the first character (also the smallest) that will have the <code>curr total distances &lt;= k</code></li> <li>if <code>found</code>, we append the best candidate character</li> <li>if <code>not found</code>, we append the character from original string</li> </ul> </li> </ul>"},{"location":"leetcode/3106-lexicographically-smallest-string-after-operations-with-constraint/#code-implementation","title":"Code Implementation","text":"<pre><code>class Solution:\n    def getSmallestString(self, s: str, k: int) -&gt; str:\n        curr = 0 \n        alphabets = \"abcdefghijklmnopqrstuvwxyz\"\n        def distance(a,b):\n            # get the distance between character a and b\n            if abs(ord(a) - ord(b)) &lt;= 13:\n                return abs(ord(a) - ord(b))\n            else:\n                return 26 - abs(ord(a) - ord(b))\n\n\n        res = []\n        curr = 0\n        for i,c in enumerate(s):\n            found = False\n            for alphabet in alphabets:\n                if distance(c,alphabet) + curr &lt;= k:\n                    curr = distance(c,alphabet) + curr\n                    found = True\n                    res.append(alphabet)\n                    break\n\n            if not found:\n                res.append(c)\n\n        return \"\".join(res)\n</code></pre>"},{"location":"leetcode/3107-minimum-operations-to-make-median-of-array-equal-to-K/","title":"3107 Minimum Operations to Make Median of Array Equal to K","text":"<p>My intuition is that, it's a prefix sum problem since it has keyword <code>make median of array equal to K</code>, but it's not asking for anything related to <code>subarray</code>. So i didn't go that direction.</p> <p>In the dry run, to determine the number of operations, on the paper, I will sort it first, since it's easier to look at it that way. Then find the median, then calculate the number of operations. So it occurs to me that whether i could afford to sort it. Look at the constrains</p> <ul> <li>n &lt;= \\(10^5\\)</li> <li>1 &lt;= nums[i] &lt;= \\(10^9\\)</li> <li>k &lt;= \\(10^9\\)</li> </ul> <p>So, after sort, \\(O(nlogn)\\) would be like on the worst possible case that we can AC it. So i went down the sorting route.</p>"},{"location":"leetcode/3107-minimum-operations-to-make-median-of-array-equal-to-K/#approach-1-sorting","title":"Approach 1 Sorting","text":"<p>I draw a little diagram to help me understand the problem better. I drew the array and the vertical line of <code>k</code>, then i drew the median line. We can't modify the <code>k</code> so we have to modify the <code>nums</code> for us to move the vertical line to desired location. </p> <p></p> <p>Your goal is to move the <code>curr_i</code> to <code>target_i</code> by subtracting or adding the numbers in between <code>curr_i</code> and <code>target_i</code>, i.e. <code>nums[left:right]</code>. The number of operations is the sum of the absolute difference between the <code>nums</code> and <code>k</code> in the range of the median.</p> <p>Tip</p> <p>\u53ea\u8981<code>y = k</code>\u8fd9\u6839\u7ebf\uff0c\u5728sorted(nums)\u4e2d\uff0c\u81f3\u5c11\u6709\u4e00\u534a\u7684\u6570\u5728\u8fd9\u6839\u7ebf\u7684\u5de6\u8fb9\uff0c\u90a3\u4e48\u5c31\u53ef\u4ee5\u8ba9<code>y=k</code>\u6210\u4e3a\u6539\u9020\u540e\u7684median\u3002\u6240\u4ee5\u6211\u4eec\u5b9a\u4e49\u7684\u65f6\u5019\uff0c\u662f<code>[left,right)</code>\u7684\u5de6\u95ed\u53f3\u5f00\u533a\u95f4</p> <p>Steps:</p> <ul> <li>sort the <code>nums</code></li> <li>find the <code>curr_i</code> defined as the index where <code>k</code> should be inserted in sorted <code>nums</code></li> <li>find the <code>target_i</code> defined as the index that the median should be</li> </ul> <pre><code>class Solution:\n    def minOperationsToMakeMedianK(self, nums: List[int], k: int) -&gt; int:\n        nums.sort()\n        n = len(nums)\n\n        # find location of k in sorted(nums)\n        if k &lt; nums[0]:\n            curr_i = 0\n        elif k &gt;= nums[-1]:\n            curr_i = n\n        else:            \n            for i in range(1,n):\n                prev = nums[i-1]\n                curr = nums[i]\n                if k &lt; curr and k &gt;= prev:\n                    curr_i = i\n                    break\n\n        # find where the index should be\n        if curr_i &gt;= n//2 + 1:\n            target_i = n//2\n        else:\n            target_i = n//2 +1\n\n        res = [abs(num - k) for num in nums[min(curr_i,target_i):max(curr_i,target_i)]]\n        return sum(res)\n</code></pre>"},{"location":"leetcode/3110-score-of-a-string/","title":"3110 Score of a String","text":"<p>adjacency pair\u7684\u95ee\u9898\uff0c\u4e5f\u9700\u8981\u5229\u7528<code>ord()</code>\u83b7\u5f97character\u7684ordinal value (numerical) of unicode coding. \u7136\u540e\u5bf9\u4e8ealphabet, unicode == ASCII. \u6216\u8005\u8bf4ASCII\u662funicode\u7684\u5b50\u96c6\u3002</p>"},{"location":"leetcode/3110-score-of-a-string/#approach-1","title":"Approach 1","text":"<pre><code>class Solution:\n    def scoreOfString(self, s: str) -&gt; int:\n        n = len(s)\n        res = 0\n        for i in range(1,n):\n            prev,curr = ord(s[i-1]),ord(s[i])\n            res += abs(curr - prev)        \n        return res\n</code></pre>"},{"location":"leetcode/3111-minimum-rectangles-to-cover-points/","title":"3111 Minimum Rectangles to Cover Points","text":""},{"location":"leetcode/3111-minimum-rectangles-to-cover-points/#approach-1","title":"Approach 1","text":"<p>\u6211\u4eec\u9700\u8981\u627e\u5230\u591a\u5c11\u4e2amaximum width\u4e3aw\u7684, bottom\u5728x-axis\u4e0a\u7684rectangle do we need to cover all the points. </p> <p>\u4ee5\u4e0b\u51e0\u70b9\u9700\u8981\u6ce8\u610f:</p> <ul> <li>rectangle\u53ef\u4ee5\u65e0\u9650\u9ad8\uff0c\u6240\u4ee5y value of point\u6ca1\u6709\u610f\u4e49\u3002\u53eacare about x value</li> <li>duplicate x value\u6ca1\u6709\u610f\u4e49\uff0c\u56e0\u4e3a\u6211\u4eec\u53ef\u4ee5\u7528\u4e00\u4e2arectangle cover\u591a\u4e2a\u5728\u540c\u4e00\u6761\u7ad6\u7ebf\u7684\u70b9</li> </ul> <p>\u7b97\u6cd5\u903b\u8f91\u5982\u4e0b:</p> <ul> <li>\u6216\u8005x values, \u53bb\u91cd\uff0c\u7136\u540esort</li> <li>initialize left,right boundary of the first rectangle</li> <li>traverse the sorted x values, <ul> <li>\u5982\u679c\u5f53\u524d\u7684x value\u5728left,right\u4e4b\u95f4\uff0c\u90a3\u4e48\u6211\u4eec\u4e0d\u9700\u8981\u65b0\u7684rectangle\uff0c</li> <li>\u5982\u679c\u5f53\u524dx value\u8d85\u8fc7right boundary, \u6211\u4eec\u9700\u8981\u65b0\u7684rectangle\uff0c\u66f4\u65b0left,right boundary\u5e76\u4e14counter + 1</li> </ul> </li> </ul> <pre><code>class Solution:\n    def minRectanglesToCoverPoints(self, points: List[List[int]], w: int) -&gt; int:\n        \"\"\"\n        objective: \u591a\u5c11\u4e2amaximum width\u4e3aw\u7684, bottom\u5728x-axis\u4e0a\u7684rectangle do we need\n        to cover all the points\n        Observation:\n        - \u5b58\u5728width == 0\u7684rectangle\n        - height\u65e0\u6240\u8c13\n        - 10^5, so it hightly likely O(nlong) at most and most likely O(n). Gonna be a gready\n        - simulation\n        \"\"\"\n        seen = set()\n        arr = []\n        for point in points:\n            x,_ = point\n            if x in seen:\n                continue\n            arr.append(x)\n            seen.add(x)\n        # sort it\n        arr.sort()\n\n        left,right = arr[0],arr[0] + w\n        i = 0\n        res = 1\n        while i &lt; len(arr):\n            if arr[i] &gt;= left and arr[i] &lt;= right:\n                i += 1\n            elif arr[i] &gt; right:\n                # update left, right boundary\n                left,right = arr[i],arr[i] + w\n                res += 1\n\n        return res\n</code></pre>"},{"location":"leetcode/3113-Find-the-Number-of-Subarrays-Where-Boundary-Elements-Are-Maximum/","title":"3113 Find the Number of Subarrays Where Boundary Elements Are Maximum","text":"<p>\u6bd4\u8d5b\u4e2d\u4e00\u76f4\u5c1d\u8bd5\u7528monotonically increasing stack + hashmap for counting\u6765\u505a\uff0c\u4f46\u4e00\u76f4\u6ca1\u5199\u51fa\u6765\uff0c\u539f\u56e0\u5c31\u662f\u6ca1\u6709\u7406\u89e3\u597d\u9898\u76ee\uff0c\u5728\u786c\u51d1. \u6211\u4eec\u9996\u5148\u660e\u767d\u7684\u662f:</p> <ul> <li>\u6211\u4eec\u9700\u8981\u4e00\u4e2a\u8ba1\u6570\u5668\uff0c\u8bb0\u5f55\u6bcf\u4e00\u4e2a\u5143\u7d20\u9047\u5230\u7684\u6b21\u6570</li> <li>\u6211\u4eec\u9700\u8981\u4e00\u4e2amonotonic stack<ul> <li>\u5355\u8c03\u9012\u589estack\uff0c \u5219\u76cf\u9876\u4e3a\u6700\u5927\u503c</li> <li>\u5355\u8c03\u9012\u51cfstack\uff0c \u5219\u76cf\u5e95\u4e3a\u6700\u5927\u503c</li> </ul> </li> </ul> <p>\u6211\u4eec\u5728\u6bcf\u6b21\u9047\u89c1\u4e00\u4e2acurr max\u65f6\uff0c\u6211\u4eec\u9700\u8981\u6e05\u7a7a\u4e4b\u524d\u7684\u6240\u6709\u4fe1\u606f\uff0c\u5bf9\u4e8e<code>[6,26,6]</code>\u8fd9\u6837\u7684array\u6765\u8bf4\uff0c\u5728\u9047\u523026\u65f6\uff0c\u4e4b\u524d\u9047\u5230\u76846\u5df2\u7ecf\u6ca1\u6709\u610f\u4e49\u4e86.</p> <p></p> <p>\u4e0e\u4e4b\u5bf9\u5e94\u7684\uff0c<code>[6,1,6]</code>\u5219\u53ef\u4ee5\u6784\u6210\u4e00\u4e2a\u7b26\u5408\u6761\u4ef6\u7684array. \u56e0\u6b64\u6211\u4eec\u7684solution\u5fc5\u987b\u80fd\u5904\u7406\u8fd9\u4e24\u79cd\u60c5\u51b5\uff0c</p> <pre><code># peak\n[6,26,6]\n# valley\n[6,1,6]\n</code></pre> <p>\u5355\u8c03\u9012\u589e\u76cf\u4e0d\u4f1a\u5254\u9664\u6bd4\u6700\u5927\u503c\u5c0f\u7684\u5143\u7d20\uff0c\u8fd9\u662f\u6211\u4eec\u9009\u62e9\u7528\u5355\u8c03\u9012\u589e\u8fd8\u662f\u9012\u51cf\u7684\u5173\u952e\u3002\u540c\u65f6\u6211\u4eec\u53ef\u4ee5\u628ahashmap\u7684\u529f\u80fd\uff0c\u76f4\u63a5\u653e\u5728stack\u4e2d\uff0c\u4e3a\u4ec0\u4e48\u8fd9\u6837\u505a\u5462\uff1f\u56e0\u4e3a\u6211\u4eec\u53ea\u5173\u5fc3\u5f53\u524d\u9047\u5230\u7684\u8fd9\u4e2a\u6570<code>num</code>\u5728\u4ee5\u524d\u6709\u6ca1\u6709\u9047\u5230\u8fc7.</p> <ul> <li>\u5efa\u7acb\u4e00\u4e2astack, \u4e25\u683c\u9012\u51cf</li> <li>\u7ef4\u62a4\u4e00\u4e2ares, \u7528\u6765\u8bb0\u5f55\u7b26\u5408\u6761\u4ef6\u7684subarray\u7684\u4e2a\u6570</li> <li>\u5faa\u73afnums:<ul> <li>\u5e38\u89c4\u64cd\u4f5c\uff0c\u7ef4\u62a4\u4e25\u683c\u5355\u8c03\u9012\u51cfstack</li> <li>\u5982\u679c\u76cf\u9876\u5143\u7d20\u548c\u65b0\u8fdb\u5165\u5143\u7d20\u76f8\u7b49\uff0c\u5219\u66f4\u65b0\u76cf\u9876\u5143\u7d20\u7684\u8ba1\u6570\u5668\uff0c\u8df3\u8fc7\u540e\u7eed\u64cd\u4f5c</li> <li>\u5426\u5219\uff0c\u5c06\u65b0\u5143\u7d20\u52a0\u5165stack, \u5e76\u66f4\u65b0res</li> </ul> </li> </ul>","tags":["Monotonic Stack"]},{"location":"leetcode/3113-Find-the-Number-of-Subarrays-Where-Boundary-Elements-Are-Maximum/#approach-1-monotonic-stack","title":"Approach 1 Monotonic Stack","text":"<pre><code>class Solution:\n    def numberOfSubarrays(self, nums: List[int]) -&gt; int:\n        \"\"\"\n        observation:\n        - count subarray\u7cfb\u5217\u9898\u76ee\n        - condition: arr[0] arr[-1] are the min and max of the subarray\n        - nums[i] &gt;= 1, \u6240\u4ee5\u53ef\u4ee5\u7528sliding window,\u4e5f\u6709\u53ef\u80fd\u662fmonotonic queue        \n        - monotically increasing queue (\u4e0d\u9700\u8981strictly)\n        intuition:\n        - monotonically decreasing stack\n        \"\"\"\n        stack = []\n        res = 0\n\n        for num in nums:\n            while stack and stack[-1][0] &lt; num:\n                stack.pop()\n            if stack and num == stack[-1][0]:\n                stack[-1][1] += 1\n                res += stack[-1][1]                \n                continue\n            stack.append([num,1])\n            res += stack[-1][1]\n\n\n        return res\n</code></pre>","tags":["Monotonic Stack"]},{"location":"leetcode/3136-valid-word/","title":"3136 Valid Word","text":"<p>\u6ca1\u5565\u7279\u522b\u7684\uff0c\u5c31\u662f\u68c0\u67e5\u4e00\u4e2a\u5b57\u7b26\u4e32\u662f\u5426\u6ee1\u8db3\u4ee5\u4e0b\u6761\u4ef6\uff1a</p> <pre><code>class Solution:\n    def isValid(self, word: str) -&gt; bool:\n        # It contains a minimum of 3 characters.\n        # It consists of the digits 0-9, and the uppercase and lowercase English letters. (Not necessary to have all of them.)\n        # It includes at least one vowel.\n        # It includes at least one consonant.\n        \"\"\"\n        0-9, 48-57\n        A-Z, 65-90\n        a-z, 97-122        \n        \"\"\"\n        if len(word) &lt; 3:\n            return False\n\n        vowels = set('aeiouAEIOU')\n        numbers = set('0123456789')\n        vowel_flag = False\n        consonant_flag = False\n\n        for char in word:\n            curr = ord(char)\n            # not a number, lower case, upper case, and special chars\n            if curr &lt; 48 or (curr &gt; 57 and curr &lt; 65) or (curr &gt; 90 and curr &lt; 97) or curr &gt; 122:\n                return False\n\n            if char in vowels:\n                vowel_flag = True\n                continue\n\n            if char not in vowels and char not in numbers:\n                consonant_flag = True\n\n        if vowel_flag and consonant_flag:\n            return True\n        else:\n            return False\n</code></pre>"},{"location":"leetcode/3137-minimum-number-of-operations-to-make-word-k-periodic/","title":"3137 Minimum Number of Operations to Make Word K-Periodic","text":""},{"location":"leetcode/3137-minimum-number-of-operations-to-make-word-k-periodic/#approach-1","title":"Approach 1","text":"<p>\u6709\u4e00\u4e2a\u6570\u7ec4\uff0c\u53ef\u4ee5\u5206\u4e3a<code>n//k</code>\u4e2asegment, \u6bcf\u4e2asegment\u7684\u957f\u5ea6\u4e3ak\uff0c\u6211\u4eec\u53ef\u4ee5\u7528\u4e00\u4e2ahashtable\u6765\u8bb0\u5f55\u6bcf\u4e2asegment\u7684\u51fa\u73b0\u6b21\u6570\uff0c\u7136\u540e\u627e\u5230\u51fa\u73b0\u6b21\u6570\u6700\u591a\u7684segment. \u8fd9\u4e2a\u5c31\u662f\u4e0d\u52a8\u7684segment,\u5176\u5b83\u7684segment\u90fd\u9700\u8981\u88ab\u66ff\u6362\u3002</p> <p>For example, <code>word = leetcodeleet</code> and <code>k = 4</code>, \u53ef\u4ee5\u5206\u4e3a<code>leet</code>, <code>code</code>, <code>leet</code>\u4e09\u4e2asegment, \u7edf\u8ba1\u4e00\u4e0b, <pre><code>{\n    \"leet\": 2,\n    \"code\": 1\n}\n</code></pre></p> <p>\u7531\u6b64\u6211\u4eec\u53ef\u4ee5\u770b\u5230\uff0c<code>leet</code>\u51fa\u73b0\u4e86\u4e24\u6b21\uff0c\u6700\u5212\u7b97\u7684operation\u65f6\u53ea\u9700\u8981\u66ff\u6362\u4e00\u6b21\u5c31\u53ef\u4ee5\u4e86\u3002</p> <p>!!! note '\u590d\u6742\u5ea6\u5206\u6790'</p> <pre><code>- time complexity: $O(\\frac{n}{k})$\n- space complexity: $O(\\frac{n}{k})$\n</code></pre>"},{"location":"leetcode/3137-minimum-number-of-operations-to-make-word-k-periodic/#code-implementation","title":"Code Implementation","text":"<pre><code>from collections import defaultdict\nclass Solution:\n    def minimumOperationsToMakeKPeriodic(self, word: str, k: int) -&gt; int:\n        \"\"\"\n         1.  4.  8\n        [leetcodelee t ]\n         01234567891011\n         we replace\n         - [0..3] with [4..7]\n         - [4..7] with [8..11]\n\n          0 2 4 6 8\n         [leetcoleet]\n          0123456789\n\n        example 1\u5206\u62103\u7b49\u4efd\n        example 2\u5206\u62105\u7b49\u4efd\n        \u53ea\u6709\u6700\u540e\u4e00\u4e2asegment\u4e0d\u80fd\u88ab\u66ff\u6362\uff0c\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u5229\u7528count\u6b21\u6570\u6765\u51b3\u5b9a\n        \"\"\"\n        n = len(word)\n        # target = word[n-k:n]\n        hashtable = defaultdict(int)\n\n        global_max = 0\n        for i in range(n//k):\n            start = i*k\n            end = (i+1)*k\n            hashtable[word[start:end]] += 1\n            global_max = max(global_max,hashtable[word[start:end]])\n\n        return n//k - global_max\n</code></pre>"},{"location":"leetcode/3138-minimum-length-of-anagram-concatenation/","title":"3138 Minimum Length of Anagram Concatenation","text":""},{"location":"leetcode/3138-minimum-length-of-anagram-concatenation/#approach-1","title":"Approach 1","text":"<p>\u627e\u89c4\u5f8b\uff0c\u6bd4\u8d5b\u7684\u65f6\u5019\u6211\u53d1\u73b0,</p> <ul> <li>\u5148\u7ef4\u62a4\u4e00\u4e2afrequency map for each char <code>count = Counter(s)</code>, \u518d\u6c42\u6700\u5c0ffrequency\u7684char, <code>min_freq</code></li> <li>edge case:<ul> <li>\u5982\u679c\u53ea\u6709\u4e00\u4e2achar, \u90a3\u4e48\u76f4\u63a5\u8fd4\u56de1</li> </ul> </li> <li>general cases:<ul> <li>\u5982\u679c\u6700\u5c0f\u7684\u9891\u7387\u4e3a1, \u90a3\u4e48\u5fc5\u7136\u53ea\u80fd\u6784\u6210\u4e00\u4e2aanagram, \u8fd4\u56delen(s)</li> <li>\u5982\u679c\u6700\u5c0f\u7684\u9891\u7387\u5927\u4e8e1, \u5206\u7c7b\u8ba8\u8bba:<ul> <li>\u6240\u6709\u7684\u6570\u90fd\u80fd\u88ab\u6700\u5c0f\u7684\u9891\u7387\u6574\u9664, \u90a3\u4e48\u76f4\u63a5\u8fd4\u56de\u6700\u5c0f\u7684\u9891\u7387</li> <li>\u4e0d\u80fd\u88ab\u6574\u9664, \u90a3\u4e48\u8fd4\u56delen(s)</li> </ul> </li> </ul> </li> </ul> <p>\u4ee3\u7801\u5b9e\u73b0\u5982\u4e0b,</p> <pre><code>from collections import Counter\nclass Solution:\n    def minAnagramLength(self, s: str) -&gt; int:\n        \"\"\"\n        observation:\n        - O(n) solution or at worst O(nlogn)\n        - \"xxe\"\n        - \"\" --&gt; \"bboorruull\"\n        - \"\" --&gt; \"ooooiinnss\", \u8fd8\u5b58\u5728\u67d0\u4e9b\u5076\u6570\u7684\u60c5\u51b5;\n        \"\"\"\n        count = Counter(s)       \n        # \u53ea\u6709\u4e00\u4e2achar\n        if len(count) == 1:\n            return list(count.values())[0]\n\n        # \u83b7\u5f97\u6700\u5c0f\u503c\n        min_freq = min(count.values())\n        distinct_freq = sorted(set(count.values()))\n\n        # \u5982\u679cmin_greq\u4e3a1\uff0c\u90a3\u4e48\u4e0d\u7ba1\u5176\u4ed6\u503c\u662f\u591a\u5c11,\u90fd\u5fc5\u7136\u662fn\n        if min_freq == 1:\n            return len(s)\n\n        for freq in distinct_freq:\n            if freq % min_freq != 0:\n                return len(s)\n\n        return min_freq\n</code></pre> <p>\u4f46\u6709\u51e0\u4e2ahidden test cases\u6ca1\u6cd5\u8dd1\u8fc7\uff0c\u6240\u4ee5\u8fd9\u4e2a\u903b\u8f91\u8fd8\u662f\u4e0d\u591f\u5168\u9762\u3002\u6ca1cover\u5230\u7684test cases\u7684<code>distinct_freq</code>\u4e3a</p> <p><pre><code>distinct_freq = {385, 322, 420, 357, 294, 329, 427, 364, 301, 399, 336, 371, 308, 406, 343, 441, 413}\nmin_freq = 294\n</code></pre> \u539f\u56e0\u5728\u4e8e\u6211\u6bd4\u8d5b\u4e2d\u60f3\u5230\u7684\u662f\"\u6240\u6709\u7684\u6570\u80fd\u88ab\u6700\u5c0f\u7684frequency\u6574\u9664\", \u4f46\u8fd9\u4e2a\u4e0d\u591f\u5168\u9762\u3002\u6700\u5168\u9762\u7684\u662f\uff0c<code>\u627e\u5230\u4e00\u4e2a\u6700\u5927\u6570\u5b57x, such that\u6240\u6709\u7684char\u7684\u9891\u7387\u90fd\u80fd\u88abx\u6574\u9664</code>. \u8fd9\u4e2ax\u5c31\u80fd\u6ee1\u8db3\u6211\u4eec\u6700\u77edanagram\u957f\u5ea6.</p>"},{"location":"leetcode/3138-minimum-length-of-anagram-concatenation/#code-implementation","title":"Code Implementation","text":"<pre><code>from collections import Counter\nclass Solution:\n    def minAnagramLength(self, s: str) -&gt; int:\n        \"\"\"\n        observation:\n        - O(n) solution or at worst O(nlogn)\n        - \"xxe\"\n        - \"\" --&gt; \"bboorruull\"\n        - \"\" --&gt; \"ooooiinnss\", \u8fd8\u5b58\u5728\u67d0\u4e9b\u5076\u6570\u7684\u60c5\u51b5;\n\n        \u6700\u540e\u7684solution\u7684freq, \u5fc5\u7136\u662f:\n        - \u5982\u679cfreq map\u53ea\u6709\u4e00\u4e2achar, \u90a3\u5c31\u662f1\n        - \u53ea\u8981\u5b58\u57281, \u90a3\u4e48\u5fc5\u7136\u662flen(s)\n        - \u6700\u540e\u7684char, freq map, \u5fc5\u7136\u662f, \n        https://oi-wiki.org/math/number-theory/gcd/\n        \"\"\"        \n        count = Counter(s)       \n        com_div = count[s[0]]\n\n        for count in count.values():\n            com_div = math.gcd(com_div,count)\n        return len(s)//com_div\n</code></pre>"},{"location":"leetcode/314-binary-tree-vertical-order-traversal/","title":"314 Binary Tree Vertical Order Traversal","text":"<p>2D matrix of a tree! \u8fd9\u9898\u7684\u89e3\u6cd5\u90fd\u662fbfs-based, </p> <ul> <li>approach 1 BFS + Sorting, O(nlogn) time complexity, O(n) space complexity. \u7ef4\u62a4\u4e00\u4e2alist of tuple (node.val, col), sort by col, \u4e4b\u540e\u518dappend\u5230res\u91cc\u9762.</li> <li>approach 2 BFS no sorting, \u662f\u6700\u4f18\u89e3. O(n) time complexity, O(n) space complexity without sorting. \u5f88\u5de7\u5999\u4e14\u5b9e\u7528\u7684trick.</li> </ul>","tags":["Tree","Hash Table","Breadth-first Search","Binary Tree"]},{"location":"leetcode/314-binary-tree-vertical-order-traversal/#approach-1-bfs-sorting","title":"Approach 1 BFS + Sorting","text":"<p>Intuition:</p> <ul> <li>create a score tracking system, if move left -= 1, if move right += 1</li> </ul> <p>\u5728BFS traverse\u7684\u65f6\u5019\uff0c\u5c31\u53ef\u4ee5\u60f3\u5230\u5728maintain\u4e00\u4e2atuple of (node, score), \u4e4b\u540esort by score\u5373\u53ef. \u7136\u540e\u518d\u6839\u636escore\u6765append\u5230res\u91cc\u9762.</p> <p>Dry run would be </p> <pre><code>    3\n   / \\\n  9  20\n    /  \\\n   15   7\n\n[(3,0),(9,-1),(20,1),(15,0),(7,2)]   \n\nthen we sort it\n[(9,-1),(3,0),(15,0),(20,1),(7,2)]\n\nwe organize it to\n[[9],[3,15],[20],[7]]\n</code></pre> <p>Code Implementation</p> <p>\u7b2c\u4e00\u6b21\u770b\u5230\u65f6\u5019\uff0c\u60f3\u5230list of tuples.</p> <pre><code>from collections import deque\nclass Solution:\n    def verticalOrder(self, root: Optional[TreeNode]) -&gt; List[List[int]]:\n        if not root:\n            return root\n\n        queue = deque([(root,0)])\n        level = []\n\n        while queue:\n            for _ in range(len(queue)):\n                curr,curr_pos = queue.pop()\n                level.append((curr,curr_pos))\n                if curr.left:\n                    queue.appendleft((curr.left,curr_pos-1))\n                if curr.right:\n                    queue.appendleft((curr.right,curr_pos+1))\n\n        level.sort(key=lambda x:x[1])\n        node,prev = level[0]\n        res = [[node.val]]\n\n        for i in range(1,len(level)):\n            node,curr = level[i]\n            if curr == prev:\n                res[-1].append(node.val)\n            else:\n                res.append([node.val])            \n            prev = curr\n        return res\n</code></pre> <p>list of tuple\u8fd9\u6837\u5199\u8d77\u6765\u592a\u9ebb\u70e6\u4e86\uff0csort\u4e4b\u540e\u8fd8\u9700\u8981explicitly\u7684\u518d\u6b21\u904d\u5386\uff0c\u5f88clumsy, \u6709\u4e00\u4e2a\u4f18\u5316readibility\u7684\u65b9\u6cd5:</p> <p>use hash table <code>defaultdict(list)</code> to store the column as key and list of nodes as value. Since we BFS, each <code>hashtable[key]</code> will remain sorted.</p> <p>\u5c0f\u4f18\u5316</p> <pre><code>from collections import deque,defaultdict\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def verticalOrder(self, root: Optional[TreeNode]) -&gt; List[List[int]]:\n        \"\"\"\n        intuition:\n            - create a score tracking system, if move left -= 1, if move right += 1\n        dry run:\n            [(3,0),(9,-1),(20,1),(15,0),(7,2)]        \n        \"\"\"\n        if not root:\n            return root\n\n        queue = deque([(root,0)])\n        hashtable = defaultdict(list)\n\n        while queue:\n            for _ in range(len(queue)):\n                curr,curr_col = queue.pop()\n                hashtable[curr_col].append(curr.val)\n                if curr.left:\n                    queue.appendleft((curr.left,curr_col - 1))\n                if curr.right:\n                    queue.appendleft((curr.right,curr_col + 1))\n\n        return [hashtable[x] for x in sorted(hashtable.keys())]\n</code></pre>","tags":["Tree","Hash Table","Breadth-first Search","Binary Tree"]},{"location":"leetcode/314-binary-tree-vertical-order-traversal/#approach-2-bfs-no-sorting","title":"Approach 2 BFS no Sorting","text":"<p>\u8ddf\u7740approach 1 minor \u4f18\u5316\u7684\u601d\u8def\uff0c\u600e\u4e48\u53ef\u4ee5\u8fdb\u4e00\u6b65\u4f18\u5316\u5462? \u6211\u4eec\u53d1\u73b0\u6211\u4eec\u6700\u540e\u83b7\u5f97\u7684column, \u80af\u5b9a\u662fcontiguous integer, \u4e5f\u5c31\u662f\u8bf4\u6211\u4eec\u53ef\u4ee5\u7528\u4e00\u4e2amin_col\u548cmax_col\u6765track\u6211\u4eec\u7684column\u7684\u8303\u56f4, \u4e4b\u540e\u4e0d\u9700\u8981sort, \u76f4\u63a5iterate min_col to max_col\u5373\u53ef.</p> <p>Tip</p> <p>\u7ef4\u62a4\u4e24\u4e2a\u53d8\u91cf\uff0cmin_col\u548cmax_col\u5c31\u80fd\u4ea4\u6362\u4e00\u4e2asort\u7684\u65f6\u95f4\u590d\u6742\u5ea6. \u8d85\u503c!</p> <pre><code>from collections import deque,defaultdict\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def verticalOrder(self, root: Optional[TreeNode]) -&gt; List[List[int]]:\n        \"\"\"\n        intuition:\n            - create a score tracking system, if move left -= 1, if move right += 1\n        dry run:\n            [(3,0),(9,-1),(20,1),(15,0),(7,2)]        \n        \"\"\"\n        if not root:\n            return root\n\n        queue = deque([(root,0)])\n        hashtable = defaultdict(list)\n        min_col = max_col = 0\n        while queue:\n            for _ in range(len(queue)):\n                curr,curr_col = queue.pop()\n                hashtable[curr_col].append(curr.val)\n                min_col = min(min_col,curr_col)\n                max_col = max(max_col,curr_col)                \n                if curr.left:\n                    queue.appendleft((curr.left,curr_col - 1))\n                if curr.right:\n                    queue.appendleft((curr.right,curr_col + 1))\n\n        return [hashtable[x] for x in range(min_col,max_col+1)]        \n</code></pre>","tags":["Tree","Hash Table","Breadth-first Search","Binary Tree"]},{"location":"leetcode/325-maximum-size-subarray-sum-equals-k/","title":"325 Maximum Size Subarray Sum Equals k","text":"<p>basic prefix sum questions</p>","tags":["Hash Table","Array","Prefix Sum"]},{"location":"leetcode/325-maximum-size-subarray-sum-equals-k/#approach-1-prefix-sum","title":"Approach 1 Prefix Sum","text":"<p>two-pass solution,</p> <ul> <li>initialize a hashmap to store the prefix sum and its index</li> <li>first pass to pre-process the prefix sum, only maintain the smallest index of the same prefix sum since we want the maximum size</li> <li>second pass to see if there is any <code>curr_sum - k = target</code> in the hashmap, if so, update the max length if necessary</li> </ul> <pre><code>from collections import defaultdict\nclass Solution:\n    def maxSubArrayLen(self, nums: List[int], k: int) -&gt; int:\n        \"\"\"\n        every subarray can be represented by the difference\n        between two subarray that starts from zero.\n        C = A - B  \n        x x x x [x x x]\n                i.   j\n        [x x x] x x x x\n         i   j\n        1. pre-processing to calculate the prefix sum\n            [1,-1,5,-2,3] --&gt; [1,0,5,3,6]\n            {\n                1:0,\n                0:1\n                5:2,\n                3:3,\n                6:4\n            }\n            if the key already in it, we do nothing since we want \n            the min length for B to get max length\n        2. we check every curr_num such that\n            curr_sum - prefix_sum = k\n            curr_sum - k = prefix_sum = target\n            check the target\n        \"\"\"        \n        prefix_sum_lookup = defaultdict(int)        \n        prefix_sum_lookup[0] = -1\n\n        rolling_sum = 0\n        for i,num in enumerate(nums):\n            rolling_sum += num\n            if rolling_sum not in prefix_sum_lookup:\n                prefix_sum_lookup[rolling_sum] = i\n\n        curr_sum = 0\n        res = 0\n        for right,num in enumerate(nums):\n            curr_sum += num\n            target = curr_sum - k\n            if target in prefix_sum_lookup:\n                left = prefix_sum_lookup[target]\n                res = max(res,right-left)\n\n        return res\n</code></pre> <p>Then you realize that 1st pass and 2nd pass look very similar to each other. And more importantly, the previous prefix_sum the 2nd pass is looking up is the smaller prefix_sum that we have seen so far. Therefore, just like in 1 two-sum that we can do 1 pass, same as here</p> <pre><code>from collections import defaultdict\nclass Solution:\n    def maxSubArrayLen(self, nums: List[int], k: int) -&gt; int:\n        prefix_sum_lookup = defaultdict(int)        \n        prefix_sum_lookup[0] = -1\n\n        rolling_sum = 0\n        res = 0\n        for right,num in enumerate(nums):\n            # pre-processing\n            rolling_sum += num\n            target = rolling_sum - k\n            if target in prefix_sum_lookup:\n                left = prefix_sum_lookup[target]\n                res = max(res,right-left)\n\n            if rolling_sum not in prefix_sum_lookup:\n                prefix_sum_lookup[rolling_sum] = right\n\n\n\n        return res\n</code></pre>","tags":["Hash Table","Array","Prefix Sum"]},{"location":"leetcode/328-odd-even-linked-list/","title":"Intuition","text":"<p>\u8fd9\u9898\u8f6c\u5316\u4e00\u4e0b\u9898\u610f: - \u5c06\u6240\u6709\u7684odd nodes\u7ec4\u6210\u4e00\u4e2a\u94fe\u8868A - \u5c06\u6240\u6709\u7684even nodes\u7ec4\u6210\u4e00\u4e2a\u94fe\u8868B - \u8fde\u63a5A\u7684\u5c3e\u5df4\u548cB\u7684\u5934</p> <p>Technique: - two pointers, odd and even; even pointer is ahead of odd pointer, so we use that in the <code>while</code> - corner cases, it has zero or it has one node;</p>"},{"location":"leetcode/33-search-in-rotated-sorted-array/","title":"33 Search in Rotated Sorted Array","text":"<p>\u8fd9\u9898\u53ef\u4ee5\u5206\u4e3a\u4e24\u6b65\uff0c </p> <ul> <li>\u627e\u5230\u6700\u5c0f\u503c\u7684\u4f4d\u7f6e\uff0c\u4e5f\u5c31\u662f\u5728\u54eapivot</li> <li>wrap around</li> </ul> <p>\u5173\u4e8e\u627e\u5230\u6700\u5c0f\u503c\u7684\u4f4d\u7f6e\uff0c\u8be6\u60c5\u89c1153 Find Minimum in Rotated Sorted Array</p> <p>\u540c\u65f6rotated sorted array\u6709\u4e00\u4e2asorted\u6027\u8d28\uff0c\u5f53\u4e14\u4ec5\u5f53</p> <ul> <li>num in <code>nums</code> are distinct</li> <li><code>nums</code> is sorted</li> </ul> <p></p> <p>From the diagram above, we have notice that as k goes from 1 to n-1, more and more elements from the start of the array will be moved to the end of the array. After realizing the pattern, we realize we could use </p> <p>$$ \\begin{equation} \\left(x_{original} + k\\right)\\bmod n = x_{rotated} \\end{equation} $$ where \\(x_{original}\\) is the index of the original array, \\(k\\) is the number of elements moved to the end of the array (or pivot index), and \\(n\\) is the length of the array, \\(x_{rotated}\\) is the index of the rotated array.</p> <pre><code>class Solution:\n    def search(self, nums: List[int], target: int) -&gt; int:\n        # for example [0,1,2,4,5,6,7]\n        # if k == 0, nothing happens\n        # ...\n        # if k == n-2 == 5,  --&gt; [1,2,4,5,6,7,0]\n        # if k == n-1 == 6, it goes back\n        # 1 &lt;= k &lt; n\n\n        # 1. find the starting location of the array with binary search\n        # 2. treat it like binar search but you need to wrap the index woth %\n\n        # step 1: find min\n        n = len(nums)\n        left,right = 0,n-1\n\n        # nums[left] &gt; nums[mid] &lt; nums[right]\n        while left &lt; right:\n            mid = (left + right)//2\n            if nums[mid] &lt; nums[right]:\n                right = mid\n            else:\n                left = mid + 1\n\n        pivot = left\n\n        left,right = 0,n-1\n        while left &lt;= right:\n            mid = (left + right)//2\n            if nums[(mid + pivot) % n] == target:\n                return (mid + pivot) % n\n            elif nums[(mid + pivot) % n] &gt; target:\n                right = mid - 1\n            else:\n                left = mid + 1                \n        return -1\n</code></pre>","tags":["Array","Binary Search"]},{"location":"leetcode/34-find-first-and-last-position-of-element-in-sorted-array/","title":"Intuition","text":"<p>we could easily find the target inside the array if it exists but the questions are, what's next? </p> <p>My originally thought is to binary search the problem and then radiates out from the target but that would lead to \\(O(n)\\) worst case.</p> <p>We start from defining the [start,end]: - nums[start] the 1st value in the array <code>nums</code> that satisifies the condition and the index nums[start-1] != target</p> <p>Then, We could solve the problem into subproblems: - find the target to see if it exists or not     - find the left most target      - find the right most target</p>"},{"location":"leetcode/34-find-first-and-last-position-of-element-in-sorted-array/#approach","title":"Approach","text":"<ul> <li>create a function to find the target, then binary search it's left search space until it find last index that satisify the condition. </li> <li>create a function to find the target, then binary search it's right search space until it find last index that satisify the condition. </li> <li>job done!</li> </ul>"},{"location":"leetcode/34-find-first-and-last-position-of-element-in-sorted-array/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: \\(O(n)\\)</li> </ul> <ul> <li>Space complexity: \\(O(1)\\)</li> </ul>"},{"location":"leetcode/34-find-first-and-last-position-of-element-in-sorted-array/#summary","title":"Summary","text":"<p>\u8fd9\u4e00\u9898\u4e3b\u8981\u5b66\u5230\u7684: - \u6e05\u6670\u7684\u7528\u8bed\u8a00\u8868\u8fbe\u51fa\u4f60\u8981\u7684condition, \u8fd9\u6837\u4f1a\u7ed9\u4f60\u6709\u542f\u53d1 - \u5206\u6cbb\u7684\u601d\u60f3\uff0c\u6765\u5c06\u6bcd\u95ee\u9898\u6539\u6210\u4fe9\u5b50\u95ee\u9898 - \u5b66\u5230\u4e86nested binary search. </p>"},{"location":"leetcode/34-find-first-and-last-position-of-element-in-sorted-array/#code","title":"Code","text":"<pre><code>class Solution:\n    def searchRange(self, nums: List[int], target: int) -&gt; List[int]:\n        # O(logn) runtime + sorted array,  dead giveaway for binary search\n\n        if len(nums) == 0: return [-1,-1]\n        if target &lt; nums[0] or target &gt; nums[-1]: return [-1,-1]\n\n        def search_left_most_target(arr,target_value):\n            left = 0\n            right = len(arr) - 1\n            left_most_index = -1\n\n            while left &lt;= right:\n                mid = left + (right - left)//2\n                if nums[mid] &gt; target:\n                    # search space to the left\n                    right = mid - 1\n                elif nums[mid] &lt; target:\n                    # search space to the right\n                    left = mid + 1\n                else:\n                    # target found, search left\n                    left_most_index = mid\n                    right = mid - 1\n\n            return left_most_index\n\n        def search_right_most_target(arr,target_value):\n            left = 0\n            right = len(arr) - 1\n            right_most_index = -1\n\n            while left &lt;= right:\n                mid = left + (right - left)//2\n                if nums[mid] &gt; target:\n                    # search space to the left\n                    right = mid - 1\n                elif nums[mid] &lt; target:\n                    # search space to the right\n                    left = mid + 1\n                else:\n                    # target found, search right\n                    right_most_index = mid\n                    left = mid + 1\n\n            return right_most_index\n\n\n        start = search_left_most_target(nums,target)\n        end = search_right_most_target(nums,target)\n\n        return [start,end] \n</code></pre>"},{"location":"leetcode/340-longest-substring-with-at-most-k-distinct-characters/","title":"340 Longest Substring With At Most K Distinct Characters","text":"","tags":["Sliding Window","Hash Table","String"]},{"location":"leetcode/340-longest-substring-with-at-most-k-distinct-characters/#approach-1-sliding-window","title":"Approach 1 Sliding Window","text":"<pre><code>from collections import defaultdict\nclass Solution:\n    def lengthOfLongestSubstringKDistinct(self, s: str, k: int) -&gt; int:\n        \"\"\"\n        k distinct chars + x overlapping chars\n        2 pointers, same direction, \n        right: moves only distinct &lt; k (use a counter for freq)\n        left: moves when we have len(counter) &gt; k\n        maintain a variable for global maximum\n        \"\"\"\n        if k == 0:\n            return 0\n\n        left  = 0\n        counter = defaultdict(int)\n        global_max = 0\n        for right in range(len(s)):\n            counter[s[right]] += 1\n            while len(counter) &gt; k and left &lt; right:\n                counter[s[left]] -= 1\n                # clean it if it's zero\n                if counter[s[left]] == 0:\n                    del counter[s[left]]\n\n                left += 1\n            # if reach here, it must be &lt;= k\n            global_max = max(global_max,right - left + 1)\n        return global_max        \n</code></pre>","tags":["Sliding Window","Hash Table","String"]},{"location":"leetcode/346-moving-average-from-data-stream/","title":"346 moving average from data stream","text":"<pre><code>from collections import deque\nclass MovingAverage:\n    def __init__(self, size: int):\n        self.size = size\n        self.window = deque([])\n        self.curr_sum = 0\n\n    def next(self, val: int) -&gt; float:\n        if len(self.window) &lt; self.size:\n            self.window.append(val)\n            self.curr_sum += val            \n        else:\n            # window is full\n            prefix = self.window.popleft()\n            self.window.append(val)\n            self.curr_sum = self.curr_sum - prefix + val\n\n        return self.curr_sum/len(self.window)\n# Your MovingAverage object will be instantiated and called as such:\n# obj = MovingAverage(size)\n# param_1 = obj.next(val)\n</code></pre>"},{"location":"leetcode/347-top-k-frequent-elements/","title":"Approach 1 Naive Solution","text":"<p>\u81ea\u5df1\u60f3\u51fa\u6765\u7684naive\u89e3\uff0cO(nlogn) in time, O(n) in space.</p> <pre><code>class Solution:\n    def topKFrequent(self, nums: List[int], k: int) -&gt; List[int]:\n        # hashmap to record: \n        #      val:occurence\n        # O(n*logn) in time, O(n) in space\n        hashtable = collections.defaultdict(int)\n        for num in nums:\n            hashtable[num] += 1\n\n        sorted_hashtable = sorted(hashtable,key=lambda x:hashtable[x],reverse = True)\n\n        return sorted_hashtable[:k]\n</code></pre>"},{"location":"leetcode/347-top-k-frequent-elements/#approach-2-using-bucket-sort","title":"Approach 2 Using bucket sort","text":"<p>Neetcode\u7684\u89e3\u6cd5 O(n) in time, O(n) in space. \u6bd4\u8f83\u5de7\u5999\u662f\uff0c\u7528\u4e86bucket sort\u7684\u601d\u60f3\uff0c\u628a\u9891\u7387\u4f5c\u4e3aindex\uff0c\u7136\u540e\u628a\u9891\u7387\u76f8\u540c\u7684\u5143\u7d20\u653e\u5728\u4e00\u4e2alist\u91cc\u9762\u3002\u8fd9\u6837\u5c31\u53ef\u4ee5\u76f4\u63a5\u4ece\u9ad8\u9891\u7387\u5f00\u59cb\u53d6\u5143\u7d20\u4e86. </p> <p>Tip</p> <p>\u4e3a\u4ec0\u4e48bucket sort\u7b97\u6cd5\u4f1a\u5feb\u5462? \u672c\u8d28\u4e0a\u662f\u628a\u4e00\u4e2aunbounded problem\u8f6c\u5316\u4e3abounded problem. \u4f60\u7684\u8f93\u5165array <code>nums = [1,2,...1000000]</code> \u91cc\u7684value\u7684\u8303\u56f4\u975e\u5e38\u5e7f\uff0c\u4f46\u662f\u4f60\u7684\u9891\u7387\u7684\u8303\u56f4\u5219\u6c38\u8fdc\u548c<code>len(nums)</code>\u4e00\u6837\u3002\u4e5f\u5c31\u662f\u4f60\u6709\u4e2asize 6\u7684array, \u9891\u7387\u6b21\u6570\u53ea\u53ef\u80fd\u662f1-6. \u6240\u4ee5\u4f60\u53ef\u4ee5\u628a\u8fd9\u4e2aunbounded problem\u8f6c\u5316\u4e3abounded problem.</p> <p>\u8fd9\u4e2a\u601d\u8def\u548c2-sum\u5b9e\u9645\u4e0a\u662f\u4e00\u4e2a\u975e\u5e38comparable, \u5bf9\u6bd4\u5982\u4e0b,</p> <p></p> <p>\u7b97\u6cd5\u590d\u6742\u5ea6\u6709\u70b9\u641e\u8111\u5b50\uff0c\u5047\u8bbe\u4f60\u7684input array is size n. \u90a3\u4e48\u6bcf\u79cd\u5143\u7d20\u6700\u591a\u51fa\u73b0n\u6b21\uff0c\u6240\u4ee5\u6700\u591a\u6709n\u79cd\u4e0d\u540c\u7684\u9891\u7387\u3002\u6240\u4ee5\u6700\u591a\u6709n\u4e2abucket\u3002\u6240\u4ee5\u6700\u591a\u6709n\u4e2alist. \u4f46\u8fd9n\u4e2alist\u91cc\uff0c\u4e00\u5171\u6709\u7684elements\u6570\u91cf\u4e5f\u4e3an\u4e2a\uff0c\u6bcf\u4e00\u4e2a\u90fdvisit\u4e00\u904d\u3002\u6240\u4ee5\u603b\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u4e3aO(n).</p> <p>Note</p> <p>bucket sort\u7684\u7cbe\u9ad3\u5728\u4e8ebucket\u7684\u5b9a\u4e49, \u8fd9\u4e2a\u5b9a\u4e49\u5b8c\u5168\u4f9d\u8d56\u4e8e\u4f60\u9700\u8981\u6c42\u7684\u95ee\u9898. \u6bd4\u5982\u8fd9\u4e2a\u95ee\u9898\u662f\u6c42\u9891\u7387\u6700\u9ad8\u7684k\u4e2a\u5143\u7d20\uff0c\u90a3\u4e48bucket\u7684\u5b9a\u4e49\u5c31\u662f\u9891\u7387\u3002\u5982\u679c\u662f\u6c42\u6700\u5927\u503c\uff0c\u90a3\u4e48bucket\u7684\u5b9a\u4e49\u5c31\u662fvalue\u7684\u8303\u56f4,\u5177\u4f53\u5982\u4e0b\u56fe.</p> <p></p> <p>\u4e0b\u9762\u7684\u4f8b\u5b50\u7528\u4e86list of list\u7684\u65b9\u5f0f\uff0c\u4f46\u662f\u5176\u5b9e\u7528defaultdict\u4e5f\u662f\u53ef\u4ee5\u7684\u3002</p>"},{"location":"leetcode/347-top-k-frequent-elements/#with-list-of-list","title":"With list of list","text":"<pre><code>class Solution:\n    def topKFrequent(self, nums: List[int], k: int) -&gt; List[int]:\n        # bucket sort, O(n) in time, O(n) in space\n\n        # cost O(n) time \n        hashtable = collections.defaultdict(int)\n        for num in nums:\n            hashtable[num] += 1\n        # cost O(n) space\n        freq = [[] for _ in range(len(nums)+1)]\n\n        # cost O(n) time\n        for num,count in hashtable.items():\n            freq[count].append(num)\n\n        # cost O(n), since we gonna have x vals, where x == len(nums)\n        res = []\n        for count in range(len(freq)-1, 0, -1):\n            # on average, we have O(1) time to get the value\n            # \u5e73\u5747\u4e0b\u6765\u6bcf\u4e2afrequency\u4e00\u4e2a\u5143\u7d20\n            for val in freq[count]:\n                res.append(val)                \n                if len(res) == k:\n                    return res\n</code></pre>"},{"location":"leetcode/347-top-k-frequent-elements/#with-defaultdict","title":"with defaultdict","text":"<p>\u4e0b\u9762\u662f\u7528defaultdict\u7684\u4f8b\u5b50 <pre><code>from collections import defaultdict\nclass Solution:\n    def topKFrequent(self, nums: List[int], k: int) -&gt; List[int]:\n        hashmap = defaultdict(int)\n        for num in nums:\n            hashmap[num] += 1\n\n        bucket = defaultdict(list)\n        for val,freq in hashmap.items():\n            bucket[freq].append(val)\n\n        # traverse from len(nums) to 1\n        res = []\n        for freq in range(len(nums), 0, -1):\n            for n in bucket[freq]:\n                res.append(n)\n                if len(res) == k:\n                    return res            \n</code></pre></p>"},{"location":"leetcode/349-intersection-of-two-arrays/","title":"349 Intersection of Two Arrays","text":"<p>\u8fd9\u9898\u76f4\u63a5\u770bfollow-up.</p>","tags":["Array","Hash Table","Two Pointers","Binary Search","Sorting"]},{"location":"leetcode/349-intersection-of-two-arrays/#approach-1-trivial-hashset","title":"Approach 1 Trivial Hashset","text":"<pre><code>class Solution:\n    def intersection(self, nums1: List[int], nums2: List[int]) -&gt; List[int]:\n        set_1 = set(nums1)\n        set_2 = set(nums2)\n\n        res = set.intersection(set_1,set_2)\n        return res\n</code></pre>","tags":["Array","Hash Table","Two Pointers","Binary Search","Sorting"]},{"location":"leetcode/349-intersection-of-two-arrays/#facebook-follow-up","title":"Facebook Follow-up","text":"<p>\u5982\u679c\u7ed9\u4f60\u7684\u4fe9array\u662fsorted\u7684\uff0c\u6709\u6ca1\u6709\u4ec0\u4e48O(n) time O(1) space\u7684\u65b9\u6cd5\uff1f(\u4e0d\u8ba1\u7b97output array\u7684\u7a7a\u95f4). \u7528\u53cc\u6307\u9488\u6cd5, \u6d41\u7a0b\u56fe\u5982\u4e0b, </p> <p></p> <pre><code>class Solution:\n    def intersection(self, nums1: List[int], nums2: List[int]) -&gt; List[int]:\n        nums1.sort()\n        nums2.sort()\n\n        res = []\n\n        p1,p2 = 0,0\n\n        while p1 &lt; len(nums1) and p2 &lt; len(nums2):\n            curr1,curr2 = nums1[p1],nums2[p2]\n            # we find the intersecton, now advances both pointer until nums[x] is different from both nums1 and nums2\n            if curr1 == curr2:\n                res.append(curr1)\n                while p1 &lt; len(nums1) and curr1 == nums1[p1]:\n                    p1 += 1\n                while p2 &lt; len(nums2) and curr2 == nums2[p2]:\n                    p2 += 1\n                continue\n\n            if curr1 &gt; curr2:\n                # \u7531\u4e8e\u662fsorted, advance p2\u76f4\u5230\u4e0d\u540c\n                while p2 &lt; len(nums2) and nums2[p2] == curr2:\n                    p2 += 1\n            else:\n                # advance p1\n                while p1 &lt; len(nums1) and nums1[p1] == curr1:\n                    p1 += 1\n        return res\n</code></pre>","tags":["Array","Hash Table","Two Pointers","Binary Search","Sorting"]},{"location":"leetcode/35-search-insert-position/","title":"35 Search Insert Position","text":"","tags":["Binary Search","Array"]},{"location":"leetcode/35-search-insert-position/#approach-1-left-right","title":"Approach 1 left &lt; right","text":"<p>\u5f53<code>while left &lt; right:</code>, \u6211\u4eec\u6709\u4e24\u79cd\u53ef\u80fd:</p> <ul> <li>CASE 1: \u627e\u5230\u4e86target, \u8fd4\u56demid</li> <li>CASE 2: \u8df3\u51fa<code>while left &lt; right:</code>\u7684\u5faa\u73af\uff0c\u8df3\u51fa\u7684\u65f6\u5019<code>left &gt;= right</code>, \u6216\u8005\u518dspecific\u4e00\u70b9, \u8981\u4e48<code>left = right</code>, \u8981\u4e48<code>left = right + 1</code>. \u4f46\u8981\u6ce8\u610f\uff0c\u53ef\u80fd\u4f1a\u6709target\u867d\u7136\u5728nums\u4e2d\uff0c\u4f46\u662f\u6ca1\u4ececase 1\u4e2dreturn.<ul> <li>Case 2.1: <code>left = right</code>, <ul> <li>\u6700\u540e\u4e00\u6b65\u66f4\u65b0<code>left = mid + 1</code></li> <li>\u6700\u540e\u4e00\u6b65\u66f4\u65b0<code>right = mid + 1</code></li> </ul> </li> <li>Case 2.2: <code>left = right + 1</code><ul> <li>\u6700\u540e\u4e00\u6b65\u66f4\u65b0<code>left = mid + 1</code></li> <li>\u6700\u540e\u4e00\u6b65\u66f4\u65b0<code>right = mid + 1</code></li> </ul> </li> </ul> </li> </ul> <p>Note</p> <p>\u4e3a\u4ec0\u4e48\u662fcase 2\u53ea\u53ef\u80fd\u662f<code>left = right</code> or <code>left = right + 1</code>? \u56e0\u4e3a\u6bcf\u6b21left or right pointer\u7684update, \u5230\u6700\u540e\u53eaincrement or decrement by one, \u4e5f\u5c31\u4e0d\u4f1a\u6709offset by 2\u7684\u60c5\u51b5.</p> <p>\u6211\u4eec\u6765\u770b\u4e00\u4e0b\u4e0b\u9762\u6d41\u7a0b\u56fe, \u8fd9\u4e2a\u51fd\u6570\u4e00\u5171\u4e5f\u5c31return\u4e09\u79cd\u60c5\u51b5, </p> <ul> <li>\u5728\u5faa\u73af\u65f6\uff0c\u627e\u5230\u4e86target, \u76f4\u63a5return mid</li> <li>\u8df3\u51fa\u5faa\u73af\u540e\uff0c\u627e\u5230\u4e86target</li> <li>\u8df3\u51fa\u5faa\u73af\u540e\uff0c\u6ca1\u627e\u5230target</li> </ul> <p></p>","tags":["Binary Search","Array"]},{"location":"leetcode/35-search-insert-position/#numsleft","title":"\u4ee5<code>nums[left]</code>\u4e3a\u5224\u5b9a\u6761\u4ef6","text":"<p>\u5bf9\u4e8ecase 2, \u6211\u4eec\u867d\u7136\u77e5\u9053left == right, \u4f46\u6211\u4eec\u5e76\u4e0d\u77e5\u9053<code>nums[left]\u548ctarget\u4e4b\u95f4\u7684\u5173\u7cfb</code>, \u9700\u8981\u505a\u4e2a\u5224\u5b9a. </p> <ul> <li>\u5f53<code>nums[left] &gt;= target</code>: </li> <li>\u5f53<code>nums[left] &lt; target</code>: \u90a3\u4e48<code>left + 1</code>\u5c31\u662f\u6211\u4eec\u63d2\u5165\u7684\u4f4d\u7f6e.</li> </ul> <pre><code>class Solution:\n    def searchInsert(self, nums: List[int], target: int) -&gt; int:\n        left,right = 0,len(nums)-1\n\n        while left &lt; right:\n            mid = (left+right)//2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] &gt; target:\n                right = mid - 1\n            else:\n                left = mid + 1\n\n        if nums[left] &gt;= target:\n            return left\n        else:\n            return left + 1\n</code></pre>","tags":["Binary Search","Array"]},{"location":"leetcode/35-search-insert-position/#numsright","title":"\u4ee5<code>nums[right]</code>\u4e3a\u5224\u5b9a\u6761\u4ef6","text":"<pre><code>class Solution:\n    def searchInsert(self, nums: List[int], target: int) -&gt; int:\n        left,right = 0,len(nums)-1\n\n        while left &lt; right:\n            mid = (left+right)//2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] &gt; target:\n                right = mid - 1\n            else:\n                left = mid + 1\n\n        if nums[right] == target:\n            return right\n        elif nums[right] &lt; target:\n            return right + 1\n        else:\n            if right - 1 &lt; 0:\n                return 0\n            else:\n                return right\n</code></pre> <p>Warning</p> <p>\u4e3a\u4ec0\u4e48\u4f9d\u636e<code>nums[left]</code>\u4f5c\u4e3a\u5224\u5b9a\u6bd4<code>nums[right]</code>\u8981\u7b80\u5355\u5462\uff1f\u662f\u56e0\u4e3aarray\u63d2\u5165\u7684\u8fb9\u754c, \u4e00\u4e2a\u957f\u5ea6\u4e3an\u7684\u6570\u7ec4\uff0c\u4f60\u53ef\u4ee5\u63d2\u5165\u7684\u4f4d\u7f6e\u662f0\u5230n. \u5f53\u4f60\u7528<code>nums[right]</code>\u4f5c\u4e3a\u5224\u5b9a\u6761\u4ef6, \u7531\u4e8eright &lt;= left, \u4e5f\u5c31\u662f\u8bf4\u4f60\u6709\u4e00\u5b9a\u51e0\u7387\u9700\u8981\u63d2\u5728right pointer\u7684\u5de6\u8fb9. \u5982\u679cright pointer \u6307\u5411\u7684\u662f0, \u90a3\u4e48\u4f60\u5c31\u9700\u8981\u7279\u6b8a\u5904\u7406\u4e00\u4e0b. \u4f46\u662f\u5982\u679c\u4f60\u7528<code>nums[left]</code>\u4f5c\u4e3a\u5224\u5b9a\u6761\u4ef6, \u7531\u4e8e<code>left &gt; right</code>, \u4e5f\u5c31\u662f\u8bf4\uff0c\u4f60\u5f80left\u5de6\u8fb9\u63d2\u80af\u5b9a\u6ca1\u95ee\u9898\uff0c\u5f80left\u53f3\u8fb9\u63d2\u4e5f\u6ca1\u95ee\u9898, \u6700\u574f\u7684case\u662f\u5bf9\u4e00\u4e2alength\u4e3an\u7684\u6570\u7ec4\uff0c\u4f60\u63d2\u5728n\u7684\u4f4d\u7f6e\uff0c\u4e5f\u4e0d\u4f1a\u6709out-of-bound\u7684\u95ee\u9898.</p>","tags":["Binary Search","Array"]},{"location":"leetcode/35-search-insert-position/#approach-2-left-right","title":"Approach 2 left &lt;= right","text":"<p>\u5f53left&lt;= right\u4f60\u8df3\u51fa\u6765\u7684\u65f6\u5019\uff0cleft = right + 1\u6052\u6210\u7acb\u8fd9\u4e00\u79cd\u53ef\u80fd\uff0c\u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u5f97\u5230\u4e00\u4e0b\u7ed3\u8bba,</p> <pre><code>nums[left] will be first value &gt; target, and nums[right] will be the last value &lt; target\n</code></pre> <p>\u65e2\u7136\uff0cleft != right, \u90a3\u4f60\u63d2\u5165\u7684\u65f6\u5019\u5c31\u6052\u6210\u7acb\u63d2\u5165\u5728left\u7684\u4f4d\u7f6e.</p> <pre><code>class Solution:\n    def searchInsert(self, nums: List[int], target: int) -&gt; int:\n        left,right = 0,len(nums)-1\n\n        while left &lt;= right:\n            mid = (left+right)//2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] &gt; target:\n                right = mid - 1\n            else:\n                left = mid + 1\n\n        # left = right + 1 and nums[left] will be first value &gt; target\n        # and nums[right] will be the last value &lt; target\n        return left\n</code></pre>","tags":["Binary Search","Array"]},{"location":"leetcode/36-valid-sudoku/","title":"36 Valid Sudoku","text":"<p>\u7b49\u4ef7\u8f6c\u6362\u4e09\u6761\u89c4\u5219: - every row must contain the digits 1-9 without repetition. - every column must contain the digits 1-9 without repetition. - every of the 9 3x3 sub-boxes of the grid must contain the digits 1-9 without repetition.</p> <p>\u7136\u540e\u6839\u636e\u4e09\u6761\u89c4\u5219\uff0c\u505a\u4e09\u6b21matrix traversal\uff0c\u5206\u522b\u68c0\u67e5\u662f\u5426valid, \u867d\u7136\u53ef\u4ee5\u4f18\u5316\u5230one pass, \u4f46\u662fasymptotic time complexity\u6ca1\u6709\u53d8\u5316. </p> <p>\\(O(n^2)\\) in time complexity, \\(O(n)\\) space complexity. \u5f53\u7136\uff0c\u4f60\u4e5f\u53ef\u4ee5argue\u8bf4\u662f\\(O(1)\\) in both time and space complexity, \u56e0\u4e3a\u6211\u4eec\u53ea\u662f\u7528\u4e86\u4e00\u4e2ahashmap\u6765\u5b58\u50a8\uff0c\u4e14\u5faa\u73af\u6570\u56fa\u5b9a\u4e3a9 * 9 = 81.</p> <pre><code>class Solution:\n    def isValidSudoku(self, board: List[List[str]]) -&gt; bool:\n        # 9 vertical scan, 9 horitonal scan, 9 3x3 grid scan\n        def is_horizontal_valid(matrix):\n            for row in matrix:                \n                hashmap = set()\n                for item in row:                        \n                    if item != \".\" and item in hashmap:\n                        return False                        \n                    hashmap.add(item)\n\n            return True\n\n\n        def is_vertical_valid(matrix):\n            \"\"\"\n            first pass\n            (0,0),(1,0),(2,0)...\n            2nd pass\n            (0,1),(1,1),(2,1)...\n            \"\"\"\n            for i in range(len(matrix)):\n                hashmap = set()\n                for j in range(len(matrix)):\n                    if matrix[j][i] != \".\" and matrix[j][i] in hashmap:\n                        return False\n                    hashmap.add(matrix[j][i])            \n            return True\n\n        def is_sub_box_valid(matrix):\n            for x in range(0,9,3):\n                for y in range(0,9,3):\n                    hashmap = set()\n                    for i in range(3):\n                        for j in range(3):\n                            if matrix[x+i][y+j] != \".\" and matrix[x+i][y+j] in hashmap:\n                                return False\n                            hashmap.add(matrix[x+i][y+j])\n            return True\n\n        res = False\n        if is_sub_box_valid(board) and is_vertical_valid(board) and is_horizontal_valid(board):\n            res = True\n\n        return res\n</code></pre>","tags":["array","matrix","hash table"]},{"location":"leetcode/368-largest-divisible-subset/","title":"368 Largest Divisible Subset","text":"<p>\u538b\u7f29DP\u7684\u9898\u578b, \u4e14state transition function\u4f9d\u8d56\u4e8e\u591a\u4e2a\u524d\u9a71\u8282\u70b9\uff0c\u4e14prior nodes\u9700\u8981\u901a\u8fc7\u9898\u76ee\u6761\u4ef6\uff0c\u4e5f\u5c31\u662f<code>nums[i] % nums[j] == 0</code> or <code>nums[j] % nums[i] ==0</code> \u6765\u8fdb\u884c\u7b5b\u9009.</p>","tags":["Dynamic Programming","Array","Math","Sorting"]},{"location":"leetcode/368-largest-divisible-subset/#approach-1-dp-bottom-up-on2-time-on-space","title":"Approach 1 DP bottom-up, \\(O(N^2)\\) time, \\(O(N)\\) space","text":"<p>\u6700\u91cd\u8981\u7684\u601d\u8def\u662f\uff0c\u8f6c\u6362, <code>nums[i] % nums[j] == 0</code> or <code>nums[j] % nums[i] ==0</code> \u53ef\u4ee5\u7b49\u4ef7\u4e8e<code>nums[i] % nums[j] == 0 and i &gt; j</code>, \u8fd9\u4e00\u9898\u76ee\u6b63\u597d\u6ee1\u8db3\u8fd9\u4e2a\u6761\u4ef6, \u56e0\u4e3a\u6bcf\u4e2a\u6570\u5b57\u90fd\u662funique\u7684 <pre><code>1 &lt;= nums.length &lt;= 1000\n1 &lt;= nums[i] &lt;= 2 * 109\nAll the integers in nums are unique.\n</code></pre></p> <p>Tip</p> <p>\u5982\u679cnums\u4e2d\u7684\u6570\u5b57\u4e0d\u662funique\u7684\uff0c\u53ef\u4ee5\u6784\u5efa\u4e2ahashmap\u8bb0\u5f55\u6bcf\u4e2a\u6570\u5b57\u51fa\u73b0\u7684occurrence, \u6700\u540emax(dp)\u52a0\u4e0a\u5c31\u53ef\u4ee5\u4e86.</p>","tags":["Dynamic Programming","Array","Math","Sorting"]},{"location":"leetcode/368-largest-divisible-subset/#dp-definition","title":"dp definition","text":"<pre><code>dp[i]: \n      the length of the largest divisible subset ending at i elment \n      in the ascendingly sorted input array.\nprev[i]:\n        the previous index of the largest divisible subset ending at i element.  \u8fd9\u4e2aarray\u7684value\u6307\u5411\u7684\u662f\u4e0a\u4e00\u4e2aindex that is divisible by nums[i]\n</code></pre> <p>\u6ce8\u610f\uff0c\u8fd9\u5e76\u4e0d\u662f\u6211\u4eec\u8981\u6c42\u7684\uff0c\u6211\u4eec\u8981\u6c42\u7684\u662f\u4efb\u4e00\u7b26\u5408\u6761\u4ef6\u7684largest divisible subset, \u4f46\u662f\u8fd9\u4e2adp\u6570\u7ec4\u53ef\u4ee5\u5e2e\u52a9\u6211\u4eec\u627e\u5230\u6700\u5927\u7684index, \u7136\u540e\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7prev\u6570\u7ec4\u56de\u6eaf\u627e\u5230\u6700\u5927\u7684subset.</p> <p></p>","tags":["Dynamic Programming","Array","Math","Sorting"]},{"location":"leetcode/368-largest-divisible-subset/#initial-condition","title":"initial condition","text":"<pre><code>dp[i] = 1 for all\n</code></pre>","tags":["Dynamic Programming","Array","Math","Sorting"]},{"location":"leetcode/368-largest-divisible-subset/#state-transition-function","title":"state transition function","text":"<p><pre><code>if nums[i] % nums[j] == 0:\n    dp[i] = max(dp[i], 1 + dp[j])\n    if dp[j]+1 == dp[i]:\n        prev[i] = j\n</code></pre> \u53d1\u73b0\u4e86divisible elements\u5c31\u505a\u4e24\u4ef6\u4e8b:</p> <ul> <li>\u66f4\u65b0dp[i]</li> <li><code>prev[i]</code>\u7684\u66f4\u65b0\u8bb0\u5f55\u4e86<code>nums[i]</code>\u7684previous index, \u8fd9\u4e2a\u6570\u7684previous index\u4e3a<code>nums[j]</code></li> </ul> <p>\u4ee3\u7801\u5982\u4e0b:</p> <pre><code>class Solution:\n    def largestDivisibleSubset(self, nums: List[int]) -&gt; List[int]:\n        # largest subset, every num % 1 == 0        \n        # dp[i]: \n        #       the length of the largest divisible subset ending at i elment \n        #       in the ascendingly sorted input array.\n        # initial conditon:\n        #       dp[i] = 1 for all, dp[0] = 0\n        # state transition function\n        #       dp[i] = max(dp[i], 1 + dp[j])\n        #       prev[i] = j, \u8fd9\u4e2a\u6570\u7684previous index\u4e3a\n\n        nums.sort()\n        dp = [1 for _ in range(len(nums))]\n        prev = [-1 for _ in range(len(nums))]\n\n        for i in range(len(nums)):\n            for j in range(0,i):\n                if nums[i] % nums[j] == 0:\n                    dp[i] = max(dp[i], 1 + dp[j])\n                    # successfully updated\n                    if dp[j]+1 == dp[i]:\n                        prev[i] = j\n\n        # find the max index    \n        max_length = -1\n        max_index = -1\n        for i,length in enumerate(dp):\n            if length &gt; max_length:\n                max_length = length\n                max_index = i        \n        # now we have the max index, \n        # largest divisible subset will be ending at element nums[i] where nums is sorted\n        # we need to brack track until we find the res \n        res = []\n\n        while max_index != -1:\n            res.append(nums[max_index])\n            max_index = prev[max_index]\n\n        return res\n</code></pre>","tags":["Dynamic Programming","Array","Math","Sorting"]},{"location":"leetcode/368-largest-divisible-subset/#reference","title":"Reference","text":"<ul> <li>huifeng guan, \u6b8b\u9177\u5237\u9898\u7fa4\u7fa4\u4e3b</li> </ul>","tags":["Dynamic Programming","Array","Math","Sorting"]},{"location":"leetcode/370-range-addition/","title":"370 Range Addition","text":"<p>\u5229\u7528\u4e86segment tree\u91cc\u7684lazy propagation\u7684\u601d\u60f3. \u4f60\u4e0d\u9700\u8981\u7acb\u523b\u66f4\u65b0\u6240\u6709\u7684\u503c\uff0c\u800c\u662f\u5728\u9700\u8981\u7684\u65f6\u5019\u518d\u66f4\u65b0.</p>","tags":["Prefix Sum","Array"]},{"location":"leetcode/370-range-addition/#approach-1-brute-force","title":"Approach 1: Brute Force","text":"<pre><code>class Solution:\n    def getModifiedArray(self, length: int, updates: List[List[int]]) -&gt; List[int]:\n        # brute force:\n        # increment everything by inc\n        res = [0] * length\n        for start,end,inc in updates:\n            for i in range(start,end+1):\n                res[i] += inc\n\n        return res\n</code></pre>","tags":["Prefix Sum","Array"]},{"location":"leetcode/370-range-addition/#approach-2-prefix-sum","title":"Approach 2: Prefix Sum","text":"<p>Prefix Sum with auxillary DS as array, + traverse backwards to get the final result. For example,</p> <p><pre><code>Input: length = 5, updates = [[1,3,2],[2,4,3],[0,2,-2]]\nOutput: [-2,0,3,5,3]\n</code></pre> The intuition is that, we can maintain a <code>prefix</code> array to indicate at which index, we need to add the <code>inc</code> value. Then we can traverse backwards to get the final result.</p> <p></p> <p>We don't need n <code>prefix</code> array to maintain. JUST apply superposition to combines states since we only interested in the final result and not caring about the intermediate states.</p> <p></p>","tags":["Prefix Sum","Array"]},{"location":"leetcode/370-range-addition/#code-implementation","title":"Code Implementation","text":"<pre><code>class Solution:\n    def getModifiedArray(self, length: int, updates: List[List[int]]) -&gt; List[int]:        \n        \"\"\"\n        Auxillary DS\n        x [x x x] x\n           1   3\n        \"\"\"\n        helper = [0]*length\n\n        for i,j,inc in updates:\n            helper[j] += inc\n            if i == 0:\n                continue\n            else:\n                helper[i-1] -= inc\n        res = [0] * length\n        curr = 0\n        for i in range(length-1,-1,-1):\n            curr += helper[i]\n            res[i] = curr\n        return res\n</code></pre>","tags":["Prefix Sum","Array"]},{"location":"leetcode/370-range-addition/#approach-3-postfix-sum","title":"Approach 3: Postfix Sum","text":"<p>\u5f53\u4f60\u505apost-fix sum\u5c31\u9700\u8981traverse forward.</p> <pre><code>class Solution:\n    def getModifiedArray(self, length: int, updates: List[List[int]]) -&gt; List[int]:        \n        \"\"\"\n        suffix sum\n\n        Auxillary DS (1,3,2)\n        x [x x x] x\n        0  1 2 3  4\n        0  2.    -2\n        \"\"\"\n        suffix_sum = [0]*length\n\n        for i,j,inc in updates:\n            suffix_sum[i] += inc\n            if j == length-1:\n                continue\n            else:\n                suffix_sum[j+1] -= inc\n\n        res = [0] * length\n        curr = 0\n\n        for i in range(length):\n            curr += suffix_sum[i]\n            res[i] = curr\n\n        return res\n</code></pre>","tags":["Prefix Sum","Array"]},{"location":"leetcode/374-guess-number-higher-or-lower/","title":"\u9519\u8bef\u7b97\u6cd5","text":"<p>\u7531\u4e8e\u60ef\u6027\u601d\u7ef4, binary search\u9700\u8981sorted array, \u6240\u4ee5\u6211construct\u4e86\u4e00\u4e2aarray, \u8fd9\u6837\u7684\u8bdd\u590d\u6742\u5ea6\u4e3a - time complexity: \\(O(n) + O(logn) \\approx O(n)\\) \u9700\u8981declare array\u90a3\u4e00\u6b65\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a\\(O(n)\\) \u53cd\u800c\u6bd4binary search\u7b97\u6cd5\u672c\u8eab\u8981\u6162\u4e86, \u8fd9\u91cc\u5b8c\u5168\u53ef\u4ee5\u5229\u7528index = value\u8fd9\u4e00\u7279\u6027;</p> <p>\u9519\u8bef\u7b97\u6cd5\u7684\u4ee3\u7801\u5982\u4e0b, </p> <pre><code># The guess API is already defined for you.\n# @param num, your guess\n# @return -1 if num is higher than the picked number\n#          1 if num is lower than the picked number\n#          otherwise return 0\n# def guess(num: int) -&gt; int:\n\nclass Solution:\n    def guessNumber(self, n: int) -&gt; int:\n\n        # create a list of potential Solution\n        nums = []\n        for i in range(1,n+1):\n            nums.append(i)\n\n        # now i need to find soluton within the sorted array\n        left = 0\n        right = len(nums) - 1\n\n        while left &lt;= right:\n            # get mid index of the search space\n            mid = (left+right)//2\n            # \n            if guess(nums[mid]) == 0:\n                return nums[mid]\n            elif guess(nums[mid]) == -1:\n                right = mid - 1\n            else:\n                left = mid +1\n</code></pre>"},{"location":"leetcode/374-guess-number-higher-or-lower/#intuition","title":"Intuition","text":"<p>\u7531\u4e8e\u6211\u4eec\u9700\u8981\u627e\u7684\u7a7a\u95f4\u4e3a<code>[1,n]</code>, \u6211\u4eec\u4e0d\u9700\u8981\u6784\u5efa\u4e00\u4e2asorted array\u56e0\u4e3a: - index is already equal to its value - <code>[1,n]</code> is already sorted</p>"},{"location":"leetcode/374-guess-number-higher-or-lower/#approach","title":"Approach","text":"<p>typical binary search\u7b97\u6cd5</p>"},{"location":"leetcode/374-guess-number-higher-or-lower/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: \\(O(n)\\)</li> </ul> <ul> <li>Space complexity: \\(O(1)\\)</li> </ul>"},{"location":"leetcode/374-guess-number-higher-or-lower/#code","title":"Code","text":"<pre><code># The guess API is already defined for you.\n# @param num, your guess\n# @return -1 if num is higher than the picked number\n#          1 if num is lower than the picked number\n#          otherwise return 0\n# def guess(num: int) -&gt; int:\n\nclass Solution:\n    def guessNumber(self, n: int) -&gt; int:\n\n        left = 0\n        right = n\n\n        while left &lt;= right:\n            # get mid index of the search space\n            mid = (left+right)//2\n            # \n            if guess(mid) == 0:\n                return mid\n            elif guess(mid) == -1:\n                right = mid - 1\n            else:\n                left = mid +1\n</code></pre>"},{"location":"leetcode/387-first-unique-character-in-a-string/","title":"Approach 1 Hashmap Linear Space","text":"<p>Self-explanatory. O(n) in time, O(1) in space since it has at most 26 characters.</p> <p><pre><code>from collections import defaultdict\nclass Solution:\n    def firstUniqChar(self, s: str) -&gt; int:        \n        res = -1\n        hashmap = defaultdict(int)\n        for c in s:\n            hashmap[c] += 1\n        for i in range(len(s)):\n            if hashmap[s[i]] == 1:\n                res = i\n                break\n        return res            \n</code></pre> \u7c7b\u4f3c\u7684\uff0c\u4f60\u53ef\u4ee5\u7528<code>dict().get()</code> to be more precise.</p> <pre><code>class Solution:\n    def firstUniqChar(self, s: str) -&gt; int:\n        # 1. hashmap to traverse it once\n        # 2. traverse twice to see if it's zero\n        res = -1\n        hashmap = dict()\n\n        for c in s:\n            hashmap[c] = hashmap.get(c,0) + 1\n\n        for i in range(len(s)):\n            if hashmap[s[i]] == 1:\n                res = i\n                break\n\n        return res\n</code></pre>"},{"location":"leetcode/395-longest-substring-with-at-least-k-repeating-characters/","title":"395 Longest Substring with At Least K Repeating Characters","text":"<p>\u8fd9\u9898\u7b97\u662fsliding window\u4e2d\u7684\u625b\u628a\u5b50\u4e86.</p>","tags":["Hash Table","Sliding Window","Divide and Conquer","String"]},{"location":"leetcode/395-longest-substring-with-at-least-k-repeating-characters/#approach-1-brute-force","title":"Approach 1 Brute Force","text":"","tags":["Hash Table","Sliding Window","Divide and Conquer","String"]},{"location":"leetcode/395-longest-substring-with-at-least-k-repeating-characters/#approach-2-sliding-window","title":"Approach 2 Sliding Window","text":"","tags":["Hash Table","Sliding Window","Divide and Conquer","String"]},{"location":"leetcode/395-longest-substring-with-at-least-k-repeating-characters/#approach-3-divide-and-conquer","title":"Approach 3 Divide and Conquer","text":"","tags":["Hash Table","Sliding Window","Divide and Conquer","String"]},{"location":"leetcode/402-remove-k-digits/","title":"402 Remove K Digits","text":"<p>\u5355\u8c03\u6808\u5f88\u597d\u7684\u9898\u76ee, \u4e5f\u6709\u5f88\u591aedge case\u9700\u8981\u5904\u7406. Edge case\u5305\u62ec:</p> <ul> <li>one pass\u540e\u53d1\u73b0k&gt;0, \u8bf4\u660estack\u4e2d\u7684\u5143\u7d20\u662f\u9012\u589e\u7684, \u9700\u8981\u4ecestack\u5c3e\u90e8\u5220\u9664k\u4e2a\u5143\u7d20</li> <li>\u6700\u540e\u7684solution stack\u53ef\u80fd\u662f<code>[0,0,0,0,0]</code>, \u9700\u8981\u53bb\u6389leading 0s. \u53bb\u5b8cleading 0s\u540e\u5982\u679c\u4e3a\u7a7a, \u8fd4\u56de\"0\". \u8fd9\u4e9b0\u6765\u6e90\u4e8e\u6bcf\u6b21\u9047\u52300\u7684\u65f6\u5019, \u4f1a\u628astack\u4e2d\u7684\u5143\u7d20\u5168\u90e8\u5f39\u51fa.</li> </ul>","tags":["String","Monotonic Stack","Greedy","Stack"]},{"location":"leetcode/402-remove-k-digits/#approach-1-monotonically-increasing-stack","title":"Approach 1: Monotonically Increasing Stack","text":"<p>\u7ef4\u62a4\u4e00\u4e2a\u5355\u8c03\u9012\u589e\u7684\u6808\uff0c\u5f53\u9047\u5230\u4e00\u4e2a\u6570\u5b57\u6bd4\u6808\u9876\u5143\u7d20\u5c0f\u7684\u65f6\u5019(\u51fa\u73b0downhill)\uff0c\u5c31\u628a\u6808\u9876\u5143\u7d20\u5f39\u51fa\uff0c\u76f4\u5230\u6808\u9876\u5143\u7d20\u6bd4\u5f53\u524d\u6570\u5b57\u5c0f\u6216\u8005\u6808\u4e3a\u7a7a\uff0c\u7136\u540e\u628a\u5f53\u524d\u6570\u5b57\u538b\u5165\u6808\u4e2d\u3002\u8fd9\u6837\u53ef\u4ee5\u4fdd\u8bc1\u6808\u4e2d\u7684\u5143\u7d20\u662f\u5355\u8c03\u9012\u589e\u7684\u3002</p> <p>\u6bcf\u6b21\u51fa\u6808\u90fddecrement k\uff0c\u76f4\u5230k\u4e3a0\u6216\u8005\u6808\u4e3a\u7a7a\u3002\u6700\u540e\uff0c\u5982\u679ck\u8fd8\u5927\u4e8e0\uff0c\u8bf4\u660e\u6808\u4e2d\u7684\u5143\u7d20\u662f\u9012\u589e\u7684\uff0c\u9700\u8981\u4ece\u6808\u5c3e\u90e8\u5220\u9664k\u4e2a\u5143\u7d20, \u56e0\u4e3a\u8fd9\u65f6\u5019\u7684stack\u662f\u4e00\u4e2a\u9012\u589e\u7684\u5e8f\u5217\uff0c\u5220\u540e\u9762\u7684\u66f4\u5212\u7b97\u3002</p> <p>Tip</p> <p>k == 0\u540e\uff0c\u540e\u9762\u7684\u6570\u5b57\u4e0d\u7ba1\u4e09\u4e03\u4e8c\u5341\u4e00\uff0c\u5168\u90fd\u8981.</p> <p>\u6700\u540e\uff0c\u628a\u6808\u4e2d\u7684\u5143\u7d20\u62fc\u63a5\u6210\u5b57\u7b26\u4e32\uff0c\u53bb\u6389leading 0, \u5982\u679c\u4e3a\u7a7a\u5219\u8fd4\u56de\"0\"\u3002</p> <pre><code>class Solution:\n    def removeKdigits(self, num: str, k: int) -&gt; str:\n        stack = []\n        for digit in num:\n            while stack and stack[-1] &gt; digit and k &gt; 0:\n                stack.pop()\n                k -= 1\n            stack.append(digit)\n\n        # remove last k digits if k &gt; 0 (increasing digits)\n        res = stack[:-k] if k else stack\n\n        # remove all leading zeros\n        final = \"\".join(res).lstrip('0')\n\n        return final if final else \"0\"\n</code></pre>","tags":["String","Monotonic Stack","Greedy","Stack"]},{"location":"leetcode/404-sum-of-left-leaves/","title":"404 Sum of Left Leaves","text":"<p>\u6709\u51e0\u4e2a\u89e3\u6cd5:</p> <ul> <li>iterative DFS</li> <li>recursive</li> <li>Morris Tree Traversal</li> </ul>","tags":["Tree","Depth-First Search","Breadth-First Search","Binary Tree"]},{"location":"leetcode/404-sum-of-left-leaves/#approach-1-dfs","title":"Approach 1 DFS","text":"<p>\u6211\u7684\u7b2c\u4e00\u76f4\u89c9\u662f\u4e0d\u53ef\u80fd\u662fBFS, \u56e0\u4e3a\u65e0\u6cd5\u4fdd\u8bc1leaf node\u5728\u540c\u4e00\u5c42. \u6240\u4ee5\u6211\u7684\u601d\u8def\u662fiterative implementation of DFS with stack. \u96be\u70b9\u5728\u4e8e\u6211\u4eec\u5982\u4f55\u5224\u65adleft leaf node. Left leaf node\u7684\u5b9a\u4e49\u662f:</p> <ul> <li>it's a left child of a parent node.</li> <li>it's a leaf node.</li> </ul> <p>left node\u7684\u7b49\u4ef7\u6761\u4ef6\u5f88\u597d\u5224\u65ad\uff0c\u4f46\u662fleft child\u5c31\u6bd4\u8f83\u96be\u5224\u65ad\u4e86, \u5982\u4e0b\u8868</p> statement \u7b49\u4ef7\u6761\u4ef6 it's a left child of a parent node ? it's a leaf node <code>not node.left and not not.right</code> <p>\u6240\u4ee5\u6211\u4eec\u9700\u8981\u5728dfs\u7684\u65f6\u5019\uff0c\u8bb0\u5f55\u989d\u5916\u7684\u4fe1\u606f\u6765\u8f85\u52a9\u6211\u4eec\u5224\u65ad. \u6211\u4eec\u53ef\u4ee5\u7528\u4e00\u4e2atuple\u6765\u50a8\u5b58\u5f53\u524dnode\u548c\u662f\u5426\u662fleft child. \u90a3\u6211\u4eec\u600e\u4e48\u51b3\u5b9a\u662f\u5426\u662fleft child\u5462\uff1f\u6211\u4eec\u5148\u5224\u65ad\u4ec0\u4e48\u65f6\u5019\u4e0d\u662fleft child:</p> <ul> <li>root node is not a left child</li> <li>\u5728dfs traversal\u987a\u5e8f\u662f\u5148\u5de6\u540e\u53f3\uff0c\u6bcf\u6b21\u5f80\u5de6\u8d70\u5f88\u591a\u6b65\uff0c\u6bcf\u6b21\u5f80\u53f3\u90fd\u662f\u524d\u8fdb\u4e00\u683c.\u8fd9\u4e2a\u6761\u4ef6\u5f88\u5173\u952e </li> </ul> <p>\u5728\u5f80\u5de6\u7684\u65f6\u5019\uff0c\u903b\u8f91\u662f <pre><code>while curr:\n    stack.append(curr)\n    curr = curr.left\n</code></pre></p> <p>\u6211\u4eec\u53d1\u73b0\u53ea\u8981stack\u4e2d\u6bcf\u6b21append\u7684\u7b2c\u4e00\u4e2a\u5143\u7d20\uff0c\u90fd\u4e0d\u662fleft child. \u90a3\u4e48\u6211\u4eec\u53ea\u9700\u8981\u7528\u4e00\u4e2aflag\u6765manipulate\u4e00\u4e0b\u5373\u53ef.</p> <pre><code># Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sumOfLeftLeaves(self, root: Optional[TreeNode]) -&gt; int:\n        \"\"\"\n        observation:\n        - can't BFS since leaf node might not be on the same layer\n        - left leaf\u6ee1\u8db3\u5de6\u8fb9\u8d70\u5230\u5934\u7684\u6761\u4ef6            \n        \"\"\"\n        if not root.left and not root.right:\n            return 0\n\n        stack = []\n        curr = root\n        res = 0\n        not_left_child = True\n        while stack or curr:\n            while curr:\n                if not_left_child:\n                    stack.append((curr,False))\n                    not_left_child = False\n                else:\n                    stack.append((curr,True))\n                curr = curr.left\n            # now we reach the left leaf node\n            # we go back, record the value and going right\n            curr,is_left_child = stack.pop()\n            if not curr.right and not curr.left and is_left_child:\n                res += curr.val\n            curr = curr.right\n            not_left_child = True\n        return res\n</code></pre>","tags":["Tree","Depth-First Search","Breadth-First Search","Binary Tree"]},{"location":"leetcode/404-sum-of-left-leaves/#approach-2-morris-tree-traversal","title":"Approach 2 Morris Tree Traversal","text":"","tags":["Tree","Depth-First Search","Breadth-First Search","Binary Tree"]},{"location":"leetcode/408-valid-word-abbreviation/","title":"408 Valid Word Abbreviation","text":"","tags":["Two Pointers","String"]},{"location":"leetcode/408-valid-word-abbreviation/#approach-1-two-pointers","title":"Approach 1 Two Pointers","text":"<p>Be careful with the edge cases like:</p> <ul> <li>handling leading zero</li> <li>handling when we encounter <code>number</code>, we can do it in two ways<ul> <li>1<ul> <li>maintain a counter the number of digits in the number</li> <li>we do slicing at the end</li> </ul> </li> <li>2<ul> <li>we maintain a list to store all digits in the number</li> <li>we join them at the end</li> </ul> </li> </ul> </li> </ul> <pre><code>class Solution:\n    def validWordAbbreviation(self, word: str, abbr: str) -&gt; bool:\n        \"\"\"\n        1. \u9047\u5230\"0\"\n        2. \u9047\u5230\u6570\u5b57\n        3. \u4e0d\u76f8\u540c\u7684char\n        \"\"\"\n        i = j = 0\n        m,n = len(word),len(abbr)\n\n        while i &lt; m and j &lt; n:\n            if word[i] == abbr[j]:\n                i += 1\n                j += 1\n            elif abbr[j] == '0':\n                # non-empty\n                return False\n            elif abbr[j].isnumeric():\n                k = j\n                while k &lt; n and abbr[k].isnumeric():\n                    k += 1\n                i += int(abbr[j:k])\n                j = k\n            else:\n                # both are characters\n                return False\n\n        return i == m and j == n\n</code></pre>","tags":["Two Pointers","String"]},{"location":"leetcode/41-first-missing-positive/","title":"41 First Missing Positive","text":"","tags":["Array","Hash Table"]},{"location":"leetcode/41-first-missing-positive/#approach-1-in-place-algorithm","title":"Approach 1 in-place algorithm","text":"<p>intuition:</p> <ul> <li>solution must be withtin [1,n] for <code>len(nums) == n</code>, with edge case of [1,2,3]  where result is <code>n+1</code></li> </ul> <p>algorithm:</p> <ul> <li>map <code>[1,n]</code> solution space to index <code>[0,n-1]</code> of the <code>nums</code> by convert it from <code>int</code> to <code>tuple</code> of <code>(num, seen?)</code></li> <li>first pass to mark the array</li> <li>second pass to find the value at index <code>i</code> that is not a tuple. then <code>i+1</code> must be solution</li> <li>third pass to revert it back to original states</li> </ul> <pre><code>class Solution:\n    def firstMissingPositive(self, nums: List[int]) -&gt; int:\n        \"\"\"\n        given unsorted integeter array, return smallest postive integer in nums\n        Constraints:\n        - O(n) in time O(1) in space\n        - n \\in [1,10^5]\n\n        Obvervastions:\n        - negative number,\n        - 0 doesn't count as positive interger, Z^{+}\n        - it could be to the left, mid and right\n            - [2,3,4] --&gt; 1 left\n            - [1,4,2] --&gt; 3 mid\n            - [3,1,2,] --&gt; 4 right\n\n        potential solution:\n        - sort it, [-1,1,3,4] find the first value &gt; 0\n            - if it's not 1, we found it to the left\n            - if it's 1, we continue to scan until \"gap\"\n            - if it reaches the end, it's end + 1\n            - O(nlogn) in time, O(1) in space\n        - set(nums) and we check from [1,...x], \n        - it could be large cuz nums[i] \\in [-2^31 .. 2^31-1]\n\n        intuition:\n        - it is suggested it's a in-place, could be a two-pass \n            - 1st pass to mark the array somehow\n            - 2nd pass, just to locate it\n        - maintain a global min but positive O(1)\n        - the nums size is O(n), which mean we don't care value greater than n, it has to be withtin [1,n] since \n        we can also have negaitve values and values &gt; n to \"dilute\" the solution space\n        - we only care about it, if the value is \\in [1,n] and we can mark it somehow to [0,n-1]\n        - gaussian sum only works if we only have 1 value not from it. If we have two, we c\n        we can \"*= -1\" [0,n-1] for values [1,n],         \n        \"\"\"\n        n = len(nums)\n        res = n+1\n\n        for i,num in enumerate(nums):\n            if type(num) is tuple:\n                num , _ = num\n            # we only care if num \\in [1,n]\n            if num &gt;= 1 and num&lt;= n:\n                if type(nums[num-1]) is tuple:\n                    # we have seen it\n                    continue\n                nums[num-1] = (nums[num-1], True)\n\n        for i,num in enumerate(nums):\n            if type(num) is not tuple:\n                res = i+1\n                break\n\n        # revert it back in-place\n        nums = [num[0] if num is tuple else num for num in nums]\n\n        # if ever reach here, we can do some logic to check it's \n        return res\n</code></pre>","tags":["Array","Hash Table"]},{"location":"leetcode/435-non-overlapping-intervals/","title":"435 Non-overlapping Intervals","text":"<p>Greedy, interval\u7684\u9898\u76ee. \u51e0\u79cd\u601d\u8def\uff0c</p> <ul> <li>brute force, each position, we can either remove or keep the interval, \\(O(2^n)\\)</li> <li>greedy, first sort</li> </ul>","tags":["Array","Sorting","Greedy"]},{"location":"leetcode/435-non-overlapping-intervals/#approach-1-sort-by-start-greedy","title":"Approach 1 Sort by Start Greedy","text":"<p>maintain a list of non-overlapping intervals. \u6211\u4eec\u6c42minimum number of intervals you need to remove, \u4e5f\u5c31\u662f\u6c42non-overlapping intervals\u7684\u6700\u5927\u957f\u5ea6, \u6240\u4ee5\u6211\u4eec\u7684\u76ee\u6807\u5c31\u662f\u5c3d\u53ef\u80fd\u8ba9\u8fd9\u4e2a\u6570\u7ec4\u8d8a\u957f\u8d8a\u597d.</p> <p>We sort by start time aescedingly, then by end time aescedingly. We will have <pre><code>|----|\n|-------|\n       |---|\n          |---|   \n</code></pre></p> <p>\u6211\u4eec\u7684\u6b65\u9aa4\u662f</p> <ul> <li>sort by start time aescendingly, then by end time aescendingly</li> <li>\u7ef4\u62a4\u4e00\u4e2a\u6570\u7ec4, \u8bb0\u5f55non-overlapping intervals</li> <li>\u5224\u65ad\u662f\u5426overlap<ul> <li>\u5982\u679coverlap, \u53c8\u8981\u8fdb\u884c\u4e00\u6b21\u5224\u5b9a\uff0c\u662fremove\u65b0\u6765\u7684curr interval,\u8fd8\u662fprev interval. \u8981\u9009\u62e9\u6700\u5c0f\u7684end time\u7684\u90a3\u4e2ainterval. \u56e0\u4e3aend time\u8d8a\u5927\uff0c\u8d8a\u6709\u53ef\u80fdoverlap with other intervals.</li> <li>\u5982\u679c\u4e0doverlap, \u5c31append\u5230res\u91cc\u9762</li> </ul> </li> </ul> <pre><code>class Solution:\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -&gt; int:        \n        intervals.sort()\n\n        n = len(intervals)\n        # store non-overlapping interval\n        res = [intervals[0]]\n\n        # remove larger fish\n        for curr_start,curr_end in intervals[1:]:\n            prev_start,prev_end = res[-1]\n\n            if curr_start &lt; prev_end:\n                # we have overlap! we can remove either 1, but we want to remove the one that's larger and longer\n\n                # since the longer the interval, the more likely it's going to over lap with another\n                if curr_end &gt;= prev_end:\n                    # we remove the curr one\n                    continue\n                else:\n                    # we replace the last one\n                    res.pop()\n                    res.append([curr_start,curr_end])\n                    continue\n\n            res.append([curr_start,curr_end])\n        print(intervals)\n        return n - len(res)\n</code></pre> <p>\u8fdb\u884c\u4e0b\u4f18\u5316\uff0c - \u6211\u4eec\u53ea\u5173\u5fc3last interval\u7684min. \u4e0d\u9700\u8981\u7ef4\u62a4\u6574\u4e2a\u6570\u7ec4\uff0c\u7ef4\u62a4\u4fe9\u53d8\u91cf\uff0c\u4e00\u4e2a\u662fnon-overlapping interval\u7684\u6570\u91cf\uff0c\u4e00\u4e2a\u662f<code>prev_end</code>\u7528\u4e8e\u505a\u5224\u5b9a - <code>prev_end</code>\u66f4\u65b0\u5982\u4e0b     - \u5982\u679coverlap, \u53d6min     - \u5982\u679c\u4e0doverlap, \u76f4\u63a5\u66f4\u65b0\u4e3acurr_end</p> <pre><code>class Solution:\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -&gt; int:\n        \"\"\"\n        1. start aesc, end aesc\n        |----|\n            |---|\n            |------|\n        \"\"\"        \n\n        # store non-overlapping interval\n        intervals.sort()\n\n        n = len(intervals)\n        _, prev_end = intervals[0]\n        num_of_non_overlap = 1\n\n        # remove larger fish\n        for curr_start,curr_end in intervals[1:]:\n            if curr_start &lt; prev_end:\n                # we overlap\n                prev_end = min(prev_end,curr_end)\n            else:\n                # we don't overlap\n                prev_end = curr_end\n                num_of_non_overlap += 1\n\n        return n - num_of_non_overlap\n</code></pre>","tags":["Array","Sorting","Greedy"]},{"location":"leetcode/442-find-all-duplicates-in-an-array/","title":"442 Find all Duplicates in an Array","text":"<p>follow-up: can you solve it without extra space and in O(n) runtime? \u8fd9\u4e00\u9898\u7684trick\u548cprefix sum\u4e2d525 Contiguous Array\u5f88\u50cf.</p> <p>Two things came to my mind are:</p> <ul> <li>brute force , O(n^2), O(1)</li> <li>set, O(n), O(n)</li> </ul> <p>Observation:</p> <ul> <li>for an array of length n, nums are in the range[1,n] some of those number could be missing from the array</li> <li>if an integer appears, it must appear either one or twice. Nothing larger</li> </ul> <p>So it is suggesting a in-place algorithm. We can use index to store whether we have seen the number or not.  <pre><code>value 1,2,3,4,5\nindex 0,1,2,3,4\n</code></pre> The ultimate trick is that, we only care if we have seen it before or not. And it at most appears twice. So we can use the sign of the number to mark it. </p> <p>interview tip from LC editoral</p> <p>This approach modifies the input. It changes the order of nums, but not the values of nums. In-place algorithms overwrite the input to save space, but sometimes this can cause problems.</p> <p>Here are a couple of situations where an in-place algorithm might not be suitable.</p> <ul> <li>The algorithm needs to run in a multi-threaded environment, without exclusive access to the array. Other threads might need to read the array too, and might not expect it to be modified.</li> <li>Even if there is only a single thread, or the algorithm has exclusive access to the array while running, the array might need to be reused later or by another thread once the lock has been released.</li> </ul> <p>In an interview, you should always check whether the interviewer minds you overwriting the input. Be ready to explain the pros and cons of doing so if asked!</p> <p>\u5f53\u7136\uff0c\u4f60\u4e5f\u53ef\u4ee5one-pass scan to modify it back to original array.</p>","tags":["Array","Hash Table"]},{"location":"leetcode/442-find-all-duplicates-in-an-array/#approach-1-in-place-algorithm","title":"Approach 1 in-place algorithm","text":"<pre><code>class Solution:\n    def findDuplicates(self, nums: List[int]) -&gt; List[int]:\n        \"\"\"\n\n        we sort of need a hashset-like thing to mark what we have seen so far.\n        Observation:\n        - for an array of length n, nums are in the range[1,n] some of those number could be missing from the array\n        - if an integer appears, it must appear either one or twice. Nothign larger\n        --&gt; we can try a in-place algorithm\n        value 1,2,3,4,5\n        index 0,1,2,3,4\n        \"\"\"\n        n = len(nums)\n        res = []\n        for i in range(n):\n            curr = abs(nums[i])\n            if nums[curr-1] &gt; 0:\n                # we haven't seen it, markit\n                nums[curr-1] *= -1\n            else:\n                # we have seen it b4!!\n                res.append(curr)\n\n        return res\n</code></pre>","tags":["Array","Hash Table"]},{"location":"leetcode/451-sort-characters-by-frequency/","title":"451 Sort Characters By Frequency","text":"<p>\u8fd9\u9898\u6bd4\u8f83\u7b80\u5355\uff0c\u4e5f\u662fbucket sort\u601d\u60f3\u7684\u4e00\u79cd\u5ef6\u4f38\uff0c\u8fd9\u91cc\u8bb2\u4e09\u79cd\u89e3\u6cd5</p> <ul> <li>hashmap + sorting, O(nlogn) in time, O(n) in space</li> <li>bucket sort, array as auxillary DS, O(n) in time, O(n) in space</li> <li>bucket sort, hashmap as auxillary DS, O(n) in time, O(n) in space</li> </ul>","tags":["Hash Table","String","Sorting","Bucket Sort","Heap (Priority Queue)","Counting"]},{"location":"leetcode/451-sort-characters-by-frequency/#approach-1-hashmap-sorting-by-value-onlogn-in-time-on-in-space","title":"Approach 1 hashmap + sorting by value, O(nlogn) in time, O(n) in space","text":"<p>Steps are:</p> <ul> <li>hashmap \u7edf\u8ba1\u6bcf\u4e2a\u5b57\u7b26\u51fa\u73b0\u7684\u6b21\u6570</li> <li>sorting by value, \u4ece\u5927\u5230\u5c0f</li> </ul> <p>Tip</p> <p><code>sorted()</code> in python \u4e0d\u505ain-place sorting, \u6240\u4ee5\u4e0d\u4f1a\u6539\u53d8\u539f\u6765\u7684iterable. \u65e0\u8bba\u539f\u6765\u7684iterable\u662f<code>dict()</code> or <code>list()</code>, \u8fd4\u56de\u7684\u90fd\u662f\u4e00\u4e2a\u65b0\u7684list</p> <pre><code>from collections import defaultdict\nclass Solution:\n    def frequencySort(self, s: str) -&gt; str:\n        hashmap = defaultdict(int)\n        for c in s:\n            hashmap[c] += 1\n\n        res = []\n        for i in sorted(hashmap, key=lambda x: hashmap[x], reverse=True):\n            res.append(i*hashmap[i])\n\n        return \"\".join(res)\n</code></pre>","tags":["Hash Table","String","Sorting","Bucket Sort","Heap (Priority Queue)","Counting"]},{"location":"leetcode/451-sort-characters-by-frequency/#approach-2-bucket-sort-array-as-auxillary-ds-on-in-time-on-in-space","title":"Approach 2 bucket sort, array as auxillary DS, O(n) in time, O(n) in space","text":"<p>Use of array as the auxillary with index as count, value as a list of occured chars, example are: <pre><code>s = \"tree\"\n#         0      1       2    3   4\nbucket = [[],[\"t\",\"r\"],[\"e\"],[], []]\n</code></pre> Similar idea,</p> <ul> <li>hashmap with key-value pair as <code>char:count</code></li> <li>use bucket sort with array</li> </ul> <pre><code>from collections import defaultdict\nclass Solution:\n    def frequencySort(self, s: str) -&gt; str:\n        # idea of bucket sort: O(n) in time, O(n) in space.\n        # construct a hash with char:count\n        char_count_hash = defaultdict(int)\n\n        for c in s:\n            char_count_hash[c] += 1\n\n        # construct a array with index as count, value as a list of occured chars\n        # 0. 1.         2.            3.  4\n        # [].[] [char,char,char]     [].  []\n        bucket = [[] for _ in range(len(s)+1)]\n\n        for char,count in char_count_hash.items():\n            bucket[count].append(char)\n\n        res = []\n        for i in range(len(bucket) -1, 0,-1):\n            for j in range(len(bucket[i])):\n                res.append(bucket[i][j] * i)\n\n        return \"\".join(res)\n</code></pre>","tags":["Hash Table","String","Sorting","Bucket Sort","Heap (Priority Queue)","Counting"]},{"location":"leetcode/451-sort-characters-by-frequency/#approach-3-bucket-sort-hashmap-as-auxillary-ds-on-in-time-on-in-space","title":"Approach 3 bucket sort, hashmap as auxillary DS, O(n) in time, O(n) in space","text":"<p>This approach is similar to approach 2 but slightly more efficient in terms of space. If you use array for bucket sort, you need to build an array of <code>len(s)</code>. However, if you use hashmap, you only need to build a hashmap with key as count appeared in the counter, value as a list of occurred chars. On average case, approach 3 with hashmap is more efficient than approach 2 with array in terms of space. But worst case for space complexity, it's the same as approach 2.</p> <pre><code>from collections import defaultdict\nclass Solution:\n    def frequencySort(self, s: str) -&gt; str:\n        # idea of bucket sort: O(n) in time, O(n) in space.\n        # construct a hash with char:count\n        char_count_hash = defaultdict(int)\n\n        for c in s:\n            char_count_hash[c] += 1\n\n        # construct a hashmap with count --&gt; [char,char]\n        bucket = defaultdict(list)\n        for char, count in char_count_hash.items():\n            bucket[count].append(char)\n\n        # we can traverse the length of the string s,\n        res = []\n        for count in range(len(s),0,-1):\n            for char in bucket[count]:\n                res.append(char * count)\n\n        return \"\".join(res)\n</code></pre>","tags":["Hash Table","String","Sorting","Bucket Sort","Heap (Priority Queue)","Counting"]},{"location":"leetcode/452-minimum-number-of-arrows-to-burst-balloons/","title":"452 Minimum Number of Arrows to Burst Balloons","text":"<p>\u611f\u89c9\u4e0d\u5230greedy, \u53ef\u80fd\u8fd8\u662f\u4e0d\u654f\u611f.</p>","tags":["Array","Greedy","Sorting"]},{"location":"leetcode/452-minimum-number-of-arrows-to-burst-balloons/#approach-1-sorting-greedy","title":"Approach 1 Sorting + Greedy","text":"<p>complexity</p> <p>O(nlogn) in time, O(n) in space. Sorting takes O(nlogn) time, and we use O(n) space to store all the intersections</p> <p>The main intuition is that we can only kill multiple birds with one arrow if they are overlapping. In another words, it exists an intersection \\(\\left[x_{start},x_{end}\\right]\\) that all the balloons have that in their own range. We just need to maintain a list of intersections and return the length of it. The steps are,</p> <ul> <li>sort <code>points</code> by start location</li> <li>iterate through <code>points</code> and find the intersection</li> </ul> <p>Code Implementation</p> <pre><code>class Solution:\n    def findMinArrowShots(self, points: List[List[int]]) -&gt; int:\n        # 1. sort by start location, now we have an Array with ascending start time\n        # 2. trying to find the intersection of it\n        # 3. return len(Array)\n\n        points.sort(key=lambda x:x[0])\n\n        res = [points[0]]\n\n        for i in range(1,len(points)):\n            curr_start,curr_end = points[i]\n            prev_start,prev_end = res[-1]\n            if curr_start &gt;= prev_start and curr_start &lt;= prev_end:\n                # we have an intersection!\n                candidate = [curr_start, min(prev_end,curr_end)]\n                res.pop()\n                res.append(candidate)\n            else:\n                # not meragable\n                res.append(points[i])\n\n        return len(res)\n</code></pre> <p>We can make two improvement over the above code,</p> <ul> <li>we maintained an Array <code>res</code> to store the intersection range. But we only care about the last element of it. So we just maintain a variable for the last intersection range and another variable for counting number of errors. The intuition is we already sort it by start time.</li> <li>since we sort it by start_time already, we can simplify <code>curr_start &gt;= prev_start and curr_start &lt;= prev_end</code> to <code>curr_start &lt;= prev_end</code>. No need for redundant check.</li> </ul> <p>space optimized</p> <pre><code>class Solution:\ndef findMinArrowShots(self, points: List[List[int]]) -&gt; int:\n    points.sort(key=lambda x:x[0])\n\n    res = points[0]\n    arrows = 1\n    # actually we don't even care about the anything other than the last element in the Array\n    # we might as well just use a plain list instead of list of list.\n    for i in range(1,len(points)):\n        curr_start,curr_end = points[i]\n        prev_start,prev_end = res\n        if curr_start &lt;= prev_end:\n            # we have an intersection, \u4e00\u7bad\u53cc\u96d5\n            candidate = [curr_start, min(prev_end,curr_end)]\n            res = candidate\n        else:\n            # not meragable\n            res = points[i]\n            arrows += 1\n\n    return arrows\n</code></pre>","tags":["Array","Greedy","Sorting"]},{"location":"leetcode/456-132-pattern/","title":"456 132 Pattern","text":"<p>\u8fd9\u9898\u5e94\u7528\u4e86monotonic stack, \u4f46\u662f\u76f8\u5f53tricky. </p>","tags":["Array","Binary Search","Stack","Monotonic Stack","Ordered Set"]},{"location":"leetcode/456-132-pattern/#approch-1-monotonic-stack","title":"Approch 1: Monotonic Stack","text":"<p>\u9700\u8981\u5728\u6570\u7ec4nums\u4e2d\uff0c\u53d1\u73b0\u7b26\u5408\u4e00\u4e0b\u6761\u4ef6: <pre><code>i &lt; j &lt; j and nums[i] &lt; nums[k] &lt; nums[j]\n</code></pre></p> <p>visualize\u4e00\u4e0b\uff0c\u662f\u627e\u4e2a\u5982\u4e0b\u56fe\u7684\u5c71\u5cf0,</p> <p></p> <p>Therefore, \u6211\u4eec\u628a\u8fd9\u4e2a\u95ee\u9898\u5206\u4e3a\u4e24\u4e2a\u5b50\u95ee\u9898,</p> <ul> <li>\u627e\u5230<code>nums[k] &lt; nums[j]</code> and <code>j &gt; k</code> (\u7b49\u4ef7\u4e8enext smaller element)</li> <li>\u627e\u5230<code>nums[i] &lt; nums[k]</code> and <code>i &lt; j</code></li> </ul> <p>\u6240\u4ee5\u6211\u4eec\u9700\u8981\u7ef4\u62a4</p> <ul> <li>Traverse <code>nums[k]</code>, \u4e00\u4e2a\u5347\u5e8f\u5355\u8c03\u6808\uff0c\u8ba9\u6bcf\u6b21\u8fdb\u6765\u7684<code>nums[k]</code>\u8fdb\u6765\u627e\u8001\u5927.</li> <li>\u4e00\u4e2a<code>prev_min</code>\u6570\u7ec4\uff0c\u8bb0\u5f55\u6bcf\u4e2a<code>nums[k]</code>\u5de6\u8fb9\u7684\u6570\u7ec4<code>nums[:k]</code>\u7684\u6700\u5c0f\u503c (not including <code>nums[k]</code>)</li> </ul> <p>\u8fd9\u6837\u53ea\u8981\u6bcf\u6b21\u6211\u4eec\u8fdb\u6765\u7684<code>nums[k]</code>\u627e\u5230\u4e86\u8001\u5927<code>nums[j]</code>\uff0c\u6211\u4eec\u5c31\u53ef\u4ee5\u6bd4\u8f83<code>nums[:j]</code>\u4e2d\u7684\u6700\u5c0f\u503c\uff0c\u662f\u5426\u5c0f\u4e8e<code>nums[k]</code>.</p>","tags":["Array","Binary Search","Stack","Monotonic Stack","Ordered Set"]},{"location":"leetcode/456-132-pattern/#code-implementation","title":"Code Implementation","text":"<pre><code>class Solution:\n    def find132pattern(self, nums: List[int]) -&gt; bool:\n        # maintaining a monotonically stack that we have a value that's smaller than it\n        \"\"\"\n                x\n                        x\n        x\n        next greater element: maintain \u5347\u5e8f\u5355\u8c03stack\n        next smaller element: maintain \u964d\u5e8f\u5355\u8c03stack\n\n        \u6211\u4eec\u8fd9\u4e00\u9898\u7ef4\u62a4\u7684\u662f, \n            1. nums[k], \u4e5f\u5c31\u662f\u7b2c\u4e09\u4e2a\u6570. \u5bf9\u4e8enums[k]\u662f\u5426\u5b58\u5728\u4e00\u4e2a\u6253\u4e0d\u8fc7\u7684\u8001\u5927\u4e5f\u5c31\u662fstack\u4e2d\u8fd8\u6709\u65b0\u6765\u7684nums[k]\u6253\u4e0d\u8fc7\u7684\u6570. \u8fd9\u4e2a\u8001\u5927\u4e5f\u5c31\u662fnums[j]\n            2. \u627e\u5230\u8001\u5927\u4e4b\u540e\uff0c\u6211\u4eec\u770b\u8fd9\u4e2a\u8001\u5927\u7684\u5de6\u8fb9\uff0c\u6709\u6ca1\u6709\u6bd4\u5b83\u5f31\u7684\u6570\u5b57nums[i].\n        \"\"\"\n\n        # preprocessing a hash for lookup: \n        prev_min = [None for _ in range(len(nums))]\n        prev_min[0] = max(nums)+1\n        for i in range(1,len(nums)):\n            prev_min[i] = min(prev_min[i-1],nums[i-1])\n\n        # traverse the list until found\n        stack = []\n        for k in range(len(nums)):\n            # try to find boss (nums[j])\n            while stack and nums[k] &gt;= nums[stack[-1]]:\n                stack.pop()\n\n            # we find the boss (nums[j])! let's find the nums[i] that's the weakest\n            if stack and nums[k] &gt; prev_min[stack[-1]]:\n                return True\n\n            # append the stack\n            stack.append(k)\n\n        return False\n</code></pre>","tags":["Array","Binary Search","Stack","Monotonic Stack","Ordered Set"]},{"location":"leetcode/456-132-pattern/#reference","title":"Reference","text":"<ul> <li>Neetcode 132 pattern</li> </ul>","tags":["Array","Binary Search","Stack","Monotonic Stack","Ordered Set"]},{"location":"leetcode/46-permutations/","title":"46 Permutations","text":""},{"location":"leetcode/46-permutations/#problem-statement","title":"Problem statement","text":""},{"location":"leetcode/46-permutations/#introduction","title":"Introduction","text":"<p>backtracking\u5165\u95e8\u9898\u76ee\uff0c\u7ed9\u5b9a\u4e00\u4e2a\u6570\u7ec4\uff0c\u8fd4\u56de\u6240\u6709\u7684permutation.</p>"},{"location":"leetcode/46-permutations/#code-implementation","title":"Code implementation","text":"<pre><code>class Solution:\n    def permute(self, nums: List[int]) -&gt; List[List[int]]:\n        def backtrack(curr):\n            \"\"\"\n            curr: current permutation we building\n            \"\"\"\n            # recursion base condition\n            if len(curr) == len(nums):\n                ans.append(curr[:])\n                return\n\n            for num in nums:\n                # \u5728curr\u91cc\u7684\u6570\u5b57\uff0c\u5df2\u7ecf\u8d70\u8fc7\u4e86\uff0clock\u6b7b\uff0c\u7565\u8fc7\n                if num not in curr:\n                    curr.append(num)\n                    backtrack(curr)\n                    curr.pop()\n\n            ans = []\n            backtrack([])\n            return ans\n</code></pre>"},{"location":"leetcode/463-island-perimeter/","title":"463 Island Perimeter","text":"<p>\u6700\u4f18\u89e3\u5c31\u662f\u66b4\u529b\u89e3.</p>","tags":["Array","Matrix","Depth-First Search","Breadth-First Search"]},{"location":"leetcode/463-island-perimeter/#approach-1-brute-force","title":"Approach 1: Brute Force","text":"<p>Note</p> <ul> <li>Time Complexity: O(m*n)</li> <li>Space Complexity: O(1)</li> </ul> <pre><code>class Solution:\n    def islandPerimeter(self, grid: List[List[int]]) -&gt; int:\n        \"\"\"\n        observation:\n        - determine adjacent nodes to see \n            - out of bounds: +1\n            - sea: + 1\n            - else: + 0                        \n        \"\"\"\n        m,n = len(grid),len(grid[0])\n\n        res = 0\n        for i in range(m):\n            for j in range(n):\n                # adjacent nodes, (i-1,j), (i+1,j),(i,j-1),(i,j+1)\n                # left\n                if grid[i][j] == 0:\n                    continue\n\n                curr = 0\n                if j-1 &lt; 0 or (j-1 &gt;= 0 and grid[i][j-1] == 0):\n                    curr += 1\n                # right\n                if j+1 &gt;= n or (j+1 &lt; n and grid[i][j+1] == 0):\n                    curr += 1\n                # top\n                if i-1 &lt; 0 or (i-1 &gt;= 0 and grid[i-1][j] == 0):\n                    curr += 1                \n                # bottom\n                if i + 1 &gt;= m or (i+1 &lt; m and grid[i+1][j] == 0):\n                    curr += 1\n\n                res += curr\n        return res            \n</code></pre>","tags":["Array","Matrix","Depth-First Search","Breadth-First Search"]},{"location":"leetcode/496-next-greater-element-I/","title":"496 Next Greater Element I","text":"","tags":["Array","Hash Table","Stack","Monotonic Stack"]},{"location":"leetcode/496-next-greater-element-I/#approach-1-monotonic-stack","title":"Approach 1 Monotonic Stack","text":"<p>\u6211\u7684\u601d\u8def\u5982\u4e0b:</p> <ul> <li>BFS\u9700\u8981\\(O(mn^2)\\)\u7684\u65f6\u95f4\u590d\u6742\u5ea6\uff0cwhere <code>m</code> and <code>n</code> are the length of <code>nums1</code> and <code>nums2</code>, respectively.<ul> <li>for every element in <code>nums1</code>, find where <code>nums1[i] == num2[j]</code>, then find the next greater element in <code>nums2</code> for <code>nums2[j]</code>.</li> </ul> </li> </ul> <p>\u65e2\u7136\u8fd9\u6837\uff0c\u8fd9\u4e2a\u95ee\u9898\u53d8\u6210\u4e86\u4e24\u4e2a\u5b50\u95ee\u9898:</p> <ul> <li><code>problem 1</code>: \u5982\u4f55\u627e\u5230next greater/smaller element in an array</li> <li><code>problem 2</code>: \u5982\u4f55\u5feb\u901f\u627e\u5230<code>nums1[i] == nums2[j]</code>\u7684index</li> </ul> <p>For <code>problem 1</code>, next greater/smaller element is the expertise for monotonic stack.</p> <ul> <li>we maintain a monotonic stack with larger value at bottom. Whenever we <code>pop</code>, it's the time for record the next greater element for the element we <code>pop</code>.</li> </ul> <p>For <code>problem 2</code>, </p> <ul> <li>We need an auxillary DS to help <code>nums1</code> to lookup<ul> <li>where <code>nums1[i] == nums2[j]</code> can be found or not as fast as possible. </li> <li>this value <code>nums[i]</code> should associate with the next greater element in nums2 if it exists.</li> </ul> </li> <li>\u6839\u636e\u8fd9\u4e2a\u9700\u6c42\uff0c\u6211\u60f3\u5230\u4e86hashmap for O(1) lookup. Also using defaultdict to set missing value to -1.</li> </ul>","tags":["Array","Hash Table","Stack","Monotonic Stack"]},{"location":"leetcode/496-next-greater-element-I/#code-implementation","title":"Code Implementation","text":"<pre><code>from collections import defaultdict\nclass Solution:\n    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -&gt; List[int]:\n        # 1000, BF: O(n * m * m)\n        # descendingly monotonic stack: larger number at bottom, when poping, we find the index\n        # tricky: how to deal with not found\n        # dry run: [1],[3],[4],[2]\n        # auxillary DS:\n        #  - allow quick lookup from nums1\n        #. - want to grab the index of next greatest value\n        # having a hashmap with default to be -1\n\n        # create a stack (list), create a defaultdict with -1 as default\n\n        # travserse nums2, maintaining the monotonic stack and assign value to hash whenever we have a pop\n\n        hashmap = defaultdict(lambda: -1)\n        stack = []\n\n        for num in nums2:\n            while stack and num &gt; stack[-1]:\n                hashmap[stack.pop()] = num\n            stack.append(num)\n\n        res = [hashmap[num] for num in nums1]\n\n        return res\n</code></pre>","tags":["Array","Hash Table","Stack","Monotonic Stack"]},{"location":"leetcode/5-longest-palindromic-substring/","title":"asda","text":"<p>asd</p>"},{"location":"leetcode/506-relative-ranks/","title":"506 Relative Ranks","text":"<p>\u8fd9\u9898\u4e24\u79cd\u89e3\u6cd5,</p> <ul> <li>sorting (O(nlogn)). Most intuitive.</li> </ul>","tags":["Array","Sorting","Heap (Priority Queue)"]},{"location":"leetcode/506-relative-ranks/#approach-1-sorting","title":"Approach 1 Sorting","text":"<p>Time complexity</p> <ul> <li>O(nlogn) for sorting</li> <li>O(n) for constructing an array of tuples <code>[(score, index),(score,index),...]</code></li> </ul> <pre><code>class Solution:\n    def findRelativeRanks(self, score: List[int]) -&gt; List[str]:\n        \"\"\"\n        start off by creating an array of tuples for (score,index)\n            temp = [(10,0),(3,1),(8,2),(9,3),(4,4)]\n        remember to sort\n            temp.sort(key=lambda x:x[0],reverse=True)\n        after sorting, the array will look like this\n            temp = [(10,0),(9,3),(8,2),(4,4),(3,1)]\n        \"\"\"\n        # empty\n        if len(score) == 0:\n            return []\n\n        n = len(score)\n        res = [None for _ in range(n)]\n\n        temp = [(num,i) for i,num in enumerate(score)]\n        temp.sort(reverse=True)\n        for rank in range(n):            \n            idx = temp[rank][1]\n            if rank == 0:\n                medal = \"Gold Medal\"\n            elif rank == 1:\n                medal = \"Silver Medal\"\n            elif rank == 2:\n                medal = \"Bronze Medal\"\n            else:\n                medal = str(rank+1)\n\n            res[idx] = medal\n\n        return res\n</code></pre>","tags":["Array","Sorting","Heap (Priority Queue)"]},{"location":"leetcode/506-relative-ranks/#approach-2-heap-priority-queue","title":"Approach 2 Heap (Priority Queue)","text":"<p>\u6548\u7387\u6ca1\u53d8\uff0c\u9700\u8981heappush n\u6b21\u3002For an array of tuple, \u6ca1\u529e\u6cd5\u7528built-in heapify\u6765\u505a, \u90a3\u4e2a\u53ea\u80fd\u5904\u7406array of <code>numbers</code> or <code>str</code>.</p> <pre><code>from heapq import heapify,heappush,heappop\nclass Solution:\n    def findRelativeRanks(self, score: List[int]) -&gt; List[str]:\n        # empty\n        if len(score) == 0:\n            return []\n\n        heap = []\n        # n * log(n)\n        for i,num in enumerate(score):\n            heappush(heap,(-num,i))\n\n        rank = 1\n        res = [None] * len(score)\n        while heap:\n            _ , people_idx = heappop(heap)\n            if rank == 1:\n                medal = 'Gold Medal'\n            elif rank == 2:\n                medal = 'Silver Medal'\n            elif rank == 3:\n                medal = 'Bronze Medal'\n            else:\n                medal = str(rank)\n            res[people_idx] = medal\n            rank += 1\n        return res\n</code></pre>","tags":["Array","Sorting","Heap (Priority Queue)"]},{"location":"leetcode/509-fibonacci-number/","title":"509 Fibonacci Number","text":"<p>Recursion + DP\u5165\u95e8\u9898</p>","tags":["Math","Dynamic Programming","Recursion","Memoization"]},{"location":"leetcode/509-fibonacci-number/#approach-1-recursion-top-down","title":"Approach 1 Recursion (top-down)","text":"<pre><code>class Solution:\n    def fib(self, n: int) -&gt; int:\n        # base cases\n        if n == 0:\n            return 0\n        elif n == 1:\n            return 1\n\n        # recurring cases\n        return self.fib(n-1) + self.fib(n-2)\n</code></pre>","tags":["Math","Dynamic Programming","Recursion","Memoization"]},{"location":"leetcode/509-fibonacci-number/#approach-2-recursion-with-memoization","title":"Approach 2 Recursion with Memoization","text":"<p>use class variable</p> <pre><code>class Solution:\n    # class variable, use memoization to store results of previous sub problems\n    cache = {0:0,1:1}\n\n    def fib(self, n: int) -&gt; int:\n        # bases cases: results in the cache\n        if n in self.cache:\n            return self.cache[n]\n\n        # update cache\n        self.cache[n] = self.fib(n-1) + self.fib(n-2)\n\n        return self.cache[n]\n</code></pre> <p>You could also use instance variable</p> <pre><code>class Solution:\n    def __init__(self):\n        self.memo = {}\n\n    def fib(self, n: int) -&gt; int:\n        # check if in memo\n        if n in self.memo:\n            return self.memo[n]\n\n        # base case\n        if n == 0:\n            return 0\n        elif n == 1:\n            return 1\n        else:\n            # n&gt;2\n            curr = self.fib(n-1) + self.fib(n-2)\n            self.memo[n] = curr\n            return curr\n</code></pre>","tags":["Math","Dynamic Programming","Recursion","Memoization"]},{"location":"leetcode/509-fibonacci-number/#approach-3-tabulation-iterative-bottom-up","title":"Approach 3 Tabulation (iterative bottom-up)","text":"<pre><code>class Solution:\n    def fib(self, n: int) -&gt; int:\n        # base cases\n        if n &lt;= 1:\n            return n\n\n        # auxillary DS list \n        cache = [None for _ in range(n+1)]\n        cache[0],cache[1] = 0,1\n\n        for i in range(2,n+1): # right hand exclusive\n            cache[i] = cache[i-1] + cache[i-2]\n\n        return cache[n]\n</code></pre>","tags":["Math","Dynamic Programming","Recursion","Memoization"]},{"location":"leetcode/509-fibonacci-number/#approach-4-tabulation-with-space-optimization","title":"Approach 4 Tabulation with Space Optimization","text":"<pre><code>class Solution:\n    def fib(self, n: int) -&gt; int:\n        if n == 0: return 0\n        if n == 1: return 1\n\n        prev = 0\n        curr = 1\n        for i in range(2,n+1):\n            temp = curr\n            curr = prev + curr\n            prev = temp\n\n        return curr\n</code></pre>","tags":["Math","Dynamic Programming","Recursion","Memoization"]},{"location":"leetcode/513-find-bottom-left-tree-value/","title":"513 Find Bottom Left Tree Value","text":"","tags":["Tree","Depth-First Search","Breadth-First Search","Binary Tree"]},{"location":"leetcode/513-find-bottom-left-tree-value/#approach-1-bfs","title":"Approach 1 BFS","text":"<p>\u60f3\u5230\u7684\u7b2c\u4e00\u4e2a\u601d\u8def\uff0c\u95ee\u9898\u6c42\u6700\u540e\u4e00\u5c42\u6700\u5de6\u8fb9\u7684\u503c\uff0c\u90a3\u4e48\u6211\u4eec\u5c31\u53ef\u4ee5\u7528BFS, right to left\u6c42\u89e3\u3002</p> <p>BFS order</p> <ul> <li>\u4ece\u5de6\u5230\u53f3BFS\u5148append left child, \u518dappend right child.</li> <li>\u4ece\u53f3\u5230\u5de6BFS\u5148append right child, \u518dappend left child.</li> </ul> <p>\u8fd9\u9898\u6c42\u7684\u662f\u6700\u540e\u4e00\u4e2a\u7684\u503c\uff0c\u6211\u4eec\u6709\u4e24\u79cd\u601d\u8def:</p> <ul> <li>\u5199\u5224\u65ad\u6761\u4ef6\uff0c\u5982\u679c\u662f\u6700\u540e\u4e00\u4e2a\uff0c\u5c31<code>return res</code></li> <li>\u7528integer\u50a8\u5b58\u6bcf\u4e00\u4e2anode\u7684value, \u53cd\u6b63BFS\u4e5f\u662f\u8981\u904d\u5386\u6240\u6709\u7684node\uff0c\u4e0d\u4f1a\u6709\u989d\u5916\u7684\u65f6\u95f4\u590d\u6742\u5ea6.</li> </ul> <p>\u6211\u9009\u62e9\u4e86\u7b2c\u4e8c\u79cd\u65b9\u6cd5.</p> <pre><code># Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nfrom collections import deque\nclass Solution:\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -&gt; int:\n        queue = deque([root])\n\n        res = 0\n        while queue:\n            curr = queue.popleft()\n            res = curr.val\n            if curr.right:\n                queue.append(curr.right)\n            if curr.left:\n                queue.append(curr.left)\n\n        return res\n</code></pre>","tags":["Tree","Depth-First Search","Breadth-First Search","Binary Tree"]},{"location":"leetcode/523-continuous-subarray-sum/","title":"523. Continuous Subarray Sum","text":"<p>\u4e0e974 Subarray Sums Divisible by K\u76f8\u4f3c.</p>","tags":["Prefix Sum","Array","Hash Table","Math"]},{"location":"leetcode/523-continuous-subarray-sum/#approach-1-prefix-sum-hash-table","title":"Approach 1: Prefix Sum + Hash Table","text":"","tags":["Prefix Sum","Array","Hash Table","Math"]},{"location":"leetcode/523-continuous-subarray-sum/#code-implementation","title":"Code Implementation","text":"<pre><code>from collections import defaultdict\nclass Solution:\n    def checkSubarraySum(self, nums: List[int], k: int) -&gt; bool:\n        \"\"\"\n        1. min length is 2\n        2. sum of subarray is multiple of k \n        &lt;--&gt; sum(j..i) % k == 0\n        &lt;--&gt; prefix(i) - prefix(j-1) = sum(j..i)\n        hashtable:\n        {key:value} pair as \n        key --&gt; prefix_sum%2 \n        value: min index that satisfies the condition (min j so longer subarray)\n        \"\"\"\n        hashtable = defaultdict(int)\n        # initial condition\n        # 0%k = 0,\n        hashtable[0] = -1\n        prefix_sum = 0\n        for i,num in enumerate(nums):\n            prefix_sum += num\n            target = prefix_sum%k\n            if target in hashtable:\n                if i - hashtable[target] &gt;= 2:\n                    return True\n            else:\n                # haven't seen this prefix_sum % k before\n                hashtable[target] = i        \n        return False\n</code></pre>","tags":["Prefix Sum","Array","Hash Table","Math"]},{"location":"leetcode/525-contiguous-array/","title":"525 Contiguous Array","text":"","tags":["Prefix Sum","Hash Table","Array"]},{"location":"leetcode/525-contiguous-array/#approach-1-prefix-sum-hash-table","title":"Approach 1 Prefix Sum + Hash Table","text":"<p>prefix sum + hash table\u64c5\u957f\u89e3\u51b3subarray sum == target\u7684\u95ee\u9898, \u4f46\u8fd9\u4e00\u9898\u5219\u6709\u70b9\u4e0d\u4e00\u6837, \u7ed9\u7684binary array, \u6211\u4eec\u9700\u8981\u627e\u5230\u6700\u957f\u7684subarray, \u4f7f\u5f970\u548c1\u7684\u6570\u91cf\u76f8\u7b49. \u8981\u7528\u5230\u4e00\u4e2atrick, \u628a\u6240\u6709\u76840\u8f6c\u5316\u4e3a-1\uff0c\u8fd9\u6837\u8fd9\u4e2a\u95ee\u9898\u5c31\u7b49\u4ef7\u4e8e\u627e\u5230\u6700\u957f\u7684subarray sum == 0, \u5982\u4e0b\u4f8b\u5b50</p> <p><pre><code># \u539f\u6570\u7ec4\n[0, 1, 0, 1, 0, 1]\n# \u8f6c\u5316\u540e\u7684\u6570\u7ec4\n[-1, 1, -1, 1, -1, 1]\n</code></pre> \u8fd9\u6837\u5c31\u80fd\u628a\u8fd9\u4e2a\u95ee\u9898\u8f6c\u5316\u4e3a\u6700\u957f\u7684subarray sum == 0\u7684\u95ee\u9898\u4e86, \u7136\u540e\u6211\u4eec\u9700\u8981\u7528\u5230\u4e00\u4e2a\u6982\u5ff5\u5c31\u662f\u4efb\u4f55\u4e00\u4e2asubarray\u7684sum\u90fd\u53ef\u4ee5\u7531\u5176\u5b83\u4e24\u4e2asubarray\u7684sum\u76f8\u51cf\u5f97\u5230, \u5982\u4e0b\u516c\u5f0f</p> <p><pre><code>sum[j:i] =&gt; prefix_sum[i] - prefix_sum[j-1]\ncase 1:\n-------------------\nx x x [x x x]\n   j-1 j   i\ncase 2 (edge case):\n-------------------\n  [x x x] x x x\n-1 0 1 i\n</code></pre> \u4f46\u8fd8\u6709\u4e00\u4e2aedge case, \u5c31\u662f\u4ee50\u4e3a\u8d77\u70b9\u7684subarray, \u5e76\u6ca1\u6709j-1, \u6240\u4ee5\u6211\u4eec\u9700\u8981\u5728hash table\u91cc\u9762\u521d\u59cb\u5316\u4e00\u4e2aprefix_sum[0] = -1, \u8fd9\u6837\u5c31\u80fdcover\u8fd9\u4e2aedge case\u4e86. </p>","tags":["Prefix Sum","Hash Table","Array"]},{"location":"leetcode/525-contiguous-array/#code-implementation","title":"Code Implementation","text":"<pre><code>class Solution:\n    def findMaxLength(self, nums: List[int]) -&gt; int:\n        hashtable = dict()\n        hashtable[0] = -1\n\n        prefix_sum = 0\n        res = 0\n        for i,num in enumerate(nums):\n            if num == 1:\n                prefix_sum += 1\n            else:\n                prefix_sum -= 1\n\n            if prefix_sum in hashtable:\n                res = max(res,i - hashtable[prefix_sum])\n            else:\n                hashtable[prefix_sum] = i\n\n        return res            \n</code></pre>","tags":["Prefix Sum","Hash Table","Array"]},{"location":"leetcode/525-contiguous-array/#reference","title":"Reference","text":"<ul> <li>wisdom peak LC 525 Contiguous Array</li> </ul>","tags":["Prefix Sum","Hash Table","Array"]},{"location":"leetcode/53-maximum-subarray/","title":"Readme","text":"<p>Please refer to my obsidian notes for more details.</p>"},{"location":"leetcode/543-diameter-of-binary-tree/","title":"543 Diameter of Binary Tree","text":"","tags":["Tree","Depth-First Search","Binary Tree"]},{"location":"leetcode/543-diameter-of-binary-tree/#approach-1-dfs-recursive","title":"Approach 1 DFS recursive","text":"<pre><code># Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -&gt; int:\n        # left-most node VS right-most node\n        # recall in order traversal\n\n        diameter = 0\n\n        def dfs(node):\n            # base case\n            if not node:\n                return 0\n\n            nonlocal diameter\n\n            # recursive call to the left and right path\n            left_path = dfs(node.left)\n            right_path = dfs(node.right)\n\n            # update the diameter\n            diameter = max(diameter, left_path + right_path)\n\n            return max(left_path,right_path) + 1\n\n        dfs(root)\n        return diameter\n</code></pre>","tags":["Tree","Depth-First Search","Binary Tree"]},{"location":"leetcode/55-jump-game/","title":"55 Jump Game","text":"<p>\u53c8\u53ef\u4ee5\u8d2a\u5fc3\uff0c\u4e5f\u53ef\u4ee5dp. </p> <ul> <li>\u8d2a\u5fc3\u7684\u601d\u8def\u66f4\u52a0\u76f4\u89c2\uff0c\u4e5f\u66f4\u52a0\u5bb9\u6613\u7406\u89e3, \u4f46\u600e\u4e48\u8bc1\u660e\u5f88\u96be.</li> <li>dp\u7684\u601d\u8def\uff0c\u66f4\u52a0\u4e25\u8c28\uff0c\u4f46\u7531\u4e8edp\u4e5f\u662f\u4e00\u79cd\u679a\u4e3e, \u540c\u65f6\u8bb0\u5fc6\u4ee5\u524d\u7684\u5b50\u95ee\u9898\uff0c\u6240\u4ee5\u4f1a\u6709\u66f4\u591a\u7684\u7a7a\u95f4\u590d\u6742\u5ea6.</li> </ul>","tags":["Array","Dynamic Programming","Greedy"]},{"location":"leetcode/55-jump-game/#approach-1-greedy","title":"Approach 1 Greedy","text":"<p>\u6709\u4e00\u4e2a\u6570\u7ec4\uff0c\u91cc\u9762\u7684\u6570\u5b57\u4ee3\u8868\u4e86\u53ef\u4ee5\u8df3\u7684\u6700\u5927\u6b65\u6570\uff0c\u95ee\u662f\u5426\u80fd\u591f\u8df3\u5230\u6700\u540e\u4e00\u4e2a\u4f4d\u7f6e\uff0c<code>nums = [2,3,1,1,4]</code>, \u4e5f\u5c31\u662f\u8bf4:</p> <ul> <li>index <code>i</code>: \u8868\u8fbe\u76ee\u524d\u5728\u7684\u4f4d\u7f6eindex.</li> <li><code>nums[i]</code>: \u8868\u8fbe\u8fd9\u4e2a\u4f4d\u7f6e\u80fd\u8d70\u7684\u6700\u5927\u6b65\u6570, 1,2,...,<code>nums[i]</code></li> </ul> <p>\u6211\u4eec\u6bcf\u4e00\u6b65\u7684\u884c\u8d70\uff0c\u53ef\u4ee5\u770b\u4f5c\u4e00\u4e2a\u5b50\u95ee\u9898\u3002\u6bcf\u4e00\u4e2a\u5b50\u95ee\u9898\u7684\u6700\u4f18\u89e3\uff0c\u7528\u8d2a\u5fc3\u7684\u7b56\u7565\uff0c\u5c31\u662f\"\u6700\u6709\u6f5c\u529b\u7684\u90a3\u4e00\u6b65\", \u4f60\u53ef\u4ee5\u5b9a\u4e49\u4e3a</p> <ul> <li>\u80fd\u5230\u8fbe\u7684\u6700\u8fdc\u8ddd\u79bb: <code>step + nums[step]</code></li> <li>\u80fd\u8d70\u51fa\u7684\u6700\u5927\u4e00\u6b65: <code>(step - i) + nums[step]</code></li> </ul> <p>\u4ee5\u4e0a\u8fd9\u4e24\u79cd\u90fd\u662f\u4e00\u6837\u7684\uff0c\u800cstep\u7684\u9009\u62e9\u8303\u56f4\uff0c\u662f\u8981\u770b<code>nums[i]</code>, \u4e3a<code>[1,2,...,nums[i]]</code>.</p> <p>\u6211\u4eec\u505a\u4e00\u4e0bdry run, <code>nums = [2,3,1,1,4]</code>,</p> <pre><code>we currently at index 0, we can go max 2 steps. No point go 0 step\n- we go 1 step, we can then go max 3 steps. Potential is 4\n- we go 2 steps, we can then go max 1 steps. Potential is 3\n\nwe greedily choose 1 step, because it has the most potential.\n</code></pre>","tags":["Array","Dynamic Programming","Greedy"]},{"location":"leetcode/55-jump-game/#code-implementation","title":"Code Implementation","text":"<pre><code>class Solution:\n    def canJump(self, nums: List[int]) -&gt; bool:\n        # brute force: try out every combination\n        # (0,2) --&gt; 1 step or 2 step\n        \"\"\"(i,nums[i])\n                (0,2)\n            (1,3)   (2,1)\n                    (3,1)\n                    (4,4)\n        \"\"\"\n        # Or \u5f53\u524d\u7684\u6700\u4f18\u89e3 = index + it's value\n\n        # base case\n        n = len(nums)\n        if n == 1:\n            return True\n\n        curr = 0\n\n        while curr &lt;= n:\n            best = 0\n            best_index = curr\n            for step in range(1,nums[curr]+1):\n                new_curr = curr + step\n                if new_curr &gt;= n-1:\n                    return True\n                if new_curr + nums[new_curr] &gt; best:\n                    best = new_curr + nums[new_curr]\n                    best_index = new_curr                    \n            # if not updating, it means, \n            if best == 0:\n                return False\n\n            # move curr pointer by that much\n            curr = best_index\n</code></pre>","tags":["Array","Dynamic Programming","Greedy"]},{"location":"leetcode/55-jump-game/#approach-2-dp","title":"Approach 2 DP","text":"<p>complexity</p> <ul> <li>time: O(n^k) where n is the length of the array and k is \u6700\u5927\u503c\u57df.</li> <li>space: O(n)</li> </ul> <pre><code>class Solution:\n    def canJump(self, nums: List[int]) -&gt; bool:\n        \"\"\"\n        \u5012\u7740\u6765\u8d70\u4e00\u904d\uff0c\n        dp[i]: \u80fd\u5426\u4eceindex i \u8df3\u5230\u7ec8\u70b9index n-1\n        \u521d\u59cb\u6761\u4ef6:\n        dp[n-1] = 1\n        state transition function:\n\n        \"\"\"\n        n = len(nums)\n        # initialize \n        dp = [False] * n\n        dp[n - 1] = True\n\n        for idx in range(n - 2, -1, -1):\n            if nums[idx] == 0:\n                # \u8fd9\u4e00\u6b65\u7684\u6570\u503c\u4e3a0\uff0c\u6ca1\u6cd5\u8d70\u4e86\n                dp[idx] = False\n                continue\n\n            # \u5f53\u524dindex\u80fd\u8d70\u7684\u6700\u8fdc\u8ddd\u79bb\n            reach = idx + nums[idx]\n            for jump in range(idx + 1, reach + 1):\n                # \u6ca1\u8df3\u51fa\u754c\uff0c\u6216\u8005\u8df3\u5230\u7684\u8fd9\u4e00\u6b65(jump)\u4e3aTrue.\n                # jump --&gt; destination, \u800cidx --&gt; jump, \u90a3\u6211\u4eec\u5c31\u53ef\u4ee5\u5230\u7ec8\u70b9from idx\n                if jump &lt; len(nums) and dp[jump]:\n                    dp[idx] = True\n                    break\n\n        return dp[0]\n</code></pre>","tags":["Array","Dynamic Programming","Greedy"]},{"location":"leetcode/55-jump-game/#reference","title":"Reference","text":"<ul> <li>striver approach to this in an interview.</li> </ul>","tags":["Array","Dynamic Programming","Greedy"]},{"location":"leetcode/56-merge-intervals/","title":"56 Merge Intervals","text":"","tags":["Array","Sorting"]},{"location":"leetcode/56-merge-intervals/#approach-1-sorting","title":"Approach 1 Sorting","text":"<p>\\(O(nlogn)\\) in time, O(n) in space.</p> <pre><code>class Solution:\n    def merge(self, intervals: List[List[int]]) -&gt; List[List[int]]:\n        intervals.sort(key = lambda x:x[0])\n\n        res = [intervals[0]]\n        for i in range(1,len(intervals)):\n            curr_start,curr_end = intervals[i]\n            prev_start,prev_end = res[-1]\n            if curr_start &lt;= prev_end:\n                candidate = [prev_start,max(prev_end,curr_end)]\n                res.pop()\n                res.append(candidate)\n            else:\n                res.append(intervals[i])\n\n        return res\n</code></pre>","tags":["Array","Sorting"]},{"location":"leetcode/560-subarray-sum-equals-k/","title":"560. Subarray Sum Equals K","text":"<p>\u8fd9\u9898\u51e0\u4e2a\u601d\u8def:</p> <ul> <li>brute force O(n^3). O(n^2) for traversing all subarraies, O(n) for sum</li> <li>preprocessing prefix sum O(n) and traversal all subarraies O(n^2).</li> <li>\u5229\u7528two sum\u7684\u601d\u60f3\uff0chashtable + prefix sum O(n) for time and space. \u6700\u4f18\u89e3.</li> </ul>","tags":["Array","Hash Table","Prefix Sum"]},{"location":"leetcode/560-subarray-sum-equals-k/#approach-1-prefix-sum-hash-table","title":"Approach 1: Prefix Sum + Hash Table","text":"<p>Hash + prefix sum\u89e3\u6cd5\uff0c\u601d\u8def\u6709\u70b9\u50cftwo sum, \u7531\u4e8e\u662f\u6c42\u4e24\u8005\u4e4b\u548c\u7b49\u4e8etarget\u7684\u9898\u76ee\uff0c\u8fd9\u4e00\u9898\u6709\u610f\u601d\u7684\u662fprefix sum\u7684\u89e3\u6cd5, \u601d\u8def\u662f\u8fd9\u6837\u7684\uff0c\u5982\u679c\u4f60\u8ba1\u7b97accumulative sum, \u4f60\u53ef\u4ee5\u8fd9\u6837\u505a, </p> <p></p> <p>pre-fix sum\u57fa\u4e8e\u7684\u7406\u8bba\u662f:</p> <ul> <li>\u4efb\u4f55\u4e00\u4e2asub-array, \u90fd\u53ef\u4ee5\u7531two sub-array\u7684\u5dee\u503c\u6765\u6784\u5efa\u51fa\u6765.</li> </ul> <p>\u8fed\u4ee3\u5230\u5728\u4efb\u4f55\u4e00\u4e2a\u65f6\u95f4\u70b9<code>i</code>\u7684prefixSum\u7684\u503c\uff0c\u5728\u5220\u53bb\u4e00\u4e9b\u524d\u7f00array\u4e4b\u540e\uff0c\u80fd\u7ec4\u5408\u6210\u4efb\u4f55\u4e00\u4e2a\u4ee5<code>nums[i]</code> \u4e3a\u7ed3\u5c3e\u7684subarray, \u8fd9\u6837\u4f60\u53ea\u8981iterate one pass, \u5c31\u80fd\u8003\u8651\u5230\u6240\u6709subarray\u7684\u60c5\u51b5;</p> <p>\u5176\u5b9e\u5f88\u50cf\u6570\u8f74\u6807\u6839\u7a7f\u9488\u5f15\u7ebf\u6cd5\u7684\u601d\u8def\uff0c\u5f53\u4f60\u524d\u9762\u6ee1\u8db3\u4e86x\u4e2aparticular sum\u7b49\u4e8e\u67d0\u4e2a\u6570\u7684\u65f6\u5019\uff0c\u5c31\u76f8\u5f53\u4e8e\u591a\u4e86x\u79cd\u53ef\u80fd\u6027.</p> <p></p> <pre><code>from collections import defaultdict\nclass Solution:\n    def subarraySum(self, nums: List[int], k: int) -&gt; int:\n        \"\"\"\n        x x x [x x x x]\n               j     i\n        sum[j..i] = prefix[i] - prefix[j-1]\n        \"\"\"\n        hashtable = defaultdict(int)\n        hashtable[0] = 1\n\n        total = 0\n        prefix = 0\n        for i,num in enumerate(nums):\n            prefix += num\n            target = prefix - k\n            if target in hashtable:\n                total += hashtable[target]\n            # add the current prefix frequency by 1            \n            hashtable[prefix] += 1\n\n        return total\n</code></pre> <p>\u8fd9\u9898\u601d\u8def\u7684\u8fdb\u96362D\u7248\u662f1074 Number of Submatrices That Sum to Target</p>","tags":["Array","Hash Table","Prefix Sum"]},{"location":"leetcode/57-insert-interval/","title":"57 Insert Interval","text":"<p>\u533a\u95f4\u578b\u9898\u76ee\uff0c\u9700\u8981\u8003\u8651\u7684\u662f\u5982\u4f55\u5408\u5e76\u533a\u95f4\u3002\u8fd9\u9053\u7406\u7ed9\u7684<code>intervals</code>\u5df2\u7ecfsort by starting time\u4e86, \u8fd9\u9053\u9898\u76ee\u7684\u601d\u8def\u662f\u5728\u4fdd\u6301<code>intervals</code> \u8fd8\u662fsorted\u7684\u6027\u8d28\u4e0b\uff0c\u63d2\u5165<code>newInterval</code>\uff0c\u7136\u540emerge. \u6700\u4f18\u89e3\u662fO(n)\u7684\u65f6\u95f4\u590d\u6742\u5ea6.</p>","tags":["Array"]},{"location":"leetcode/57-insert-interval/#approach-1-sorting","title":"Approach 1 Sorting","text":"<p>\u61d2\u5f97\u60f3\u600e\u4e48insert, \u76f4\u63a5\u66b4\u529bsort. \u7136\u540emerge intervals.</p> <p>Time/Space Complexity</p> <p>Time Complexity: O(nlogn), for sorting Space Complexity: O(1), not counting the output space.</p> <pre><code>class Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -&gt; List[List[int]]:\n        # non-overlapping\n        # 1. append it then re-sort based on starting (Onlogn) --&gt; switch to insert later O(n)\n        # 2. \n\n        # sort by start time\n        intervals.append(newInterval)\n        intervals.sort(key=lambda x: x[0])\n\n        res = [intervals[0]]\n\n        for i in range(1,len(intervals)):\n            curr_start,curr_end = intervals[i]\n            prev_start,prev_end = res[-1]\n            if curr_start &gt;= prev_start and curr_start &lt;= prev_end:\n                # if mergable\n                res.pop()\n                candidate = [prev_start,max(prev_end,curr_end)]\n                res.append(candidate)\n            else:\n                res.append([curr_start,curr_end])\n\n        return res\n</code></pre>","tags":["Array"]},{"location":"leetcode/57-insert-interval/#approach-2-insert-and-merge","title":"Approach 2 Insert and Merge","text":"<p>Find the insertion point for newInterval, then insert it. The insertion point will be set such that the array is still sorted in terms of start time. Then do a one pass solution to merge the intervals.</p> <p>Time/Space Complexity</p> <p>Time Complexity: O(n) Space Complexity: O(1), not counting the output space.</p> <pre><code>class Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -&gt; List[List[int]]:\n        # non-overlapping\n        # 1. append it then re-sort based on starting (Onlogn) --&gt; switch to insert later O(n)\n        # 2. merge potential overlapping\n\n        # linear scan and insert newInterval mainthing the monotonic increasing for intervals.\n        n = len(intervals)\n        i = 0\n        while i &lt; n and intervals[i][0] &lt; newInterval[0]: \n            i += 1\n\n        # now, i will be where we insert\n        intervals.insert(i,newInterval)\n\n        # O(n) linear scan\n        res = [intervals[0]]\n        for i in range(1,len(intervals)):\n            curr_start,curr_end = intervals[i]\n            prev_start,prev_end = res[-1]\n            if curr_start &gt;= prev_start and curr_start &lt;= prev_end:\n                # if mergable\n                res.pop()\n                candidate = [prev_start,max(prev_end,curr_end)]\n                res.append(candidate)\n            else:\n                res.append([curr_start,curr_end])\n\n        return res\n</code></pre>","tags":["Array"]},{"location":"leetcode/576-out-of-boundary-paths/","title":"576 out of boundary paths","text":"<p>Table of contents: - Intuition - Approach   - DP Definition     - Definition of DP     - Initial Condition     - State transition function   - Points Calculation - Complexity - Code</p>"},{"location":"leetcode/576-out-of-boundary-paths/#intuition","title":"Intuition","text":"<p>My intuition is that it is a 2D DP problem and use an auxillary 2D array to store information. Since this question is asking for the total number of paths with a constraint on the number of moves, we need to sum up all the solution for (1,2,3,...,maxMove) moves.</p> <p>We can decompose the problem to,  - number of ways to go out of boundary with <code>1</code> move allowed - number of ways to go out of boundary with <code>2</code> moves allowed - number of ways to go out of boundary with <code>3</code> moves allowed - ... - number of ways to go out of boundary with <code>maxMove</code> moves allowed</p> <p>If a football goes out of boundary with 2 moves, then it needs to be at the boundary of the grid with 1 move. Therefore, we can transfer this question into, - Given after a total of <code>0</code> moves, the ball is at boundary. Calculate the total number of ways to go out of bound after 1 more move. - Given after a total of <code>1</code> moves, the ball is at boundary. Calculate the total number of ways to go out of bound after 1 more move. - ... - Given after a total of <code>maxMove - 1</code> moves, the ball is at boundary. Calculate the total number of ways to go out of bound after 1 more move.</p> <p>After decompose the problem into its subproblem and rephrase each sub-problem, we need to - construct a DP definition that figure out number of ways to reach boundary nodes - figure out a way to determine what's boundary nodes and interior nodes effectively. </p>"},{"location":"leetcode/576-out-of-boundary-paths/#approach","title":"Approach","text":""},{"location":"leetcode/576-out-of-boundary-paths/#dp-definition","title":"DP Definition","text":"<p>For DP problem, we need to the following three - definition of DP - initial condition - state transition function</p>"},{"location":"leetcode/576-out-of-boundary-paths/#definition-of-dp","title":"Definition of DP","text":"<p>As stated previously, in order to determine number of ways to reach boundary nodes, we can generalize it to include interior nodes as well (for whole grid). </p> <p><code>DP[i][j]</code> is defined as the number of ways to reach position <code>(i,j)</code> with exactly <code>x</code> moves, where <code>x &lt;= maxMove</code>.</p>"},{"location":"leetcode/576-out-of-boundary-paths/#initial-condition","title":"Initial Condition","text":"<p>Initial condition is <code>DP[startRow][startColumn] = 1</code> and rest of the DP array is zero, since we start at this position with 0 moves allowed.</p> <p></p>"},{"location":"leetcode/576-out-of-boundary-paths/#state-transition-function","title":"State transition function","text":"<p>State transition function is defined as,  $$ \\begin{align} DP[i][j][t] = DP[i-1][j][t-1] \\+ DP[i][j-1][t-1] \\+ DP[i+1][j][t-1] \\+ DP[i][j+1][t-1] \\end{align} $$ where \\(t\\) the number of moves allowed, <code>DP[i][j][t]</code> is the number of ways to reach position <code>(i,j)</code> with exactly <code>t</code> moves.</p> <p>We derive this transition function based on,  - update of DP is completely dependent on the information of the previous step. DP[i][j][t] is completely dependent on DP[i][j][t-1]. - information is updated based on the four directions, up, down, left, right.</p> <p>Now, if we look at the example provided, <pre><code>Input: m = 2, n = 2, maxMove = 2, startRow = 0, startColumn = 0\nOutput: 6\n</code></pre></p> <p>We can draw the following diagram, </p> <p></p> <p>The question is asking for the total number of paths to go out of boundary. We can use the information stored in DP[i][j][t] to calculate the number of paths to go out of boundary. For example, if we have <code>maxMove = 10</code>, then we can use <code>DP[i][j][1]</code> to <code>DP[i][j][9]</code> to calculate the total number of paths to go out of boundary. </p> <p>Moving 0 times won't got out of boundary, so we start from 1. We only allow 9 moves, since we have 10 moves in total. So the last move would be \"out of bound move\".</p> <p>Since the next time step is only dependent on the previous time step, we only need to use two DP arrays to store the information. One is for the current time step, the other is for the previous time step. </p>"},{"location":"leetcode/576-out-of-boundary-paths/#points-calculation","title":"Points Calculation","text":"<p>As for relating DP with the number of paths to go out of boundary, we need to think of a way to calculate points.</p> <p>How to calculate the number of ways to reach out of boundary node. You can think of all nodes consist of inner node, edge node and corner node. - inner node: 0 ways to reach out of boundary - edge node: 1 way to reach out of boundary - corner node: 2 ways to reach out of boundary</p> <p>However, the inner, edge and corner is only valid for grid size <code>m &gt; 1</code> and <code>n &gt; 1</code>. As for <code>m = 1</code> or <code>n = 1</code>, we need to consider the edge cases,</p> <p></p> <p>We can use the following mechanism to calculate the \"points\" by which we can reach out of boundary node.</p> <pre><code>points = 0\nif i+1 &gt;= m: points += 1\nif i-1 &lt; 0: points += 1\nif j-1 &lt; 0: points += 1\nif j+1 &gt;= n: points += 1\n</code></pre> <p>Finlay, we can calculate the total number of paths to go out of boundary by summing up all the points for each node for allowing move = 1, 2, 3, ..., maxMove -1 as shown in the following diagram.</p> <p></p>"},{"location":"leetcode/576-out-of-boundary-paths/#complexity","title":"Complexity","text":"<ul> <li> <p>Time complexity: \\(O(m*n*maxMove)\\)</p> </li> <li> <p>Space complexity: \\(O(m*n)\\)</p> </li> </ul>"},{"location":"leetcode/576-out-of-boundary-paths/#code","title":"Code","text":"<pre><code>from collections import defaultdict\nclass Solution:\n    def findPaths(self, m: int, n: int, maxMove: int, startRow: int, startColumn: int) -&gt; int:        \n        # initialization\n        DP = defaultdict(lambda: 0)        \n        DP_last = defaultdict(lambda: 0)\n\n        DP[(startRow,startColumn)] = 1\n        DP_last[(startRow,startColumn)] = 1\n\n        res = 0\n        for t in range(maxMove):\n            for i in range(m):\n                for j in range(n):\n                    # max points to get is four when m = 1, n = 1, starting at (0,0)\n                    points = 0\n                    if i+1 &gt;= m: points += 1\n                    if i-1 &lt; 0: points += 1\n                    if j-1 &lt; 0: points += 1\n                    if j+1 &gt;= n: points += 1\n                    res += DP[(i,j)] * points\n\n                    # update DP at t based on t-1\n                    DP[(i,j)] = DP_last[(i-1,j)] + DP_last[(i,j-1)] + DP_last[(i+1,j)] + DP_last[(i,j+1)]\n\n            # update DP_last with DP\n            DP_last = DP.copy()\n\n        return res % (10**9 + 7)\n</code></pre>"},{"location":"leetcode/577-reverse-words-in-a-string-III/","title":"Approach1: \u778e\u5199\u7684","text":"<p>\u81ea\u5df1\u5199\u7684\uff0c\u633a\u51cc\u4e71\u7684\uff0c\u8fd9\u91cc\u8981\u6ce8\u610f\u4ee5\u4e0b\u51e0\u70b9:</p> <ul> <li><code>python</code>\u4e0d\u652f\u6301string assignment, \u6240\u4ee5\u7528two pointer method\u505astring in-place swap\u4e0d\u884c\uff0c\u8fd8\u662f\u53ea\u80fdappend\u5230list\u4e2d</li> </ul> <p>\u8fd9\u4e00\u9898\u8fd8\u662f\u8981\u4ee5\u540e\u7528\u522b\u7684\u8bed\u8a00\u5199\u4e00\u904d\uff0c\u624d\u80fd\u66f4\u7406\u89e3\u5427.</p>"},{"location":"leetcode/577-reverse-words-in-a-string-III/#complexity","title":"Complexity","text":"<ul> <li>Time complexity:</li> </ul> <ul> <li>Space complexity:</li> </ul>"},{"location":"leetcode/577-reverse-words-in-a-string-III/#code","title":"Code","text":"<pre><code>class Solution:\n    def reverseWords(self, s: str) -&gt; str:\n\n\n        whitespace_counter = 0\n\n        # traverse and count # of space, O(n)\n        for char in s:\n            if char == \" \":\n                whitespace_counter += 1\n\n\n        # space complexity, O(n)\n        res = []\n\n        head = 0\n        tail = head\n\n\n        for i in range(whitespace_counter+1):\n            while tail != len(s) -1 and s[tail+1] != \" \" :\n                tail += 1\n\n            temp = tail\n            # tail the end index of the word     \n\n            while tail &gt;= head:\n                res.append(s[tail])\n                tail -= 1       \n\n\n            if i == whitespace_counter:\n                break\n            else:\n                res.append(\" \")\n                tail = temp + 2\n                head = tail\n\n        return \"\".join(res)\n</code></pre>"},{"location":"leetcode/58-length-of-last-word/","title":"58 Length of Last Word","text":"<p>This question is kinda tricky, and i will introduce three solution </p> <ul> <li>split and then get the last word, \\(O(n)\\) in time, \\(O(n)\\) in space</li> <li>two pass solution \\(O(n)\\) in time, \\(O(1)\\) in space</li> <li>one pass solution \\(O(n)\\) in time, \\(O(1)\\) in space</li> </ul>","tags":["String"]},{"location":"leetcode/58-length-of-last-word/#approach-1-naive-solution","title":"Approach 1: Naive Solution","text":"<p>This is the solution came to my mind when i saw it. \\(O(n)\\) in time, \\(O(n)\\) in space.</p> <pre><code>class Solution:\n    def lengthOfLastWord(self, s: str) -&gt; int:\n        words = s.strip().split()\n        return len(words[-1])\n</code></pre>","tags":["String"]},{"location":"leetcode/58-length-of-last-word/#approach-2-two-pass-solution","title":"Approach 2: two pass solution","text":"<p>We realize that there are some trailing zeros that we need to handle and it is giving us some troubles. Our two passes are:</p> <ul> <li><code>1st pass</code>: First \"trim\" the trailing white space by decrementing <code>tail</code> pointer. </li> <li><code>2nd pass</code>: Then we calculate the length of the last word by incrementing <code>res</code>.</li> </ul> <p>This solution is \\(O(n)\\) in time and \\(O(1)\\) in space.</p> <pre><code>class Solution:\n    def lengthOfLastWord(self, s: str) -&gt; int:\n        # two-pass, 1 for triming right white space, 2nd for computing length\n        # 1st pass: \"trim\" right white space\n        tail = len(s) - 1\n        while tail &gt;= 0 and s[tail] == \" \":\n            tail -= 1\n\n        # 2nd pass: calculate length of last world\n        res = 0\n        while tail &gt;= 0 and s[tail] != \" \":\n            res += 1\n            tail -= 1\n        return res\n</code></pre>","tags":["String"]},{"location":"leetcode/58-length-of-last-word/#approach-3-one-pass-solution","title":"Approach 3: one pass solution","text":"<p>After you understand the two pass solution, you will realize that it must exist a one pass solution. The obstacle is that we need to handle the trailing white space and the white space between last word and 2nd last word. As illustrated in the figure below,</p> <p></p> <p>The trick is that, we need to calculate length anyways. so we have two variables:</p> <ul> <li><code>res</code> to store the length of last word</li> <li><code>tail</code> to store the current index we traversing from end of the string</li> </ul> <p>When we are in first white space (trailing white space), </p> <ul> <li><code>res == 0</code> is always true</li> <li><code>tail</code> is just decrementing until we reach the end of last word i.e. <code>s[tail] != \" \"</code></li> <li><code>s[tail] == \" \"</code> is always true</li> </ul> <p>While we are in the 2nd white space, (white space between last word and 2nd last word)</p> <ul> <li><code>res != 0</code> is always true</li> <li><code>tail</code> is just decrementing until we reach the end of 2nd last word i.e. <code>s[tail] != \" \"</code></li> <li><code>s[tail] == \" \"</code> is always true</li> </ul> <p>Therefore, we can see that the only difference is the <code>res</code> between the two white spaces. So we can just use <code>res</code> as the escape condition for distinguishing the two white spaces.</p> <pre><code>class Solution:\n    def lengthOfLastWord(self, s: str) -&gt; int:\n        # one pass solution, calculat none \" \" white space\n        tail = len(s) - 1\n        res = 0\n\n        while tail &gt;= 0:\n            if s[tail] != ' ':\n                res += 1\n            elif res &gt; 0:\n                return res            \n            tail -= 1\n\n        return res\n</code></pre>","tags":["String"]},{"location":"leetcode/59-group-anagrams/","title":"59 Group Anagrams","text":""},{"location":"leetcode/6-zigzag-conversion/","title":"6 ZigZag Conversion","text":"<p>\u8fd9\u9898\u53ea\u80fd\u7b97\u8111\u7b4b\u6025\u8f6c\u5f2f\uff0c\u4e0d\u600e\u4e48\u8003\u6570\u636e\u7ed3\u6784\u3002\u6211\u7684\u601d\u8def\u662f</p> <ul> <li>\u521b\u5efamatrix</li> <li>\u8bbe\u8ba1\u4e00\u4e2aflag\uff0c\u7528\u6765\u5224\u65ad\u662f\u5411\u4e0a\u8fd8\u662f\u5411\u4e0b, \u89e6\u5e95\u53cd\u5f39\u548c\u89e6\u9876\u53cd\u5f39</li> <li>\u628a\u503c\u586b\u8fdbmatrix</li> <li>\u6700\u540e\u628amatrix\u8f6c\u6362\u6210string</li> </ul> <p>\u6211\u53ea\u8fc7\u4e86\u5c11\u6570test case, \u5176\u5b83\u6709index error, \u8bf4\u660e\u5728\u8fb9\u754c\u5904\u7406\u4e0a\u4e0d\u5e72\u51c0. \u9664\u6b64\u4e4b\u5916\u8fd8\u6709\u51e0\u4e2a\u7f3a\u9677:</p> <ul> <li>matrix\u7684\u5927\u5c0f\u4e0d\u597d\u786e\u5b9a, \u4e14\u6700\u540eflatten\u6bd4\u8f83expensive</li> </ul>","tags":["String"]},{"location":"leetcode/6-zigzag-conversion/#approach-1","title":"Approach 1","text":"<p>\u628a\u6bcf\u4e00\u884c\u6d53\u7f29\u6210\u4e00\u4e2astring,</p> <pre><code>s = \"paypalishiring\"\nrows = [\n    \"pahn\",\n    \"aplsiig\",\n    \"yir\"\n]\n</code></pre> <p>\u8bbe\u8ba1\u4e00\u4e2a<code>upward</code> flag, \u7528\u6765\u5224\u65ad\u662f\u5411\u4e0a\u8fd8\u662f\u5411\u4e0b, \u89e6\u5e95\u53cd\u5f39\u548c\u89e6\u9876\u53cd\u5f39</p> <pre><code>class Solution:\n    def convert(self, s: str, numRows: int) -&gt; str:\n        # construct a 2D array\n        # convert the array to a string\n        # worst case\n        if numRows == 1:\n            return s\n\n        # \u628a\u6bcf\u4e00\u884c\u6d53\u7f29\u6210\u4e00\u4e2astring\u4e86\n        rows = [\"\"] * numRows\n        upward = True\n        curr_row = 0\n\n        for char in s:\n            rows[curr_row] += char\n            # switch direction\n            if curr_row == 0 or curr_row == numRows - 1:\n                backward = not backward\n\n            if backward:\n                curr_row -= 1\n            else:\n                curr_row += 1\n        return \"\".join(rows)\n</code></pre>","tags":["String"]},{"location":"leetcode/61-rotate-list/","title":"Problem","text":"<p>Given the <code>head</code> of a linked list, rotate the list to the right by <code>k</code> places.</p> <p>Example1</p> <p> <pre><code>Input: head = [1,2,3,4,5], k = 2\nOutput: [4,5,1,2,3]\n</code></pre></p> <p>Example2</p> <p> <pre><code>Input: head = [0,1,2], k = 4\nOutput: [2,0,1]\n</code></pre> Constraints:</p> <ul> <li>The number of nodes in the list is in the range <code>[0, 500]</code>.</li> <li><code>-100 &lt;= Node.val &lt;= 100</code></li> <li>0 \\(\\leq\\) k \\(\\leq\\) 2 * \\(10^9\\)</li> </ul>"},{"location":"leetcode/61-rotate-list/#solution","title":"Solution","text":"<p>\u4f60\u7684\u7b2c\u4e00\u76f4\u89c9\u5f88\u53ef\u80fd\u662fcut off tail node and \u7eed\u5728\u524d\u9762, \u4e00\u5171\u64cd\u4f5ck\u6b21\uff0c\u4f46\u6839\u636eproblem constrains, k\u7684upper limit\u6bd4linked list\u4e2dnodes\u7684\u6570\u91cf\u591a\u8fd9\u4e48\u591a\uff0c\u4f60\u5c31\u77e5\u9053\u8fd9\u5e76\u4e0d\u53ef\u80fd. </p> <p>\u5982\u679c\u94fe\u8868\u957f\u5ea6<code>n = 3</code>\uff0c\u7ed9\u5b9a\u7684\u8f93\u5165<code>k</code>, \u6bcf\u4e94\u6b21\u5c31\u4f1a\u56de\u5230starting position as illustrated in example 2 above. \u8fd9\u6837\u7684\u8bdd, \u6211\u4eec\u5b9e\u9645\u9700\u8981\u632a\u52a8\u7684\u6b21\u6570\\(k_{real}\\)\u4e3a $$ k_{real} = k\\%n $$ Instead of doing \\(k_{real}\\) times, we can just do 1 single operation, we just need to find the pattern. \u6211\u4eec\u77e5\u9053k and n, \u90a3\u53ea\u9700\u8981\u5c06\u6574\u4e2alinked list\u5206\u4e3a\u4e24\u5757\u5373\u53ef\uff0c</p> <p></p> <p>\u5177\u4f53\u64cd\u4f5c\u7684\u8bdd\uff0c\u9700\u8981\u77e5\u9053three pointers \u4ee5\u53ca\u94fe\u8868\u957f\u5ea6</p> <p>\u6211\u4eec\u901a\u8fc7first time traversal\u6765\u83b7\u5f97: - \u94fe\u8868\u957f\u5ea6 <code>n</code> - tail pointer that points to <code>tail node</code></p> <p>2nd time traversal for a fixed # of times <code>n-k</code> to find - tail of the blue chunk - head of the red chunk </p>"},{"location":"leetcode/61-rotate-list/#edge-cases","title":"Edge cases","text":"<p>\u8fd9\u4e00\u9898edge cases\u6bd4\u8f83\u591a\u7684 - head is None, \u4e0d\u7ba1k\u591a\u5927\uff0c\u90fd\u662fNone, \u6240\u4ee5<code>return head</code> - k = 0, no rotation, \u6240\u4ee5<code>return head</code>  - n%k == 0, \u65cb\u8f6c\u56de\u81ea\u8eab\uff0c\u7b49\u4e8e\u767d\u65cb\u8f6c, <code>return head</code></p>"},{"location":"leetcode/61-rotate-list/#code","title":"Code","text":"<pre><code># Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -&gt; Optional[ListNode]:\n        # range of k is fairly large, need to calculate the lenght of linked list and modulus it.\n        if k == 0 or head is None: return head\n\n\n        # n the length of linked list\n        n = 0\n        dummy = ListNode(None,head)\n        tail, curr = dummy, head\n        while curr:\n            n += 1\n            curr = curr.next\n            tail = tail.next\n\n        if k%n == 0: return head\n\n        # update k\n        k = k%n\n\n        prev,curr = dummy, head\n\n        for i in range(n - k):\n            prev = prev.next\n            curr = curr.next\n\n        prev.next = None\n        dummy.next = curr\n        tail.next = head\n\n        return dummy.next\n</code></pre>"},{"location":"leetcode/617-merge-two-binary-trees/","title":"Problem","text":"<p>You are given two binary trees <code>root1</code> and <code>root2</code>.</p> <p>Imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge the two trees into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of the new tree.</p> <p>Return the merged tree.</p> <p>Note: The merging process must start from the root nodes of both trees.</p> <p>Example: please see the diagram below</p> <p></p>"},{"location":"leetcode/617-merge-two-binary-trees/#solution","title":"Solution","text":"<p>The key for this problem is to: - take <code>left tree</code> as a basis and add <code>right tree</code>'s stuff to it - traverse the left tree as always.</p> <p></p>"},{"location":"leetcode/62-unique-paths/","title":"62 Unique Paths","text":"","tags":["Dynamic Programming","Math","Combinatorics"]},{"location":"leetcode/62-unique-paths/#approach-1-dp","title":"Approach 1: DP","text":"<p>Note</p> <p>time complexity: O(mn) space complexity: O(mn)</p>","tags":["Dynamic Programming","Math","Combinatorics"]},{"location":"leetcode/62-unique-paths/#dp","title":"DP\u4e09\u5b9d","text":"","tags":["Dynamic Programming","Math","Combinatorics"]},{"location":"leetcode/62-unique-paths/#dp_1","title":"DP\u5b9a\u4e49","text":"<p><code>dp[i][j]</code>\uff1a\u8868\u793a\u4ece\u8d77\u70b9<code>(0,0)</code>\u5230\u8fbe<code>(i,j)</code>\u6240\u6709\u8def\u5f84\u6570.</p>","tags":["Dynamic Programming","Math","Combinatorics"]},{"location":"leetcode/62-unique-paths/#dp_2","title":"DP\u521d\u59cb\u5316","text":"<p>\u8d77\u70b9<code>dp[0][0]</code>\u5fc5\u7136\u662f1, \u56e0\u4e3a\u53ea\u6709\u4e00\u79cd\u53ef\u80fd\u6027. \u5fc5\u7136\u662f\u7531\u4e8e\u53ea\u80fd\u5f80\u53f3\u6216\u8005\u5f80\u4e0b\u8d70\uff0c\u6240\u4ee5\u7b2c\u4e00\u884c\u7b2c\u4e00\u5217\u90fd\u662f1. </p> \\[ \\begin{equation} dp[i][j] = \\begin{cases}     1, &amp; \\text{if } i=0 \\text{ or } j=0\\\\     0, &amp; \\text{otherwise} \\end{cases} \\end{equation} \\]","tags":["Dynamic Programming","Math","Combinatorics"]},{"location":"leetcode/62-unique-paths/#dp_3","title":"DP\u72b6\u6001\u8f6c\u79fb","text":"<p>Since the robot can only move right and down, your matrix will be updated from top or left.</p> \\[ \\begin{equation} dp[i][j] = \\begin{cases}     dp[i-1][j] + dp[i][j-1], &amp; \\text{if } i&gt;0 \\text{ and } j&gt;0\\\\     1, &amp; \\text{if } i=0 \\text{ or } j=0 \\end{cases} \\end{equation} \\]","tags":["Dynamic Programming","Math","Combinatorics"]},{"location":"leetcode/62-unique-paths/#code-implementation","title":"Code Implementation","text":"<p>Tip</p> <p>\u8fd9\u91cc\u7528\u4e86<code>defaultdict</code>\u6765\u521d\u59cb\u5316<code>dp</code>\uff0cinstead of array, \u8fd9\u6837\u53ef\u4ee5\u907f\u514d\u5904\u7406boundary\u7684\u95ee\u9898\uff0c\u8d85\u8fc7\u8fb9\u754c\u76f4\u63a5\u9ed8\u8ba4\u4e3a0\u4e86.</p> <p><pre><code>from collections import defaultdict\nclass Solution:\n    def uniquePaths(self, m: int, n: int) -&gt; int:\n        # dp[(i,j)]: number of possible ways to reach to the grid[m][n]\n        # initial condition\n        # dp[(i,0)] = 1, dp[(0,j)] = 1\n        # state transition function:\n        #   dp[(i,j)] = dp[(i-1,j)] + dp[(i,j-1)]\n\n        dp = defaultdict(int)\n        for i in range(m):\n            dp[(i,0)] = 1\n\n        for i in range(m):\n            for j in range(1,n):\n                dp[(i,j)] = dp[(i-1,j)] + dp[(i,j-1)]\n\n        return dp[(m-1,n-1)]\n</code></pre> \u4f60\u751a\u81f3\u53ef\u4ee5\u7701\u7565\u521d\u59cb\u5316\u90a3\u4e00\u6b65\uff0c\u56e0\u4e3a\u6211\u4eec\u7684\u4fe1\u606f\u90fd\u662f\u4ece\u5de6\u4e0a\u89d2\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u53ea\u8981\u4ece\u5de6\u4e0a\u89d2\u5f00\u59cbhorizontal\u6216\u8005vertical\u7684\u904d\u5386\u5c31\u53ef\u4ee5\u4e86.</p> <pre><code>class Solution:\n    def uniquePaths(self, m: int, n: int) -&gt; int:\n        dp = [[0 for _ in range(n)] for _ in range(m)]\n\n        for i in range(m):\n            for j in range(n):\n                if i == 0 or j == 0:\n                    dp[i][j] = 1\n                else:\n                    dp[i][j] = dp[i-1][j] + dp[i][j-1]\n\n        return dp[m-1][n-1]\n</code></pre>","tags":["Dynamic Programming","Math","Combinatorics"]},{"location":"leetcode/62-unique-paths/#approach-2-dp-space-optimized","title":"Approach 2: DP, space optimized","text":"<p>\u53d1\u73b0\u4e0a\u9762\u7684DP\u5176\u5b9e\u53ea\u7528\u5230\u4e86\u4e0a\u4e00\u884c\u7684\u4fe1\u606f\uff0c\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u4f18\u5316\u7a7a\u95f4\u590d\u6742\u5ea6, reduce to \\(O(m)\\) or \\(O(n)\\), \u6839\u636e\u4f60\u9009\u62e9\u7684horizontal scan or vertical scan.</p> <p>Note</p> <p>time complexity: O(m*n) space complexity: O(n)</p>","tags":["Dynamic Programming","Math","Combinatorics"]},{"location":"leetcode/62-unique-paths/#code-implementation_1","title":"Code Implementation","text":"<pre><code>from collections import defaultdict\nclass Solution:\n    def uniquePaths(self, m: int, n: int) -&gt; int:\n        if n == 1: return 1\n\n        prev = [1 for _ in range(m)]\n        curr = [0 for _ in range(m)]\n\n        for j in range(1,n):\n            for i in range(m):\n                # update curr\n                if i == 0:\n                    curr[i] = prev[i]\n                else:\n                    curr[i] = prev[i] + curr[i-1]\n\n            prev = curr.copy()\n\n        return curr[-1]\n</code></pre>","tags":["Dynamic Programming","Math","Combinatorics"]},{"location":"leetcode/621-task-scheduler/","title":"621 Task Scheduler","text":"","tags":["Array","Hash Table","Heap (Priority Queue)","Greedy","Sorting","Counting"]},{"location":"leetcode/621-task-scheduler/#approach-1-max-heap-hashmap","title":"Approach 1: max heap + hashmap","text":"<p>Warning</p> <p>max heap + hashmap\u7684\u6548\u679c: \u6309\u9891\u7387\u51fa\u73b0\u7684distinct elements. </p> <p>What does the optimal solution gonna look like? The strategy will be to minimize the number of neighbors of same tasks. Let's say for <code>m</code> tasks, you have <code>m-1</code> neighbors.</p> <p></p> <p>The reason why this strategy is more optimal is that we have the penalty of <code>n</code> idle time for same task. It's a workaround to minimize the likelihood of getting penalized by it.</p> <p>For examples, <code>tasks = ['A','B','A','C','D','B',]</code> will be rearranged into <code>[A,B,C,D,A,B]</code> to make As and Bs as far as possible. The pattern is that during one cycle (at most 26 alphabets), we will list the most frequent tasks first, and then the rest of the tasks. In the next cycle, we do the same thing. So in summary,</p> <ul> <li>In first cycle, we list out the most frequent and distinct tasks first</li> <li>In second cycle, we list out the most frequent and distinct tasks first</li> <li>...</li> </ul> <p>How to make sure that we can list <code>distinct</code> and <code>more frequent</code> values? We can use a hashmap and a max heap to make sure that happens.</p> <ul> <li>initialize a hashmap as a counter for the tasks</li> <li>initialize a <code>max heap</code> to store the tasks in descending order of frequency  <pre><code>    (4,'A')\n(3,'B') (1,'C') \n</code></pre></li> <li>maintain <code>time</code> for the total time taken to finish the tasks</li> <li>while the max heap is not empty, we do the following:<ul> <li>initialize a <code>cycle = n+1</code> (n is the cooldown time)</li> <li>initialize and maintain a <code>remaining</code> list to store the tasks with &gt;= 2 frequencies in heap. It means we gonna need to do them again in next cycle</li> <li>while <code>cycle</code> has time left and the max heap is not empty, we do the following:<ul> <li>pop the most frequent task from the max heap, and decrement the frequency by 1</li> <li>if that task is still not done, we add it to the remaining tasks</li> <li>we increment the <code>time</code> by 1</li> <li>decrement the <code>cycle</code> by 1</li> </ul> </li> <li>we shovel the remaining tasks back into the <code>max heap</code>. If there is nothing left in the heap, we break the loop</li> <li>add the <code>idle</code> time into the <code>time</code> count. That means <code>n &gt; len(max_heap)</code>, </li> </ul> </li> </ul>","tags":["Array","Hash Table","Heap (Priority Queue)","Greedy","Sorting","Counting"]},{"location":"leetcode/621-task-scheduler/#code-implementation","title":"Code Implementation","text":"<pre><code>from collections import Counter\nfrom heapq import heappush,heappop\nclass Solution:\n    def leastInterval(self, tasks: List[str], n: int) -&gt; int:\n        # 1. \u6700\u4f18\u89e3\u4f1a\u662f\u4ec0\u4e48\u6837\u7684\uff1f\u4e5f\u5c31\u662f\u4e24\u5143\u7d20\u76f8\u90bb\u7684\u8d8a\u5c11\u5373\u53ef\u3002for m\u4e2a\u4efb\u52a1\uff0c\u6709m-1\u4e2a\u76f8\u90bb\u70b9.\n        # 2. \u6709\u53ef\u80fd\u6709\u591a\u4e2a\u6700\u4f18\u89e3;\n        # hashmap + max heap: \u4fdd\u8bc1\u8ba9distinct\u7684\u6700\u591a\u7684\u51fa\u6765\n\n        counter = Counter(tasks)\n\n        priority_queue = []\n        for task,freq in counter.items():\n            heappush(priority_queue,(-freq,task))\n\n        time = 0\n        while priority_queue:\n            # do one cycle\n            cycle = n + 1\n            remaining = []\n            while cycle &gt; 0 and priority_queue:\n                max_freq, task = heappop(priority_queue)\n                max_freq *= -1\n                if max_freq &gt; 1:\n                    max_freq -= 1\n                    remaining.append((-max_freq,task))\n                time += 1\n                cycle -= 1\n            # \u585e\u56de\u53bb\n            for item in remaining:\n                heappush(priority_queue,item)\n            # \u5982\u679c\u7a7a\u4e86,\u4e5f\u4e0d\u9700\u8981idle\u4e86\n            if not priority_queue:\n                break\n\n            # add idle time into time count\n            time += cycle\n        return time\n</code></pre>","tags":["Array","Hash Table","Heap (Priority Queue)","Greedy","Sorting","Counting"]},{"location":"leetcode/622-design-circular-queue/","title":"Approach 1 with array","text":"<pre><code>class MyCircularQueue:\n    \"\"\"\n    Use array to implement \"circular \"queue. Imagine we have a full queue like \n    [1, 2, 3, 4 ,5 ]\n    and we execute two dequeue() from the top. \n    [_, _, 3, 4 ,5 ]\n    Now, we have some space near the head but we don't have space at the tail. \n    It will cause problem if we decide to enqueue(i), we will be\n    - shifting everything to fill the empty space near head of the queue (O(n))\n    - expand the fix-sized array, (create an array of size 2n, move to it, destroy the old array)\n    \"\"\"\n    def __init__(self, k: int):\n        self.queue = [0 for _ in range(k)]\n        self.count = 0\n        self.capacity = k\n        # always points to the head of the queue\n        self.head = 0\n\n    def enQueue(self, value: int) -&gt; bool:\n        \"\"\"\n        Insert an element into the circular queue from tail. Return true if the operation\n        is successful. Return false if the queue is maxed out.\n        \"\"\"\n        if self.count == self.capacity:\n            return False\n        # last available slot ready to be enqueued\n        tail_enqueue = (self.head + self.count) % self.capacity\n        self.queue[tail_enqueue] = value\n        self.count += 1\n        return True\n\n    def deQueue(self) -&gt; bool:\n        \"\"\"\n        Pop an element from the head. Return true if the operation is successful.\n        Return false if the queue is empty\n        \"\"\"\n        if self.count == 0:\n            return False\n        # remove the element at head\n        self.head = (self.head + 1) % self.capacity\n        self.count -= 1\n        return True\n\n\n    def Front(self) -&gt; int:\n        if self.count == 0:\n            return -1\n        return self.queue[self.head]\n\n\n    def Rear(self) -&gt; int:\n        if self.count == 0:\n            return -1\n        # points to last item in the queue (who just enqueued)\n        tail = (self.head + self.count - 1) % self.capacity\n        return self.queue[tail]\n\n    def isEmpty(self) -&gt; bool:\n        return self.count == 0\n\n    def isFull(self) -&gt; bool:\n        return self.count == self.capacity\n\n\n\n# Your MyCircularQueue object will be instantiated and called as such:\n# obj = MyCircularQueue(k)\n# param_1 = obj.enQueue(value)\n# param_2 = obj.deQueue()\n# param_3 = obj.Front()\n# param_4 = obj.Rear()\n# param_5 = obj.isEmpty()\n# param_6 = obj.isFull()\n</code></pre>"},{"location":"leetcode/623-add-one-row-to-tree/","title":"623 Add One Row to Tree","text":"<p>\u8fd9\u9898\u6211\u7b2c\u4e00\u53cd\u5e94\u662fBFS, AC\u540e\u53d1\u73b0\u8fd8\u6709DFS\u7684\u89e3\u6cd5. </p>","tags":["Tree","Depth-First Search","Breadth-First Search","Binary Tree"]},{"location":"leetcode/623-add-one-row-to-tree/#approach-1-bfs","title":"Approach 1 BFS","text":"<p>Intuition says that it must be BFS. The rough logic would be to </p> <ul> <li>BFS until the layer before the targeted depth <code>curr_depth = depth - 1</code></li> <li>add a new layer below the current layer</li> </ul> <p>However, there are a couple of edge cases:</p> <ul> <li>if <code>depth == 1</code>, insert a new node and make the root node it's left node</li> <li>if <code>depth == max_depth</code>, we add the new layer below the original leaf node</li> <li>otherwise, <code>curr_depth == depth - 1</code></li> </ul> <p>How to add the layer? For example, let's consider add between <code>node</code> and <code>node.left</code>.</p> <ul> <li><code>node.left</code> exists, we add a <code>temp = TreeNode(left = node.left)</code> that it's left pointer to <code>node.left</code> and then we point <code>node.left = temp</code> to the new node</li> <li><code>node.left</code> doesn't exist, we add a new TreeNode points to nothing.</li> </ul> <p>Similarly for node.right.</p>","tags":["Tree","Depth-First Search","Breadth-First Search","Binary Tree"]},{"location":"leetcode/623-add-one-row-to-tree/#code-implementation","title":"Code Implementation","text":"<pre><code>from collections import deque\nclass Solution:\n    def addOneRow(self, root: Optional[TreeNode], val: int, depth: int) -&gt; Optional[TreeNode]:\n        # edge case\n        if depth == 1:\n            new_root = TreeNode(val = val,left = root)\n            return new_root\n\n        curr = root\n        queue = deque([curr])\n        curr_depth = 0\n        is_layer_added = False\n        while queue and not is_layer_added:\n            curr_depth += 1\n            for _ in range(len(queue)):\n                node = queue.pop()\n                if node.left:\n                    queue.appendleft(node.left)\n                if node.right:\n                    queue.appendleft(node.right)\n                # added layer\n                if curr_depth == depth - 1 or curr_depth == depth:            \n                    if node.left:\n                        temp_left = TreeNode(val = val, left = node.left)                        \n                        node.left = temp_left\n                    else:\n                        temp_left = TreeNode(val = val)                        \n                        node.left = temp_left\n                    if node.right:\n                        temp_right = TreeNode(val = val, right = node.right)\n                        node.right = temp_right    \n                    else:\n                        temp_right = TreeNode(val = val)\n                        node.right = temp_right\n                    is_layer_added = True   \n\n        return curr\n</code></pre>","tags":["Tree","Depth-First Search","Breadth-First Search","Binary Tree"]},{"location":"leetcode/623-add-one-row-to-tree/#approach-2-dfs-recursive","title":"Approach 2 DFS (recursive)","text":"","tags":["Tree","Depth-First Search","Breadth-First Search","Binary Tree"]},{"location":"leetcode/623-add-one-row-to-tree/#approach-3-dfs-iterative","title":"Approach 3 DFS (iterative)","text":"","tags":["Tree","Depth-First Search","Breadth-First Search","Binary Tree"]},{"location":"leetcode/63-unique-paths-II/","title":"63 Unique Paths II","text":""},{"location":"leetcode/64-minimum-path-sum/","title":"64 Minimum path sum","text":""},{"location":"leetcode/647-palindromic-substrings/","title":"647 Palindromic Substrings","text":"<p>\u8fd9\u4e00\u9898\u7684LC premium article\u5199\u7684\u5b9e\u5728\u592a\u725b\u903c\u4e86\uff0c\u8fd9\u7bc7post\u7684\u5f88\u591a\u8868\u8fbe\u65b9\u5f0f\uff0c\u90fd\u501f\u9274\u4e86\u8fd9\u7bc7\u6587\u7ae0. </p>","tags":["String","Dynamic Programming","Palindrome"]},{"location":"leetcode/647-palindromic-substrings/#palindrome","title":"Palindrome","text":"<p>\u56de\u6587\u4e32\u7684\u5b9a\u4e49\u662f\uff0c\u6b63\u7740\u8bfb\u548c\u5012\u7740\u8bfb\u662f\u4e00\u6837\u7684\uff0c\u6bd4\u5982<code>\"aba\"</code>, <code>\"abba\"</code>, <code>\"abcba\"</code>. \u4e00\u5171\u6709\u4e24\u79cdpalindrome, \u4e00\u79cd\u662f\u5947\u6570\u957f\u5ea6\u7684\uff0c\u4e00\u79cd\u662f\u5076\u6570\u957f\u5ea6\u7684.</p> <p>\u5947\u6570\u7684\u6709<code>\"aba\"</code>, \u5076\u6570\u7684\u6709<code>\"abba\"</code>, <code>\"aa\"</code>. </p> <p>Tip</p> <p>Palindromes are compositionally homogeneous around their center.</p> <p>In layman's terms, smaller palindromes make up larger palindromes. \u4e00\u4e2a\u5927\u7684palindrome\u4e00\u5b9a\u7531\u5c0f\u7684palindrome\u7ec4\u6210.\u6bd4\u5982\u4f60\u6709\u4e00\u4e2apalindrome <code>eve</code>,</p> <ul> <li><code>eve</code>\u5f80\u91cc\u8d70\uff0c\u90a3\u4e48<code>eve</code>\u7684\u4e2d\u5fc3\uff0c\u4e5f\u5c31\u662f<code>v</code>\u4e00\u5b9a\u4e5f\u662f\u4e2apalindrome</li> <li><code>eve</code>\u5f80\u5916\u6269\u5c55\uff0c\u53ea\u9700\u8981\u7b26\u5408\u5de6\u53f3\u589e\u52a0\u7684character\u76f8\u7b49\uff0c\u90a3\u4e48\u5c31\u662fpalindrome, \u6bd4\u5982\u8fc7<code>level</code>.</li> </ul>","tags":["String","Dynamic Programming","Palindrome"]},{"location":"leetcode/647-palindromic-substrings/#approach-1-brute-force-on3-time-o1-space","title":"Approach 1 Brute force \\(O(N^3)\\) time, \\(O(1)\\) space","text":"<pre><code>class Solution:\n    def countSubstrings(self, s: str) -&gt; int:\n        # Brute force: travsere all potential substring O(N^2), determine palindrome or not, two pointer O(n)        \n\n        def is_palindrome(s,left,right):\n            while left &lt; right:\n                if s[left] != s[right]:\n                    return False\n                left += 1\n                right -= 1\n            return True\n\n        res = 0\n        for i in range(len(s)):\n            for j in range(i,len(s)):\n                if is_palindrome(s,i,j):\n                    res += 1\n\n        return res\n</code></pre> <p>\u6ce8\u610f\u4e00\u4e0bpython\u4e2dstring slicing\u4e5f\u662fright exclusive\u7684\uff0c\u6240\u4ee5word = s[i:j+1]\uff0c\u8fd9\u6837\u7684\u8bdd\uff0cword\u7684\u957f\u5ea6\u5c31\u662fj-i+1, \u4e5f\u5c31\u4e0d\u4f1amiss\u6389\u6700\u540e\u4e00\u4e2a\u5b57\u7b26. </p> <pre><code>class Solution:\n    def countSubstrings(self, s: str) -&gt; int:\n        # Brute force: travsere all potential substring O(N^2), determine palindrome or not, two pointer O(n)        \n\n        def is_palindrome(word):\n            left,right = 0,len(word)-1,\n            while left &lt; right:\n                if word[left] != word[right]:\n                    return False\n                left += 1\n                right -= 1\n            return True\n\n        res = 0\n        for i in range(len(s)):\n            for j in range(i,len(s)):\n                word = s[i:j+1]         \n                if is_palindrome(word):\n                    res += 1\n\n        return res\n</code></pre>","tags":["String","Dynamic Programming","Palindrome"]},{"location":"leetcode/647-palindromic-substrings/#approach-2-dp-on2-time-on2-space","title":"Approach 2 DP \\(O(N^2)\\) time, \\(O(N^2)\\) space","text":"","tags":["String","Dynamic Programming","Palindrome"]},{"location":"leetcode/647-palindromic-substrings/#dp","title":"\u5982\u4f55\u786e\u5b9a\u662f\u5426\u7528DP?","text":"<p>DP\u7b49\u4ef7\u4e8e, - Optimal substructure - Overlapping subproblems</p> <p>As for Optimal substructure, since palindrome is made of smaller palindrome. \u4e5f\u5c31\u662f\u8fd9\u4e2a\u6709substructure. </p> <p>As for overlapping subproblems, \u6211\u4ee5\u524d\u6ca1\u600e\u4e48\u7406\u89e3\u8fd9\u4e00\u5c42\u7684\u610f\u601d\uff0cin layman's term, \u5176\u5b9e\u5c31\u662f\u6709\u91cd\u590d\u8ba1\u7b97\u7684\u610f\u601d. \u6211\u4eec\u62ff<code>level</code>\u4f5c\u4e3a\u4f8b\u5b50\uff0c\u5982\u4e0b\u8868\u6240\u793a.</p> word <code>level</code> <code>eve</code> <code>v</code> <code>level</code> 1 1 1 <code>eve</code> 0 1 1 <code>v</code> 0 0 1 <p>\u8fd9\u91cc<code>level</code>, <code>eve</code> and <code>eve</code>\u8fd9\u4e09\u4e2aproblem, \u90fd\u5171\u4eab\u4e86<code>v</code>\u8fd9\u4e2asubproblem\uff0c\u88ab\u89e3\u4e86\u4e09\u6b21\uff0c\u8fd9\u4e5f\u662foverlapping subproblems\u7684\u610f\u601d.</p>","tags":["String","Dynamic Programming","Palindrome"]},{"location":"leetcode/647-palindromic-substrings/#dp-definition","title":"dp definition","text":"<p>\u8fd9\u662f\u4e8c\u7ef4dp\u7684\u4e00\u4e2a\u5178\u578b\u9898\u76ee\uff0c<code>dp[i][j]</code>\u8868\u793a<code>s[i:j+1]</code>\u662f\u5426\u662fpalindrome, \u5982\u4e0b\u56fe\u6240\u793a</p> <p></p> <p>Note</p> <p>\u4f60\u6ce8\u610f\u5230\u4e86\u5417? \u8fd9\u4e2a\u77e9\u9635\uff0c\u53ea\u9700\u8981upper triangle\u5c31\u53ef\u4ee5\u4e86.</p>","tags":["String","Dynamic Programming","Palindrome"]},{"location":"leetcode/647-palindromic-substrings/#initial-condition","title":"Initial condition","text":"<p>\u8fd9\u4e00\u9898\u6709\u4e24\u4e2abase case, \u4e00\u4e2a\u662f\u5947\u6570\u957f\u5ea6\u7684\uff0c\u4e00\u4e2a\u662f\u5076\u6570\u957f\u5ea6\u7684, \u6240\u4ee5\u66f4\u65b0\u7531\u4e0b\u56fe\u6240\u793a, </p> <p></p> <p>\u7b80\u5316\u4e00\u4e0b\u7684\u8bdd, for odd case, \u5176\u5b9e\u5c31\u662fkronecker delta \\(\\delta{ij}\\),</p> \\[ \\begin{equation}     dp(i,j) = \\begin{cases}         1 &amp; \\text{if } i = j \\\\         0 &amp; \\text{if } i \\neq j     \\end{cases} \\end{equation} \\] <p>for even case, </p> \\[ \\begin{equation}     dp(i,i+1) = \\begin{cases}         1 &amp; \\text{if } s[i] = s[i+1] \\\\         0 &amp; \\ otherwise     \\end{cases} \\end{equation} \\]","tags":["String","Dynamic Programming","Palindrome"]},{"location":"leetcode/647-palindromic-substrings/#state-transition-function","title":"State transition function","text":"<p>\u5e38\u89c4\u65b9\u6cd5\u4e3a, \u5de6pointer\u4e3a<code>i</code>, \u53f3pointer\u4e3a<code>j</code>. \u4f46\u6211\u4eec\u53ef\u4ee5\u6362\u4e00\u4e2a\u601d\u8def\uff0c\u56e0\u4e3a\u6211\u4eec\u5df2\u7ecf\u6c42\u4e86length = 1 and 2\u7684\u60c5\u51b5\uff0c\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u76f4\u63a5\u4ecelength = 3\u5f00\u59cb\uff0c\u8fd9\u6837\u7684\u8bdd\uff0c\u6211\u4eec\u53ef\u4ee5\u76f4\u63a5\u7528length\u6765\u904d\u5386\uff0c\u7136\u540e\u7528<code>i</code>\u6765\u904d\u5386\u6240\u6709\u7684\u8d77\u59cb\u70b9, \u901a\u8fc7<code>i</code>\u548c<code>length</code>\u6765\u786e\u5b9a<code>j</code>. </p> <p>A string is palindrome\u7684\u5145\u8981\u6761\u4ef6\u53d8\u4e3a:</p> <ul> <li>its first and last characters are the same</li> <li>the rest of the string (excluding the first and last characters) is also a palindrome</li> </ul> <p>\u53ef\u4ee5formulate\u6210\u5982\u4e0b\u7684state transition function:</p> \\[ \\begin{equation}     dp(i,j) = \\begin{cases}         True &amp; \\text{if}\\quad dp(i+1,j-1) = True \\text{ and } s[i] = s[j] \\\\         False &amp; \\text{otherwise}     \\end{cases} \\end{equation} \\] <p>\u7531\u4e8e\u6211\u4eec\u7684\u8ba1\u7b97\u987a\u5e8f\u662f:</p> <ul> <li>base case</li> <li>\u5148\u8ba1\u7b97\u957f\u5ea6\u4e3a1\u7684</li> <li>\u518d\u8ba1\u7b97\u957f\u5ea6\u4e3a2\u7684</li> <li>length &gt;= 3</li> </ul> <p>\u6211\u4eec\u6c42length = 3\u7684\u65f6\u5019\uff0c\u6211\u4eec\u7684dp[][]\u6570\u7ec4\u5df2\u7ecf\u6709\u4e86\u957f\u5ea6\u4e3a1 and 2\u7684\u4fe1\u606f\uff0c\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u76f4\u63a5\u7528<code>dp[i+1][j-1]</code>\u6765\u5224\u65ad\u662f\u5426\u662fpalindrome. \u9700\u8981\u89e3\u51b3\u5f53\u524d\u957f\u5ea6\u7684substring\u7684\u95ee\u9898\u6240\u9700\u7684\u6240\u6709\u4fe1\u606f\uff0c\u5df2\u7ecf\u88abcache\u4e86.</p> <pre><code>class Solution:\n    def countSubstrings(self, s: str) -&gt; int:\n        res = 0\n        n = len(s)\n        dp = [[False for _ in range(n)] for _ in range(n)]\n\n        # base case odd\n        for i in range(n):\n            dp[i][i] = True\n            res += 1\n\n        # base case even\n        for i in range(n-1):\n            if s[i] == s[i+1]:\n                dp[i][i+1] = True\n                res += 1\n\n        for length in range(3,n+1):\n            for i in range(0,n + 1 - length):\n                j = length + i - 1\n                if dp[i+1][j-1] and s[i] == s[j]:\n                    dp[i][j] = 1\n                    res += 1\n\n        return res1\n</code></pre>","tags":["String","Dynamic Programming","Palindrome"]},{"location":"leetcode/647-palindromic-substrings/#approach-3-dp-space-optimized-on2-time-on-space","title":"Approach 3 DP, space optimized \\(O(N^2)\\) time, \\(O(N)\\) space","text":"","tags":["String","Dynamic Programming","Palindrome"]},{"location":"leetcode/647-palindromic-substrings/#approach-4-expand-around-center-on2-time-o1-space","title":"Approach 4 Expand around center \\(O(N^2)\\) time, \\(O(1)\\) space","text":"","tags":["String","Dynamic Programming","Palindrome"]},{"location":"leetcode/658-Find-K-Closest-Elements/","title":"658 Find K Closest Elements","text":"","tags":["Array","Two Pointers","Binary search","Sorting","Sliding Window","Heap (Priority Queue)"]},{"location":"leetcode/658-Find-K-Closest-Elements/#approach-1-binary-search","title":"Approach 1 Binary Search","text":"<p>Given a sorted integer array, find the k closest elements to x in the array. The result should also be sorted in ascending order.</p> <ul> <li><code>|a - x| &lt; |b - x|</code></li> <li><code>|a - x| == |b - x|</code> and <code>a &lt; b</code></li> </ul> <pre><code>class Solution:\n    def findClosestElements(self, arr: List[int], k: int, x: int) -&gt; List[int]:\n        left,right = 0,len(arr)-k\n\n        while left &lt; right:\n            mid = (left + right)//2\n            if x - arr[mid] &gt; arr[mid + k] - x:\n                left = mid + 1\n            else:\n                right = mid\n        return arr[left:left+k]\n</code></pre>","tags":["Array","Two Pointers","Binary search","Sorting","Sliding Window","Heap (Priority Queue)"]},{"location":"leetcode/673-number-of-longest-increasing-subsequence/","title":"Intuition","text":"<p>\u8fd9\u4e00\u9898\u662flis\u53d8\u79cd\uff0csubsequence problems' bottom up solution usually includes multiple indicator - <code>LIS</code>: longest increasing sequence ending on <code>nums[i]</code>. Track longest sequence so far. - <code>count</code>: number of LIS ending on <code>nums[i]</code>. track current longest sequence so far.</p> <p>This problem has a couple of states: - <code>if nums[i] &gt; nums[j]</code>: Since we found an increasing sequence, we are allowed to update. How to update is based whether this new increasing sequence is longer than what we have or equal to what we have.   - <code>if LIS[i] &lt; LIS[j] + 1</code>: we found a longer sequence. increment <code>DP[i]</code> by one, reset <code>count[i]</code> to <code>count[j]</code>.      - \u8fd9\u91cc\u89e3\u91ca\u4e00\u4e0b\uff0c\u5982\u679c<code>count[j]</code> == 1, \u8bf4\u660eending on <code>nums[j]</code> \u7684\u6700\u957f\u5b50\u5e8f\u5217\u53ea\u6709\u4e00\u4e2a\uff0c\u5982\u679c<code>count[j]&gt;1</code>, \u4f60\u5f97\u628a\u8fd9\u4e24\u4e2a\u90fd\u7b97\u4e0a. [1,2,3], on nums[2] = 3    - <code>if LIS[i] == LIS[j] + 1</code>: we found a sequence of same length, increment count[i] by count[j].</p> <p>\u4e0b\u9762\u662fstate transition diagram:</p> <pre><code>flowchart TD\n    init(\"LIS, count \u521d\u59cb\u5316\u4e3a1\")\n    do_nothing(\"do nothing\")\n    longer_state(\"longer found&lt;br&gt;LIS[i] = LIS[j] + 1&lt;br&gt;count[i] = count[j]\")\n    same_state(\"same length found &lt;br&gt;LIS[i] = LIS[j] + 1&lt;br&gt;count[i] = count[j]+1\")\n    if{\"nums[j] &lt; nums[i]?\"}\n    init --&gt; if\n    if ---&gt; |No|do_nothing \n    if --&gt; |\"Yes and LIS[i] &lt; LIS[j] + 1\"| longer_state\n    if --&gt; |\"Yes and LIS[i] = LIS[j] + 1\"| same_state</code></pre> <pre><code>class Solution:\n    def findNumberOfLIS(self, nums: List[int]) -&gt; int:\n        # LIS[i]: longest increasing sequence ending on nums[i]\n        # count[i]: number of LIS ending on nums[i]\n        # base case: all one\n        LIS = [1 for num in nums]\n        count = [1 for num in nums]\n\n        for i in range(len(nums)):\n            for j in range(i):\n                if nums[i] &gt; nums[j]:\n                    if LIS[i] &lt; LIS[j] + 1: # find a longer sequence\n                        LIS[i] = LIS[j] + 1\n                        count[i] = count[j]\n                        continue\n\n                    if LIS[i] == LIS[j] + 1: # find another sequence with same length\n                        LIS[i] = LIS[j] + 1\n                        count[i] += count[j]\n        # update the data \n        max_length = max(LIS)\n        return sum(c for l, c in zip(LIS, count) if l == max_length)\n</code></pre>"},{"location":"leetcode/678-valid-parenthesis-string/","title":"678 Valid Parenthesis String","text":"<p>\u5148\u6765\u7406\u89e3\u4e00\u4e0b\u8fd9\u9898\uff0cobservations\u5982\u4e0b:</p> <ul> <li>\u4e00\u5171\u53ea\u6709\u4e09\u79cd\u5b57\u7b26: <code>(</code>, <code>)</code> and <code>*</code></li> <li>\u8d56\u5b50\u724c\uff0c<code>*</code> \u53ef\u4ee5\u4ee3\u8868\u4e09\u79cd\u4ee5\u4e0a<code>(</code> or <code>)</code> or empty string <code>''</code> </li> <li>\u90a3\u4e48\u5bf9\u4e8e\u6bcf\u4e00\u4e2a<code>*</code>\u90fd\u6709\u4e09\u79cd\u53ef\u80fd\u6027\uff0c\u90a3\u4e48\u603b\u5171\u6709\\(3^{*}\\)\u79cd\u53ef\u80fd\u6027</li> </ul> <p>\u5148\u628a\u53ef\u80fd\u6027\u7684path\u753b\u51fa\u6765,</p> <p>\u8fd9\u79cd\u66b4\u529b\u7684\u6811\u4e00\u753b\u51fa\u6765\uff0c\u4f1a\u53d1\u73b0\u6709\u5f88\u591a\u91cd\u590d\u7684\u5b50\u95ee\u9898\uff0c\u6240\u4ee5\u6697\u793a\u6211\u4eec\u53ef\u4ee5\u7528DP\u6765\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898.</p>","tags":["String","Dynamic Programming","Stack"]},{"location":"leetcode/678-valid-parenthesis-string/#approach-1-top-down-with-memoization","title":"Approach 1 Top-down with memoization","text":"<pre><code>class Solution:\n    def checkValidString(self, s: str) -&gt; bool:\n        \"\"\"\n        observation:\n        - \u53ea\u6709(,) and *\n        - \u548c\u9ebb\u5c06\u724c\u7684\u8d56\u5b50\u4e00\u6837\uff0c*\u80fd\u4ee3\u8868\u4efb\u4f55( or ) or empty string\n        - parathesis questions must involve stack to push '(' in when necessary\n        - \u5047\u8bbe\u6211\u4eec\u6709x\u4e2a*, \u90a3\u4e48\u5c31\u67093^{*}\u4e2a\u53ef\u80fd\u6027\n        \"\"\"\n        n = len(s)\n        memo = [[-1] * n for _ in range(n)]\n\n        return self.is_valid_string(0,0,s,memo)\n\n    def is_valid_string(self,index,open_count,s,memo):\n        # base case\n        if index == len(s):\n            # reach the end of the string,\n            return open_count == 0\n\n        # in-memo\n        if memo[index][open_count] != -1:\n            return memo[index][open_count] == 1\n\n        is_valid = False\n        if s[index] == '*':\n            # '*' as '('\n            is_valid |= self.is_valid_string(index+1,open_count+1,s,memo)\n            if open_count &gt; 0:\n                # '*' as '('\n                is_valid |= self.is_valid_string(index+1,open_count-1,s,memo)\n            # treat as empty string\n            is_valid |= self.is_valid_string(index+1,open_count,s,memo)\n        else:\n            if s[index] == '(':\n                is_valid = self.is_valid_string(index+1,open_count+1,s,memo)\n            elif open_count &gt; 0:\n                is_valid = self.is_valid_string(index+1,open_count-1,s,memo)\n\n        # mark it True or False\n        memo[index][open_count] = 1 if is_valid else 0\n        return is_valid\n</code></pre>","tags":["String","Dynamic Programming","Stack"]},{"location":"leetcode/680-valid-palindrome-II/","title":"680 Valid Palindrome II","text":"<p>\u662f125 valid palindrome\u7684\u6269\u5c55, \u4f5c\u4e3a\u53cc\u6307\u9488\u5165\u95e8\u662f\u5f88\u4e0d\u9519\u7684\u4e00\u9898.</p>","tags":["Two Pointers","String","Greedy"]},{"location":"leetcode/680-valid-palindrome-II/#approach-1-two-pointers","title":"Approach 1 Two Pointers","text":"<p>\u4e00\u5171\u6709\u4e09\u79cd\u60c5\u51b5:</p> <ul> <li>\u4e0d\u9700\u8981\u5220\u9664\u4efb\u4f55\u5b57\u7b26,\u5c31\u662fpalindrome</li> <li>\u5728two pointer\u4e24\u7aef\u671d\u4e2d\u95f4travel\u7684\u8fc7\u7a0b\u4e2d,<ul> <li>\u5de6\u8fb9<code>i</code>\u9047\u5230\u4e0d\u4e00\u6837\u7684\u5b57\u7b26, \u5224\u65ad<code>i+1</code>\u5230<code>j</code>\u662f\u5426\u662fpalindrome</li> <li>\u53f3\u8fb9<code>j</code>\u9047\u5230\u4e0d\u4e00\u6837\u7684\u5b57\u7b26\uff0c\u5224\u65ad<code>i</code>\u5230<code>j-1</code>\u662f\u5426\u662fpalindrome</li> </ul> </li> </ul> <p>\u53ef\u4ee5\u770b\u51fa\uff0c\u6211\u4eec\u9700\u8981\u6267\u884cis_palindrome\u4e09\u6b21\uff0c\u6240\u4ee5\u6784\u5efa\u4e00\u4e2ahelper function\u6765\u5224\u65ad\u662f\u5426\u662fpalindrome.</p> <pre><code>class Solution:\n    def validPalindrome(self, s: str) -&gt; bool:\n        def is_palindrome(word,left,right):\n            while left &lt; right:\n                if word[left] != word[right]:\n                    return False\n                left += 1\n                right -= 1\n            return True\n\n        i,j = 0,len(s)-1\n        while i &lt; j and s[i] == s[j]:\n            i += 1\n            j -= 1\n\n        # we remove 0 char\n        if i &gt;= j:\n            return True\n        if is_palindrome(s,i+1,j) or is_palindrome(s,i,j-1):\n            return True\n\n        return False\n</code></pre>","tags":["Two Pointers","String","Greedy"]},{"location":"leetcode/69-binary-search/","title":"69 Binary Search","text":""},{"location":"leetcode/70-climbing-stairs/","title":"70 Climbing Stairs","text":"<p>\u7b97\u662f\u6590\u6ce2\u90a3\u5951\u6570\u5217\u7684\u53d8\u79cd\uff0c\u4e5f\u662f\u5f88\u597d\u7684recursion --&gt; memo --&gt; dp\u7684\u5165\u95e8\u9898\u76ee</p>","tags":["Dynamic Programming","Math","Recursion","Memoization"]},{"location":"leetcode/70-climbing-stairs/#approach-1-recursion-top-down","title":"Approach 1 Recursion (top-down)","text":"<pre><code>class Solution:\n    def climbStairs(self, n: int) -&gt; int:\n        if n &lt;= 2:\n            return n\n        else:\n            return self.climbStairs(n-1) + self.climbStairs(n-2)\n</code></pre>","tags":["Dynamic Programming","Math","Recursion","Memoization"]},{"location":"leetcode/70-climbing-stairs/#approach-2-recursion-with-memoization","title":"Approach 2 Recursion with Memoization","text":"<pre><code>class Solution:\n    memo = {1:1,2:2}\n    def climbStairs(self, n: int) -&gt; int:\n        if n &lt;= 2:\n            return n\n        else:\n            if n in self.memo:\n                return self.memo[n]\n\n            curr = self.climbStairs(n-1) + self.climbStairs(n-2)\n            self.memo[n] = curr\n\n            return curr\n</code></pre>","tags":["Dynamic Programming","Math","Recursion","Memoization"]},{"location":"leetcode/70-climbing-stairs/#approach-3-dynamic-programming","title":"Approach 3 Dynamic Programming","text":"<p>\u8fd9\u4e00\u9898\u662fdynamic programming\u7684\u5165\u95e8\u9898\u76ee\uff0c\u73b0\u5728\u6709n\u8282\u53f0\u9636\uff0c\u4f60\u6bcf\u6b21\u53ea\u80fd\u722c1\u6216\u80052\u8282\uff0c\u4f60\u73b0\u5728\u8fd9\u4e2astate i\u7684\u53ef\u80fd\u6027\uff0c\u53ea\u53d6\u51b3\u4e8ei-1, i-2, \u4e5f\u5c31\u662f</p> \\[ dp[i] = dp[i-1] + dp[i-2] \\] <p>\u6211\u4eec\u6765\u770b\u770b\u524d\u9762\u51e0\u6b65\u5c31\u5f88\u65b9\u4fbf\u7406\u89e3\u4e86</p> <p><pre><code>dp = [1,2]\n</code></pre> \u8fd9\u4e2a\u6570\u7ec4<code>dp</code>\u4e2d</p> <ul> <li><code>dp[0]</code>: \u4ee3\u8868\u7740\u722cn=1 (\u4e00\u8282\u53f0\u9636\u7684\u6240\u6709\u53ef\u80fd\u6027)</li> <li><code>dp[1]</code>: \u4ee3\u8868\u7740\u722cn=2 (\u4e24\u8282\u53f0\u9636\u7684\u6240\u6709\u53ef\u80fd\u6027)\uff0c\u4e5f\u5c31\u662f\u4f60\u8d70\u4e00\u6b65\u6216\u8005\u4e24\u6b65</li> </ul> <p>\u6309\u7167\u8fd9\u4e2a\u903b\u8f91\u5f80\u4e0b\u63a8:</p> <ul> <li><code>dp[2]</code>: \u4ee3\u8868\u7740n=3 (\u722c\u4e09\u8282\u53f0\u9636\u7684\u6240\u6709\u53ef\u80fd\u6027)\uff0c\u7531\u4e8e\u4f60\u817f\u77ed\uff0c\u4f60\u53ea\u80fd\u722c\u4e00\u8282\u6216\u8005\u4e24\u8282\u53f0\u9636\uff0c\u6240\u4ee5\u8bf4\u4f60\u8fd9\u4e00\u6b65i\u7684\u53ef\u80fd\u6027\uff0c\u662f\u4ece\u524d\u4e00\u4e2a\u53f0\u9636\u8d70\u4e00\u6b65 + \u524d\u4e24\u4e2a\u53f0\u9636\u8d70\u4e24\u6b65\u7684\u6240\u6709\u53ef\u80fd\u6027\u4e4b\u548c;</li> </ul> <p>.... so on so forth</p> <p>\u56e0\u6b64</p> \\[ dp[i] = dp[i-1] + dp[i-2] \\] <p>\u4ece\u903b\u8f91\u4e0a\u6765\u8bb2, \u5982\u679c\u4f60\u53ef\u4ee5\u4e00\u53e3\u6c14\u8de83\uff0c4\uff0c5\u6b65\uff0c\u90a3\u4e48\u4f60current state information is dependent on previous 3, 4, 5 steps, respectively.</p>","tags":["Dynamic Programming","Math","Recursion","Memoization"]},{"location":"leetcode/700-search-in-a-binary-search-tree/","title":"700 Search in a binary search tree","text":"<p>\u4e00\u5171\u4e09\u79cd\u89e3\u6cd5, </p> <ul> <li>recursive solution of DFS</li> <li>iterative solution of DFS with stack</li> <li>iterative solution of BFS with queue</li> </ul>","tags":["Tree","Binary Search Tree","Binary Tree"]},{"location":"leetcode/700-search-in-a-binary-search-tree/#approach-1-recursion","title":"Approach 1 Recursion","text":"<p><code>base case</code>: \u4e5f\u5c31\u662f\u5f53\u6211\u4eectraverse\u5230\u4e86<code>None</code>\u7684\u65f6\u5019, \u76f4\u63a5\u8fd4\u56de<code>None</code>\u5373\u53ef. \u5982\u679c<code>val</code>\u7b49\u4e8e<code>root.val</code>, \u90a3\u4e48\u76f4\u63a5\u8fd4\u56de<code>root</code>\u5373\u53ef, \u627e\u5230\u7b54\u6848\u4e86.</p> <p><code>recursive case</code>: \u5229\u7528BST\u7684\u6027\u8d28, \u5982\u679c<code>val</code>\u5c0f\u4e8e<code>root.val</code>, \u90a3\u4e48\u6211\u4eec\u5c31\u53bb\u5de6\u8fb9\u627e, \u5982\u679c<code>val</code>\u5927\u4e8e<code>root.val</code>, \u90a3\u4e48\u6211\u4eec\u5c31\u53bb\u53f3\u8fb9\u627e.</p> <pre><code># Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def searchBST(self, root: Optional[TreeNode], val: int) -&gt; Optional[TreeNode]:\n        # base case\n        if not root:\n            return root\n            # \u7528return None\u4e5f\u53ef\u4ee5, \u4f46\u8fd9\u91ccroot\u5c31\u662fNone, \u6240\u4ee5\u76f4\u63a5\u8fd4\u56deroot\u5373\u53ef\n            # return None\n\n        if val == root.val:\n            return root\n\n        if val &lt; root.val:\n            # go to some place smaller\n            return self.searchBST(root.left,val)\n        else:\n            return self.searchBST(root.right,val)\n</code></pre>","tags":["Tree","Binary Search Tree","Binary Tree"]},{"location":"leetcode/700-search-in-a-binary-search-tree/#approach-2-iterative-solution-of-dfs-with-stack","title":"Approach 2 Iterative solution of DFS with stack","text":"<p>\u8fd9\u9898\u751a\u81f3\u4e0d\u9700\u8981\u7528stack, \u56e0\u4e3a\u53ea\u9700\u8981\u4e00\u4e2apointer \u770b\u6bd4\u8f83value\u5c31\u53ef\u4ee5\u4e86. \u5176\u5b83\u6d89\u53ca\u5230DFS\u7684\u9898\u76ee, \u4e00\u822c\u90fd\u9700\u8981stack, \u56e0\u4e3a\u9700\u8981\u8bb0\u5f55\u8d70\u8fc7\u7684\u8def\u5f84, \u4f46\u8fd9\u9898\u4e0d\u9700\u8981.</p>","tags":["Tree","Binary Search Tree","Binary Tree"]},{"location":"leetcode/700-search-in-a-binary-search-tree/#code-implementation","title":"Code Implementation","text":"<pre><code># Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def searchBST(self, root: Optional[TreeNode], val: int) -&gt; Optional[TreeNode]:\n        curr = root\n\n        while curr:\n            if curr.val == val:\n                return curr\n            elif curr.val &lt; val:\n                curr = curr.right\n            else:\n                curr = curr.left\n\n        return None\n</code></pre>","tags":["Tree","Binary Search Tree","Binary Tree"]},{"location":"leetcode/700-search-in-a-binary-search-tree/#approach-3-iterative-solution-of-bfs-with-queue","title":"Approach 3 Iterative solution of BFS with queue","text":"","tags":["Tree","Binary Search Tree","Binary Tree"]},{"location":"leetcode/700-search-in-a-binary-search-tree/#code-bfs","title":"Code: \u66b4\u529bBFS","text":"<p>\u66b4\u529b\u7684Breadth First Search, \u4e0d\u5229\u7528binary search tree\u7684\u6027\u8d28.</p> <pre><code>from collections import deque\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def searchBST(self, root: Optional[TreeNode], val: int) -&gt; Optional[TreeNode]:\n        queue = deque([root])\n\n        while queue:\n            curr = queue.pop()\n            if curr.val == val:\n                return curr\n\n            if curr.left:\n                queue.append(curr.left)\n            if curr.right:\n                queue.append(curr.right)\n\n        return None\n</code></pre>","tags":["Tree","Binary Search Tree","Binary Tree"]},{"location":"leetcode/700-search-in-a-binary-search-tree/#code-bfsbstpruning","title":"Code: BFS\u5229\u7528BST\u6027\u8d28\u505apruning","text":"<p>\u5229\u7528BST\u6027\u8d28\u505a\u4e00\u4e9bpruning, </p> <pre><code>from collections import deque\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def searchBST(self, root: Optional[TreeNode], val: int) -&gt; Optional[TreeNode]:\n        queue = deque([root])\n\n        while queue:\n            curr = queue.pop()\n            if curr.val == val:\n                return curr\n\n            if curr.val &gt; val and curr.left:\n                queue.append(curr.left)\n            if curr.val &lt; val and curr.right:\n                queue.append(curr.right)\n\n        return None\n</code></pre>","tags":["Tree","Binary Search Tree","Binary Tree"]},{"location":"leetcode/703-kth-largest-element-in-a-stream/","title":"703 Kth Largest Element in a Stream","text":"<p>This question is asking for maintaining a data stream and return the kth largest element in the stream. Since we only interested in the kth largest element, we can just maintain kth largest elements in a DS by popping the smaller ones. Therefore, we can use a min heap of maximum length k to maintain the kth largest elements by popping the smaller ones.</p> <pre><code>from heapq import heapify,heappush,heappop\nclass KthLargest:\n\n    def __init__(self, k: int, nums: List[int]):\n        \"\"\"\n        since the problem asks for return the kth largest element in the stream\n        we only need to maintain a DS of len(k) and make sure those are the largest\n        \"\"\"\n        heapify(nums)\n        self.heap = nums\n        self.k = k\n        # we can get rid of the smaller values till length is k\n        self._prune()\n\n    def add(self, val: int) -&gt; int:\n        heappush(self.heap,val)\n        self._prune()\n\n        return self.heap[0]\n\n    def _prune(self):\n        while len(self.heap) &gt; self.k:\n            heappop(self.heap)\n\n# Your KthLargest object will be instantiated and called as such:\n# obj = KthLargest(k, nums)\n# param_1 = obj.add(val)\n</code></pre>","tags":["Tree","Design","Binary Search Tree","Heap (Priority Queue)","Binary Tree","Data Stream"]},{"location":"leetcode/704-binary-search/","title":"704 Binary Search","text":"","tags":["Binary Search","Array"]},{"location":"leetcode/704-binary-search/#approach-1-binary-search","title":"Approach 1 Binary Search","text":"<p>\u7b54\u6848\u5f88\u7b80\u5355\uff0c\u5982\u4e0b</p> <pre><code>class Solution:\n    def search(self, nums: List[int], target: int) -&gt; int:\n        left,right = 0,len(nums) - 1\n\n        while left &lt;= right:\n            mid = (left + right)//2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] &lt; target:\n                left = mid + 1\n            else:\n                right = mid - 1\n\n        # \u7b49\u53f7\u7684\u610f\u4e49, \u8f93\u51fa\u7684\u65f6\u5019\uff0cleft\u5728right\u7684\u53f3\u8fb9\uff0c\u4e14left = right + 1\n        return -1\n</code></pre> <p>\u96be\u70b9\u662f\u7406\u89e3<code>while left &lt;= right</code>\u7684\u610f\u4e49, \u5f53\u8df3\u51fawhile\u5faa\u73af\u7684\u65f6\u5019\uff0cleft\u5728right\u7684\u53f3\u8fb9\uff0c\u4e14left = right + 1. \u8fd9\u4ee3\u8868\u7740\u4e24\u4ef6\u4e8b:</p> <ul> <li>CASE 1: \u5982\u679c\u5df2\u7ecf\u627e\u5230\u4e86target, \u5728while\u5185\u5df2\u7ecf\u8fd4\u56demid. \u90a3\u4e48\u73b0\u5728\u76f4\u63a5\u5728loop\u4e2d<code>return mid</code></li> <li>CASE 2: \u4e00\u65e6\u8df3\u51fa<code>left &lt;= right</code>\u7684\u5faa\u73af\uff0cleft = right + 1, \u4ee3\u8868\u7740<code>left</code>\u5728<code>right</code>\u7684\u53f3\u8fb9\uff0c\u4e14<code>left</code>\u6307\u5411\u7684\u662f\u7b2c\u4e00\u4e2a\u5927\u4e8e<code>target</code>\u7684\u6570\uff0c<code>right</code>\u6307\u5411\u7684\u662f\u6700\u540e\u4e00\u4e2a\u5c0f\u4e8e<code>target</code>\u7684\u6570\u3002</li> </ul> <p>\u4f46\u4e3a\u4ec0\u4e48Case2\u662f<code>return -1</code>?, \u8fd9\u4e2a\u72b6\u6001\u5982\u4e0b\u56fe\u6240\u793a,</p> <p></p> <p>\u65e2\u7136<code>while left &lt;= right:</code>, \u90a3\u4e48\u6211\u4eec\u6709 $$ \\begin{equation} left = right + 1 \\end{equation} $$</p> <p>\u5176\u5b9e\u5c31\u662fsolution space\u4e3a\u7a7a\u96c6\uff0c\u4fdd\u8bc1case1 and case2\u7684\u5168\u96c6\u80fd\u591f\u88ab\u8986\u76d6\u5230. \u5982\u679c\u6211\u5de6\u6307\u9488\u90fd\u5230\u53f3\u6307\u9488\u7684\u53f3\u8fb9\u4e86\uff0c\u6211\u4e5f\u6709\u4e00\u4e2a\u8ba9\u4f60\u8df3\u51fa\u5faa\u73af\u7684\u6761\u4ef6<code>if nums[mid] == target:</code>, \u4f60\u8fd8\u662f\u8d70\u8fc7\u4e86\u6240\u6709\u7684while\u5faa\u73af\uff0c\u90a3\u4e48\u5c31\u8bf4\u660e\u6240\u6709\u89e3\u91cc\u9762\u90fd\u6ca1\u6709\u4f60\u8981\u627e\u7684\u89e3\uff0c\u90a3\u4e48\u5c31\u8fd4\u56de-1.</p>","tags":["Binary Search","Array"]},{"location":"leetcode/713-subarray-product-less-than-k/","title":"713 Subarray Product Less Than K","text":"<p>\u8fd9\u9898\u957f\u5f97\u5f88\u50cfprefix\u7684\u9898\u76ee\uff0c560 subarray sum equals k\uff0c\u4f46\u662f\u8fd9\u9898\u662fsubarray product less than k, \u610f\u5473\u7740\u6211\u4eec\u6ca1\u529e\u6cd5\u4ee5\\(O(1)\\)\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u6765\u67e5\u627e\u54c8\u5e0c\u8868\u91cc\u7684\u503c. </p> <p>Warning</p> <p>\u770beditorial\u4e4b\u524d\uff0c\u6211\u7684\u601d\u8def\u662f\u7528prefix-sum\u7684\u60f3\u6cd5\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\uff0c\u4f46\u4e0dwork, \u539f\u56e0\u662f\u6211\u4eec\u6ca1\u529e\u6cd5\u7528\\(O(1)\\)\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u6765\u67e5\u627e\u54c8\u5e0c\u8868\u91cc\u7684\u503c. \u4e4b\u540e\u6211\u7684\u601d\u8def\u60f3\u5230\u4e86sliding window, \u4f46\u6211\u7684dry run sliding window\u7684\u6307\u9488\u79fb\u52a8\u6761\u4ef6\u662f:</p> <ul> <li>\u5982\u679cproduct &lt; k, right += 1</li> <li>\u5982\u679cproduct &gt;= k, \u6211\u4eec\u5148backtrack <code>right -= 1</code>,\u8ba9\u7a97\u53e3\u4e2d\u7684product\u51cf\u5c11\u5230\u524d\u4e00\u6b65\u7684<code>&lt;k</code>. \u7136\u540ewindow\u4e0d\u65adshrink <code>left += 1</code>. \u8fc7\u7a0b\u4e2d\u6211\u4eec\u7ef4\u62a4product\u4ee5\u53ca\u7b26\u5408\u6761\u4ef6\u7684counter\u7684\u503c</li> </ul> <p>\u4f46\u8fd9\u4e48\u505a\u6ca1\u529e\u6cd5\u679a\u4e3e\u51fa\u6240\u6709\u7684subarray.</p>","tags":["Array","Sliding Window"]},{"location":"leetcode/713-subarray-product-less-than-k/#approach-1-sliding-window","title":"Approach 1: Sliding Window","text":"<p>\u8fd9\u9898\u96be\u70b9\u6709\u662f,</p> <ul> <li>\u5982\u4f55come up with sliding window\u7684\u89e3\u6cd5</li> <li>\u5982\u4f55\u62c6\u89e3\"\u6240\u6709\u7684subarray\"\u8fd9\u4e2a\u95ee\u9898.</li> </ul> <p>\u600e\u4e48\u5206\u89e3subarray\u8fd9\u4e2a\u95ee\u9898\u6709\u70b9\u50cfDP\u65f6\u505a\u8fc7\u7684\u601d\u8def, \u6211\u4eec\u53ef\u4ee5\u7528\u6240\u6709\u4ee5<code>i</code>\u7ed3\u5c3e\u7684subarray, \u6765\u8868\u793a\u6240\u6709\u7684subarray. \u6362\u53e5\u8bdd\u8bf4\uff0c\u6240\u6709\u7684subarray\u80fd\u591f\u7528:</p> <ul> <li>\u4ee5index <code>0</code>\u7ed3\u5c3e\u7684subarray</li> <li>\u4ee5inde x<code>1</code>\u7ed3\u5c3e\u7684subarray</li> <li>...</li> <li>\u4ee5index <code>n-1</code>\u7ed3\u5c3e\u7684subarray</li> </ul> <p>\u6765\u8868\u793a. \u6211\u4eec\u518d\u8fdb\u4e00\u6b65\u7f29\u5c0f\u8303\u56f4\u6765\u641c\u7d22\u6240\u6709\u6ee1\u8db3subarray product &lt; k\u7684subarray, \u6211\u4eec\u53ef\u4ee5\u7528sliding window\u6765\u505a. \u4e5f\u5c31\u662f\u8bf4\uff0c\u6211\u4eec\u628a\u4e0a\u8ff0\u95ee\u9898\u8f6c\u5316\u4e3a\u4e86,</p> <ul> <li>\u4ee5index <code>0</code>\u7ed3\u5c3e\u7684subarray, \u4e14product &lt; k</li> <li>\u4ee5index <code>1</code>\u7ed3\u5c3e\u7684subarray, \u4e14product &lt; k</li> <li>...</li> <li>\u4ee5index <code>n-1</code>\u7ed3\u5c3e\u7684subarray, \u4e14product &lt; k</li> </ul> <p>\u7531\u4e8e\u90fd\u662f\u6b63\u6574\u6570\uff0csubarray product, \u968f\u7740\u6211\u4eec<code>left += 1</code>, \u53ef\u4ee5\u627e\u5230\u4e00\u4e2a\u4e34\u754carray, \u4f7f\u5f97product &lt; k. \u8fd9\u4e2a\u4e34\u754carray\u5c31\u662f\u95ee\u9898\u7684\u5173\u952e\u70b9. \u8fd9\u5c31\u6d89\u53ca\u5230\u7b2c\u4e8c\u4e2a\u601d\u8def\uff0c\u5982\u4f55\u901a\u8fc7\u4e34\u754carray\u8ba1\u7b97\u5176\u4e2d\u7b26\u5408\u6761\u4ef6\u7684subarray\u7684\u4e2a\u6570. \u8fd9\u4e00\u601d\u8003\u8fc7\u7a0b\u5982\u4e0b\u56fe\uff0c</p> <p></p> <p>\u6211\u4eec\u603b\u7ed3\u4e00\u4e0b\uff0c\u4e0d\u96be\u53d1\u73b0\uff0c\u4ee5<code>i</code>\u7ed3\u5c3e\u7684subarray\u7684\u4e2a\u6570\u4e3a<code>window size</code>, \u5373<code>right - left + 1</code>. \u8fd9\u4e2a\u601d\u8def\u662f\u5173\u952e\uff0c\u6211\u4eec\u53ef\u4ee5\u518d\u505a\u4e00\u6b21\u8f6c\u5316,</p> <ul> <li>\u4ee5index <code>0</code>\u7ed3\u5c3e\u7684\u6ee1\u8db3\u6761\u4ef6\u7684\u6700\u5927\u4e34\u754csubarray\u7684window size</li> <li>\u4ee5index <code>1</code>\u7ed3\u5c3e\u7684\u6ee1\u8db3\u6761\u4ef6\u7684\u6700\u5927\u4e34\u754csubarray\u7684window size</li> <li>...</li> <li>\u4ee5index <code>n-1</code>\u7ed3\u5c3e\u7684\u6ee1\u8db3\u6761\u4ef6\u7684\u6700\u5927\u4e34\u754csubarray\u7684window size</li> </ul> <p>$$ \\text{total} = \\sum_{i=0}^{n-1} w_i $$ where \\(w_i\\) the size of the largest window ending at index <code>i</code> that with its product &lt; k.</p> <pre><code>class Solution:\n    def numSubarrayProductLessThanK(self, nums: List[int], k: int) -&gt; int:\n        \"\"\"\n        BFS: O(n^2) for finding all nums, O(n) for doing the product\n        --&gt; minior improvement of it by pre-processing\n\n        nums[1] \\in [1,1000]\n        x x x [x x x]\n               i.  j\n        x x x [x x x]\n            i-1    j\n        [x x x] x x x x\n         i   j\n\n        we one pass scan with pointer \"right\", and we calculate every possible array by combining solution for\n        every subarray ending at pointer [right]\n        \"\"\"\n        # edge case\n        if k &lt;= 1:\n            return 0\n\n        total = 0\n        rolling_product = 1\n        left = 0\n        for right,num in enumerate(nums):\n            rolling_product *= num\n\n            while rolling_product &gt;= k:\n                rolling_product /= nums[left]\n                left += 1\n            # if we reach here, it's the minimum size subarray that with its product &lt; k and ending at \"right\"\n            total += right - left + 1\n        return total\n</code></pre>","tags":["Array","Sliding Window"]},{"location":"leetcode/713-subarray-product-less-than-k/#approach-2-binary-search","title":"Approach 2: Binary Search","text":"<p>\u6709\u4e00\u4e2amath intuition for logrithms, it has a property that the sum of logarithms is \"approximately equal\" to the logarithm of the product.</p>","tags":["Array","Sliding Window"]},{"location":"leetcode/718-maximum-length-of-repeated-subarray/","title":"Approach","text":"<ul> <li><code>DP[i,j]</code> is defined as the maixmum repeating prefix array ending with num1[i] and num2[j] (inclusive). \u5fc5\u987b\u8981\u7528\u8fd9\u4fe9\u70b9\u4e3a\u7ed3\u5c3e.</li> </ul> \\[ DP[i,j] = \\begin{cases}     DP[i-1][j-1] + 1 &amp;if\\:nums[i]\\neq nums[j]\\\\     0 &amp;if\\:nums[i]= nums[j] \\end{cases} \\] <p>\u5173\u952e\u70b9\u5728\u4e8eprefix arraying endign with nums[i] and nums[j]. \u5982\u679c\u6700\u540e\u4e00\u4e2aelement\u4e0d\u76f8\u7b49\uff0c\u5219\u8fd9\u4fe9subarray\u5fc5\u7136\u4e0drepeating</p> <p></p>"},{"location":"leetcode/718-maximum-length-of-repeated-subarray/#not-optimized-code","title":"Not optimized code","text":"<pre><code>class Solution:\n    def findLength(self, nums1: List[int], nums2: List[int]) -&gt; int:\n        # DP[i,j]: maximum length of list ending on nums1[i] and nums2[j]\n\n        m = len(nums1)\n        n = len(nums2)\n\n        DP = [[0] * (n+1) for _ in range(m+1)]\n\n        for i in range(1,m+1):\n            for j in range(1,n+1):\n                if nums1[i-1] == nums2[j-1]:\n                    # \u76f8\u7b49,info from the top\n                    DP[i][j] = DP[i-1][j-1] + 1\n                else:\n                    # \u65e2\u7136\u4fe9array, last element\u4e0d\u7b49\uff0c\u90a3\u4e48\u5b83\u4eec\u5fc5\u7136\u4e0dshare repeating array ending on nums1[i] and num2s[j]\n                    DP[i][j] = 0\n\n        return max(max(row) for row in DP)\n</code></pre>"},{"location":"leetcode/718-maximum-length-of-repeated-subarray/#optimized-code","title":"Optimized code","text":"<pre><code>class Solution:\n    def findLength(self, nums1: List[int], nums2: List[int]) -&gt; int:\n        # DP[i,j]: maximum length of repeated subarray ending on nums1[i] and nums2[j]\n\n        m = len(nums1)\n        n = len(nums2)\n\n        last_row = [0 for _ in range(n+1)]\n        DP = [0 for _ in range(n+1)]\n        max_length = 0\n\n\n        # left right scan\n        for i in range(1,m+1):\n            for j in range(1,n+1):\n                if nums1[i-1] == nums2[j-1]:\n                    # \u76f8\u7b49,info from the top left\n                    DP[j] = last_row[j-1] + 1\n                else:\n                    DP[j] = 0\n                # update max_length\n                max_length = max(DP[j],max_length)\n\n            # update it\n            last_row = DP.copy()\n\n        return max_length\n</code></pre>"},{"location":"leetcode/72-edit-distance/","title":"Approach 1: bottom up","text":"<p>It is simliar to LCS and we need to define DP first</p> <ul> <li><code>DP[i,j]</code>: the minimum edit distance needed between word1 and word2.</li> <li><code>base case</code>: including the consideratio of \\(\\varnothing\\), then any word modified to \\(\\varnothing\\) would be <code>len(word)</code></li> <li>case 1: when <code>word1[i] == word2[j]</code>, then informatin is from top left corner</li> <li>case 2: when <code>word1[i] != word2[j]</code>, the information is coming from the minimum out of top cell, left cell or top left cell. And we need do one most operation to replace <code>word1[i]</code> and <code>word2[j]</code></li> </ul> \\[ DP[i,j] = \\begin{cases}     i&amp;if\\,j=0\\\\     j&amp;if\\,i=0\\\\     DP[i-1,j-1]&amp;if\\,word1[i] = word2[j]\\\\     min(DP[i-1,j-1],DP[i-1,j],DP[i,j-1])&amp;if\\,word1[i] \\neq word2[j]\\\\ \\end{cases} \\] <p>I would do an example so you could visualize it by first initializing it.</p> - \\(\\varnothing\\) r o s \\(\\varnothing\\) 0 1 2 3 h 1 - - - o 2 - - - r 3 - - - s 4 - - - e 5 - - - <p>The rest of it is extremely similar to the LCS example so i won't bother .</p>"},{"location":"leetcode/72-edit-distance/#code-implementaton","title":"Code implementaton","text":"<pre><code>from collections import defaultdict\nclass Solution:\n    def minDistance(self, word1: str, word2: str) -&gt; int:\n        # DP[i,j]: the minimum number of operations needed to edit from word1 to word2;\n        # base case: \u5982\u679c\u4efb\u4f55\u4e00\u4e2asubstring\u4e3a\u7a7a\u96c6\uff0c# of ops needed to reach \u7a7a\u96c6 always will be len(other_words);\n        # case 1: if word1[i] == word2[j], then no editing needed from upper left corner\n        # case 2: if word1[i] != word2[j], min(top cell, topleft cell, left cell)\n        # \u7531\u4e8e\u5b9a\u4e49\u662fmin # of operations needed, \u90a3\u4e48\u4fe1\u606f\u53ef\u4ee5\u4ece\u4efb\u4e00previous step\u6d41\u52a8\u8fc7\u6765\n\n        x = len(word1) \n        y = len(word2)\n\n        # \u52a0\u5165\u7a7a\u96c6\u7684\u8003\u91cf\uff0c\u5c31\u4e0d\u7528treat\u8fb9\u754c and mid nodes different\u4e86\n        DP = defaultdict(int)\n\n        for i in range(x+1):\n            DP[(i,0)] = i\n\n        for j in range(y+1):\n            DP[(0,j)] = j\n\n        # horizontal scanning, left to right, top to bottom\n        for i in range(1,x + 1):\n            for j in range(1,y + 1):\n                # \u5224\u65ad\u662f\u5426\u76f8\u7b49\n                if word1[i-1] == word2[j-1]:\n                    # info is propogating from top left \n                    DP[(i,j)] = DP[(i-1,j-1)]\n                else:\n                    # info is propogating from top or left\n                    DP[(i,j)] = 1 + min(DP[(i-1,j)],DP[(i,j-1)],DP[(i-1,j-1)])\n\n        return DP[(x,y)]\n</code></pre> <p>food for thought, what if you can only do delete and insert? </p>"},{"location":"leetcode/72-edit-distance/#if-only-delete-and-insert-allowed","title":"If only <code>delete</code> and <code>insert</code> allowed","text":"<p>In only delete and insert allowed, you can reduce the problem to the classics LCS problem. </p> <pre><code>from collections import defaultdict\nclass Solution:\n    def minDistance(self, word1: str, word2: str) -&gt; int:\n        # similar to LCS, find the largest common substring between word1 and word2,\n        # then \n        # example: \"horse\", \"ros\", --&gt; LCS =\"os\". len(word1) - len(LCS) = 5 - 2 = 3\n        # example: \"intention\", \"execution\", --&gt; LCS =\"tion\". len(word1) - len(LCS) = 9 - 4 = 5\n\n        # initialize to be zeros\n\n        x = len(word1) \n        y = len(word2)\n\n        # \u52a0\u5165\u7a7a\u96c6\u7684\u8003\u91cf\uff0c\u5c31\u4e0d\u7528treat\u8fb9\u754c and mid nodes different\u4e86\n        LCS = defaultdict(int)\n\n        # horizontal scanning, left to right, top to bottom\n        for i in range(1,x + 1):\n            for j in range(1,y + 1):\n                # \u5224\u65ad\u662f\u5426\u76f8\u7b49\n                if word1[i-1] == word2[j-1]:\n                    # info is propogating from top left \n                    LCS[(i,j)] = LCS[(i-1,j-1)] + 1\n                else:\n                    # info is propogating from top or left\n                    LCS[(i,j)] = max(LCS[(i-1,j)],LCS[(i,j-1)])\n        # replace operation: \u6700\u5212\u7b97\uff0c\u76f8\u5f53\u4e8edelete 1 char + add 1 char\n        # insert operation: \u589e\u52a0\u4e00\u4e2a\u6570\u5b57\n        # delete operation: \u51cf\u5c11\u4e00\u4e2a\u6570\u5b57\n        # \u600e\u4e48\u6837\u8ba1\u7b97replace a character\u7684number of opetaion\u5462?\n\n        edit_distance = len(word1) - LCS[(x,y)] + len(word2) - LCS[(x,y)]\n        return edit_distance\n</code></pre>"},{"location":"leetcode/72-edit-distance/#reference","title":"Reference","text":"<ul> <li>LC discussion</li> </ul>"},{"location":"leetcode/739-daily-temperatures/","title":"739 Daily Temperatures","text":"<p>\u8fd9\u9898\u6709\u4e09\u79cd\u89e3\u6cd5\uff0c</p> <ul> <li>Brute Force</li> <li>Monotonic Stack (optimal)</li> <li>Array, Space optimized (\u4e0d\u4f1a)</li> </ul>","tags":["Array","Stack","Monotonic Stack"]},{"location":"leetcode/739-daily-temperatures/#approach-1-brute-force","title":"Approach 1: Brute Force","text":"<p>\u6700\u7b80\u5355\u7684\u65b9\u6cd5\u662f\u4f7f\u7528\u4e24\u4e2a\u6307\u9488\uff0c\u4e00\u4e2a\u6307\u9488\u6307\u5411\u5f53\u524d\u7684\u6e29\u5ea6\uff0c\u53e6\u4e00\u4e2a\u6307\u9488\u6307\u5411\u5f53\u524d\u6e29\u5ea6\u7684\u4e0b\u4e00\u4e2a\u6e29\u5ea6\u3002\u5982\u679c\u4e0b\u4e00\u4e2a\u6e29\u5ea6\u6bd4\u5f53\u524d\u6e29\u5ea6\u9ad8\uff0c\u90a3\u4e48\u5c31\u627e\u5230\u4e86\u7b54\u6848\u3002\u5982\u679c\u6ca1\u6709\u627e\u5230\uff0c\u5c31\u7ee7\u7eed\u79fb\u52a8\u6307\u9488\u3002\u6211\u60f3\u51fa\u6765\u4e86\u8fd9\u4e2a\uff0c\u53ef\u60dctime limit exceeded\u4e86\u3002</p> <p>\u590d\u6742\u5ea6</p> <p>\\(O(n^2)\\) time complexity, \\(O(n)\\) space complexity.</p>","tags":["Array","Stack","Monotonic Stack"]},{"location":"leetcode/739-daily-temperatures/#code-implementation","title":"Code Implementation","text":"<p>\u53ef\u60dcTLE\u4e86</p> <pre><code>class Solution:\n    def dailyTemperatures(self, temperatures: List[int]) -&gt; List[int]:\n        # answers[i]: # of future days needed to get a higher temperature\n        # two pointer\n        left = 0\n        right = left + 1\n        ans = []\n        while left &lt;= right and left &lt; len(temperatures):\n            if right == len(temperatures):\n                # went beyond the length of array, no possible solution found, time to reset\n                ans.append(0)\n                left += 1\n                right = left\n            elif temperatures[right] &gt; temperatures[left]:\n                # found the solution, mark it down\n                ans.append(right - left)\n                left += 1\n                right = left\n            else:\n                # move the next\n                right += 1\n\n        return ans\n</code></pre>","tags":["Array","Stack","Monotonic Stack"]},{"location":"leetcode/739-daily-temperatures/#approach-2-monotonic-stack","title":"Approach 2 Monotonic Stack","text":"<p>Monotonic stack is a stack that is either strictly increasing or strictly decreasing. \u4e5f\u5c31\u662f\u4e25\u683c\u5355\u8c03\u9012\u589e\u6216\u8005\u9012\u51cf\u7684\u4e00\u79cd\u6570\u636e\u7ed3\u6784.</p> <p>Help</p> <p>Monotonic stack is good for finding the nearest biggest or nearest smallest element in an array, \u56e0\u4e3a\u5176\u4e25\u683c\u7684\u5355\u8c03\u6027. \u7c7b\u4f3c\u7684\u8fd8\u6709monotonic queue.</p> <p>\u8fd9\u91cc\u6211\u4eec\u53ef\u4ee5\u7528monotonic stack\u6765\u50a8\u5b58\u6240\u6709\u7b49\u5f85\u5bfb\u627e\u6bd4\u5b83\u6e29\u5ea6\u9ad8\u7684\u6e29\u5ea6\u7684index\u3002We traverse the original array, \u6bcf\u5f53\u9047\u5230\u4e00\u4e2a\u65b0\u7684\u6e29\u5ea6\u65f6\uff0c\u6211\u4eec\u505a\u4ee5\u4e0b\u5224\u65ad\uff0c</p> <ul> <li>\u5982\u679c\u4e0a\u4e00\u4e2aiteration\u585e\u8fdb\u53bb\u7684, <code>stack[-1]</code>\u6240\u6307\u5411\u7684\u6e29\u5ea6\u6bd4\u5f53\u524d\u6e29\u5ea6\u4f4e\uff0c\u90a3\u6211\u4eec\u5c31\u627e\u5230\u7b54\u6848\u4e86\uff0c\u6211\u4eec\u5c31pop\u51fa\u6765\uff0c\u7136\u540e\u8bb0\u5f55\u7b54\u6848\u3002</li> <li>\u5982\u679c\u4e0a\u4e00\u4e2aiteration\u585e\u8fdb\u53bb\u7684, <code>stack[-1]</code>\u6240\u6307\u5411\u7684\u6e29\u5ea6\u6bd4\u5f53\u524d\u6e29\u5ea6\u9ad8\uff0c\u90a3\u6211\u4eec\u8fd8\u6ca1\u6709\u4e3a<code>stack[-1]</code>\u627e\u5230\u7b54\u6848\uff0c\u90a3\u5c31\u628a\u5f53\u524d\u6e29\u5ea6\u7684index\u585e\u8fdb\u53bb\u3002</li> </ul> <p>\u5982\u4e0b\u56fe\u6240\u793a, </p> <p></p> <p>\u8fd9\u4e00\u9898\u9700\u8981\u641e\u6e05\u695a\u4e24\u70b9, - <code>answer[i]</code>\u8fd9\u4e2aarray, \u6211\u4eec\u5e76\u4e0d\u662f\u6309\u7167\u987a\u5e8f\u5bfb\u627e\u7b54\u6848\u7684.  - <code>stack</code>\u8d8a\u4e0a\u9762\u7684, \u6e29\u5ea6\u8d8a\u4f4e\uff0c\u56e0\u4e3a\u6240\u6709\u6bd4\u5b83\u6e29\u5ea6\u9ad8\u7684\u90fd\u5df2\u7ecf\u88abpop\u51fa\u53bb\u4e86\u3002</p> <p></p> <p>\u53e6\u4e00\u4e2a\u70b9\u662f\uff0c\u8fd9\u91cc\u7528\u7684 <pre><code>while stack and temperatures[stack[-1]] &lt; curr_temp:\n</code></pre></p> <p>Instead of <pre><code>if stack and temperatures[stack[-1]] &lt; curr_temp:\n</code></pre></p> <p>\u662f\u56e0\u4e3a\u6211\u4eec\u662f\u4e2aone-pass solution, \u5f53\u6211\u4eec\u9047\u5230\u4e00\u4e2a\u65b0\u7684temp\u7684\u65f6\u5019\uff0c\u6211\u4eec\u6bd4\u8f83curr_temp\u548ctop of stack\u7684\u6e29\u5ea6 (\u5728monotonic stack\u4e2d\u662f\u6700\u4f4e\u7684\uff0c\u6700\u5f31\u7684\u6e29\u5ea6)\uff0c\u6240\u4ee5\u6211\u4eec\u9700\u8981<code>while</code> loop\u8ba9curr_temp\u6765\u6253\u64c2\u53f0\u8d5b\uff0c\u76f4\u5230\u8f93\u6389.</p> <p></p>","tags":["Array","Stack","Monotonic Stack"]},{"location":"leetcode/739-daily-temperatures/#code-implementation_1","title":"Code Implementation","text":"<p>\u6ce8\u610f</p> <p>\u8bb0\u4f4f\uff0c\u6bcf\u5f53\u6211\u4eecpop\u51fa\u4efb\u4f55\u4e00\u4e2a\u5143\u7d20\u7684\u65f6\u5019\uff0c\u6211\u4eec\u90fd\u627e\u5230\u4e86the first element in <code>temperatures</code> that is greater than it. </p> <pre><code>class Solution:\n    def dailyTemperatures(self, temperatures: List[int]) -&gt; List[int]:\n        # a monotonic stack, with hotter temperature at bottom of the stack\n        stack = []\n        ans = [0] * len(temperatures)\n\n        for curr_index, curr_temp in enumerate(temperatures):\n            # we found a match for top of the stack\n            while stack and temperatures[stack[-1]] &lt; curr_temp:\n                prev_index = stack.pop()\n                ans[prev_index] = curr_index - prev_index\n            # cuz every temperature needs to be solved\n            stack.append(curr_index)\n        return ans\n</code></pre>","tags":["Array","Stack","Monotonic Stack"]},{"location":"leetcode/739-daily-temperatures/#approach-3-array-space-optimized","title":"Approach 3: Array, Space optimized","text":"<p>\\(O(n)\\) in time, \\(O(1)\\) in space. \u8fd9\u4e2a\u89e3\u6cd5\u592a\u725b\u903c\u4e86\uff0c\u4ee5\u540e\u518d\u5b66\u5427. Monotonic stack\u6765\u627enearest greater \u5c31\u8db3\u591f\u5f3a\u5927\u4e86.</p>","tags":["Array","Stack","Monotonic Stack"]},{"location":"leetcode/74-search-a-2D-matrix/","title":"74 Search a 2D Matrix","text":"<p>\u5f52\u5316\u7684\u60f3\u6cd5\uff0c\u8f6c\u79fb\u6210\u5df2\u77e5\u7684\u95ee\u9898\u3002\u5982\u679c\u7ed9\u5b9a\u7684\u4e0d\u662f\u4e8c\u7ef4\u6570\u7ec4\uff0c\u800c\u662f1d array, \u5c31\u5f88\u7b80\u5355\u3002\u90a3\u4e48for a matrix (m x n), \u6211\u4eec\u53ef\u4ee5\u6709\u4e00\u4e2a1D array of size m*n, \u4e5f\u5c31\u662f<code>nums[0..m*n-1]</code>. \u6211\u4eec\u53ea\u8981\u5728\u8fd9\u4e2a1d \u6570\u7ec4\u91cc\u9762\u505abinary search\u5c31\u53ef\u4ee5\u4e86. \u4f46\u6211\u4eec\u6709\u7684\u5374\u662f\u4e00\u4e2a2d array, \u5b9e\u9645\u4e0a\u6211\u4eec\u53ea\u8981\u627e\u5230\u8fd9\u4e2a\u5173\u7cfb\u5373\u53ef, <code>num[z] == matrix[x][y]</code>, \u6211\u4eec\u53ef\u4ee5\u5efa\u7acb\u4e00\u4e2a\u6620\u5c04\u5173\u7cfb\uff0c</p> <p>$$ \\begin{equation}     f(z) = (x,y) = (\\left\\lfloor \\frac{z}{n}\\right\\rfloor, z\\bmod n) \\end{equation} $$ where \\(m\\) and \\(n\\) are the number of rows and columns of the matrix, respectively.</p> <p>\u590d\u6742\u5ea6</p> <ul> <li>\u65f6\u95f4\u590d\u6742\u5ea6\uff1a\\(O(\\log(mn)) = \\log(m) + \\log(n)\\).</li> <li>\u7a7a\u95f4\u590d\u6742\u5ea6\uff1a\\(O(1)\\).</li> </ul> <pre><code>class Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -&gt; bool:\n        # binary search\n        # problem: \n        #   1. find the target;\n        #.  2. wrap around the rows somehow.\n\n        # Solution:\n        # BFS: linear search or flatten it to a 1D row and do your normal binary search. O(mn)\n        # m,n for row and col, respetively.\n        # i = 0 .. m*n-1\n        # i --&gt; matrix[i//n][i%n]\n\n        m,n = len(matrix),len(matrix[0])        \n        left,right = 0,m*n-1\n\n        while left &lt;= right:\n            mid = (left + right)//2\n            x,y = mid//n, mid%n\n            curr = matrix[x][y]\n            if  curr == target:\n                return True\n            elif curr &lt; target:\n                left = mid + 1\n            else:\n                right = mid - 1\n\n        return False\n</code></pre>","tags":["Array","Binary Search","Matrix"]},{"location":"leetcode/740-delete-and-earn/","title":"740 delete and earn","text":"<p>sss</p>"},{"location":"leetcode/744-find-smallest-letter-greater-than-target/","title":"744 Find Smallest Letter Greater Than Target","text":"","tags":["Array","Binary Search"]},{"location":"leetcode/744-find-smallest-letter-greater-than-target/#problem-statement","title":"Problem Statement","text":"<p>\u8fd9\u4e00\u9898\u7ed9\u4f60\u4e00\u4e2a\u6392\u5e8f\u597d\u7684\u6570\u7ec4 like <code>[\"a\",\"c\",\"z\"]</code>\uff0c\u548c\u4e00\u4e2atarget letter, \u8ba9\u4f60\u627e\u5230\u6570\u7ec4\u4e2d\u7b2c\u4e00\u4e2a\u5927\u4e8etarget\u7684letter. \u5982\u679c\u627e\u4e0d\u5230\uff0c\u5c31\u8fd4\u56de\u7b2c\u4e00\u4e2aletter.</p>","tags":["Array","Binary Search"]},{"location":"leetcode/744-find-smallest-letter-greater-than-target/#approach-1-ugly-but-works","title":"Approach 1 Ugly but works","text":"<p>\u81ea\u5df1\u5199\u7684\uff0c\u975e\u5e38struggle with the edge cases, \u4f46\u662f\u6700\u540e\u8fd8\u662f\u8fc7\u4e86. \u6211\u7684\u601d\u8def\u662f:</p> <ul> <li>\u5148\u5bfb\u627etarget\uff0c<ul> <li>\u5982\u679c\u627e\u5230\uff0c\u518dlinear search\u627e\u5230\u7b2c\u4e00\u4e2a\u5927\u4e8etarget\u7684\u6570</li> <li>\u5982\u679c\u627e\u4e0d\u5230\uff0c\u76f4\u63a5return first element</li> </ul> </li> </ul> <p>Warning</p> <p>\u6211\u8fd9\u4e00\u9898\u8fd9\u4e48struggle\u4e14solution deteriorate to Linear solution when i have array with low cardinality (edge case) like <code>[\"a\",\"a\",\"a\",\"a\"]</code>\u7684\u539f\u56e0\u662f\uff0c\u6211predicate\u5b9a\u4e49\u9519\u4e86.</p> <pre><code>class Solution:\n    def nextGreatestLetter(self, letters: List[str], target: str) -&gt; str:\n        left,right = 0, len(letters)-1\n\n        while left &lt;= right:\n            mid = (left + right)//2\n            if letters[mid] &gt; target:\n                right = mid - 1\n            elif letters[mid] &lt; target:\n                left = mid + 1\n            else:\n                # mid is the target\n                while mid &lt; len(letters):\n                    if letters[mid] &gt; target:\n                        return letters[mid]\n                    mid += 1\n\n                return letters[0]\n                # didn't find it\n                if mid == len(letters):\n                    return letters[0]\n                # we find it!\n                return mid\n\n            # case: we didn't find it and left &gt; right\n            # left = right + 1\n            if letters[left] &lt;= target:\n                while left &lt; len(letters):\n                    if letters[left] &gt; target:\n                        return letters[left]\n                    left += 1\n                return letters[0]\n            else:\n                return letters[left]\n</code></pre>","tags":["Array","Binary Search"]},{"location":"leetcode/744-find-smallest-letter-greater-than-target/#approach-2-beautiful-af","title":"Approach 2 Beautiful AF","text":"<p>\u8fd9\u9898\u7684\u641c\u7d22\u6761\u4ef6\u662f: <pre><code>\u627e\u5230\u7b2c\u4e00\u4e2a\u5927\u4e8etarget\u7684\u6570\uff0c\u800c\u4e0d\u662f\u627e\u5230target\n</code></pre></p> <p>\u90a3\u8fd9\u6837\u7684\u8bdd\uff0c\u6211\u4eec\u7684updates\u7684\u6761\u4ef6\u5c31\u4e0d\u53ea\u662fletters[left] &lt; target\u800c\u662fletters[left] &lt;= target. \u8fd9\u6837\u7684\u8bdd\uff0c\u6211\u4eec\u5c31\u53ef\u4ee5\u76f4\u63a5\u7528binary search\u627e\u5230\u7b2c\u4e00\u4e2a\u5927\u4e8etarget\u7684\u6570. <pre><code># \u5e94\u8be5\u662f\nif letters[mid] &lt;= target:\n    left = mid + 1\nelse:\n    right = mid - 1\n\n# instead of \nif letters[mid] &lt; target:\n    left = mid + 1\nelif letters[mid] == target:\n    pass\nelse:\n    right = mid - 1\n</code></pre></p> <p>\u5f53\u79bb\u5f00while\u5faa\u73af\u540e\uff0c\u6211\u4eec\u6709\u4ee5\u4e0b\u51e0\u4e2a\u6027\u8d28</p> <ul> <li>left + 1 = right</li> <li>\u5982\u679cletters\u4e2d\u5b58\u5728\u7b26\u5408letter\u5927\u4e8etarget\uff0c<ul> <li><code>letters[left]</code> is the first letter greater than target</li> <li><code>letters[right]</code> is the last letter less than target</li> </ul> </li> <li>\u5982\u679cletters\u4e2d\u4e0d\u5b58\u5728\u7b26\u5408letter\u5927\u4e8etarget\uff0c\u90a3\u4e48left\u5fc5\u7136\u5df2\u7ecf\u641c\u7d22\u5230\u4e86\u6700\u540e\u4e00\u4e2aletter\uff0c\u4e5f\u6ca1\u627e\u5230\u5927\u4e8etarget\u7684\u6570. \u6240\u4ee5, <ul> <li><code>left == len(letters)</code></li> <li><code>nums[left]</code> &gt;= target\u6052\u6210\u7acb</li> </ul> </li> </ul> <pre><code>class Solution:\n    def nextGreatestLetter(self, letters: List[str], target: str) -&gt; str:\n        left,right = 0,len(letters)-1\n\n        while left &lt;= right:\n            mid = (left + right)//2\n            if letters[mid] &lt;= target:\n                left = mid + 1\n            else:\n                right = mid - 1\n\n        # when reaches here, left = right + 1 and left is the first index greater than mid\n        if left == len(letters):\n            # scan the whole array\n            return letters[0]\n        else:\n            return letters[left]\n</code></pre>","tags":["Array","Binary Search"]},{"location":"leetcode/746-min-cost-climbing-stairs/","title":"746 min cost climbing stairs","text":"<p>sss</p>"},{"location":"leetcode/752-open-the-lock/","title":"752 Open the Lock","text":"<p>\u5f88\u65b0\u9896\u7684\u4e00\u9053BFS\u9898\u76ee\u4e86. \u6709\u70b9\u50cfgym lock, \u6709\u56db\u4f4d\u6570\uff0c\u4e0d\u65ad\u6362\u4f4d\uff0c\u4f46\u662f\u6709\u4e9b\u4f4d\u662fdeadend, \u4e0d\u80fd\u6362\u4f4d\u3002\u6211\u4eec\u8981\u627e\u5230\u6700\u5c11\u7684\u6362\u4f4d\u6b21\u6570\uff0c\u4ece\"0000\"\u5230\"target\"\u3002</p> <p></p> <p>\u5728matrix\u4e2d\u7684\u4e0a\u4e0b\u5de6\u53f3\u56db\u4e2a\u65b9\u5411\uff0c\u8fd9\u91cc\u53d8\u6210\u4e868\u4e2a\u65b9\u5411\uff0c\u56e0\u4e3a\u6bcf\u4e2a\u6570\u5b57\u53ef\u4ee5\u52a01\u6216\u8005\u51cf1\uff0c\u6240\u4ee5\u67098\u4e2a\u72b6\u6001\u91cf. Similarly, \u9700\u8981\u7ef4\u62a4\u4e00\u4e2aset\u6765\u8bb0\u5f55\u5df2\u7ecf\u8bbf\u95ee\u8fc7\u7684\u72b6\u6001\u91cf\uff0c\u907f\u514d\u91cd\u590d\u8bbf\u95ee\u3002BFS\u6700\u5148\u5230\u8fbe\u7684\u72b6\u6001\u91cf\u80af\u5b9a\u662f\u6700\u77ed\u8def\u5f84\u3002</p> <p>warp-around\u7684\u5904\u7406</p> <p>\u8fd98\u4e2a\u72b6\u6001\u91cf\u8ba1\u7b97\u65f6\u8981\u6ce8\u610fwrap around\u4ee5\u53ca\u51cf\u6cd5\u65f6\u5019\u7684\u8d1f\u6570\u5904\u7406\u3002</p> <ul> <li>0 + 1 = 1, 1 % 10 = 1</li> <li>9 + 1 = 10, 10 % 10 = 0 (wrap around 9--&gt;0)</li> <li>0 - 1 = -1, (-1 + 10) % 10 = 9 (wrap around 0--&gt;9)</li> </ul>","tags":["Array","Hash Table","String","Breadth-First Search"]},{"location":"leetcode/752-open-the-lock/#approach-1-bfs","title":"Approach 1 BFS","text":"<pre><code>class Solution:\n    def openLock(self, deadends: List[str], target: str) -&gt; int:\n        \"\"\"\n        observation:\n        - kinda like gym lock from 0-9 but 9 wraps around to 0\n        - starts from \"0000\" --&gt; \"target\"\n        - \u8981\u907f\u5f00\u4e2d\u95f4deadend state\n        - \u6709\u70b9\u50cftree,\u4f46\u662f\u6709\u4e9b\u8def\u88ab\u5c01\u6389\u4e86\n        \"\"\"\n        def bfs(lock):\n            \"\"\"\n            return a list of next state, if input is '0000'\n            output is ['0001','0009','0010','0090',......]\n            \"\"\"\n            res = []\n            for i in range(4):\n                digit_increment = lock[:i] + str((int(lock[i]) + 1 + 10)%10) + lock[i+1:]\n                res.append(digit_increment)\n                digit_decrement = lock[:i] + str((int(lock[i]) - 1 + 10)%10) + lock[i+1:]\n                res.append(digit_decrement)\n            return res\n\n        # edge case\n        if '0000' in deadends:\n            return -1\n\n        q = collections.deque()\n        # lock stack, turn\n        q.append(['0000',0])\n        visited = set(deadends)\n\n        while q:\n            state,turn = q.popleft()\n            # base case\n            if state == target:\n                return turn            \n            # doing BFS\n            for child in bfs(state):\n                if child not in visited:\n                    visited.add(child)\n                    q.append([child,turn+1])\n        # whoops not found\n        return -1\n</code></pre>","tags":["Array","Hash Table","String","Breadth-First Search"]},{"location":"leetcode/76-minimum-window-substring/","title":"Approach 1 Sliding Window","text":"<p>\u5f88classic\u7684sliding window\u7684\u9898\u76ee. \u9996\u5148\u770bconstraints, - <code>- 1 &lt;= s.length, t.length &lt;= 10^5</code></p> <p>\u7531\u6b64\u53ef\u4ee5\u63a8\u65ad\u51fa\uff0c\u8fd9\u4e2a\u9898\u76ee\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u662f<code>O(n)</code>\uff0c\u81f3\u591a\u662f<code>O(nlogn)</code>.</p> <p>\u56e0\u6b64\u6211\u4eec\u628a\u91cd\u5fc3\u653e\u5728\u5982\u4f55\u6784\u5efasliding window\u548c\u5de6\u53f3\u6307\u9488\u7684\u79fb\u52a8\u4e0a\uff0c\u5fc5\u987b\u4fdd\u8bc1\u6784\u5efa\u65b9\u6cd5\u80fdtraverse\u6574\u4e2as efficiently. Recall two sum,\u8fd9\u4e9b\u9898\u76ee\u90fd\u662f\u7528hashmap\u6765\u89e3\u51b3\u7684. \u6211\u4eec\u53ef\u4ee5\u7528\u4e24\u4e2ahashmap\u6765\u8bb0\u5f55 - \u6211\u4eec\u9700\u8981\u7684<code>need_hash</code> - \u6211\u4eec\u62e5\u6709\u7684<code>have_hash</code></p> <p>\u5982\u4e0b\u56fe\u6240\u793a <pre><code>have_hash               need_hash\nkey  value              key  value\nA       1               A       1\nB       1               B       1\nD       1               C       1\nE       1               \nO       1\n</code></pre></p> <p>Tip</p> <p>\u7528hashmap\u7684\u539f\u56e0\u662f\uff0c\u6211\u4eec\u9700\u8981\u6267\u884cfind\u7684\u64cd\u4f5c\uff0c\u5728array\u91cc\u9762\uff0cfind\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u662f<code>O(n)</code>\uff0c\u800c\u5728hashmap\u91cc\u9762\u662f<code>O(1)</code>.</p> <p>\u6211\u4eec<code>right</code>\u4e0d\u65ad\u904d\u5386\u524d\u8fdb\uff0c\u6bcf\u6b21\u904d\u5386\u90fd\u4f1a\u66f4\u65b0<code>have_hash</code>\uff0c\u7136\u540e\u53ef\u4ee5\u6bd4\u8f83need_hash\u548chave_hash\u7684\u60c5\u51b5\uff0c\u5982\u679c\u6ee1\u8db3\u6761\u4ef6\uff0c\u6211\u4eec\u5c31\u53ef\u4ee5\u5f00\u59cb\u66f4\u65b0<code>left</code>\u6307\u9488\u4e86. \u4f46\u8fd9\u91cc\u6211\u4eec\u53ef\u4ee5\u7528\u4e24\u4e2a\u53d8\u91cf<code>need</code>\u548c<code>have</code>\u6765\u8bb0\u5f55\u6211\u4eec\u6ee1\u8db3\u7684\u6761\u4ef6\uff0c \u4e0d\u7136\u6bcf\u6b21<code>right++</code>, \u6211\u4eec\u90fd\u9700\u8981\u6bd4\u8f83\u4e24\u4e2ahashmap\u7684\u60c5\u51b5\uff0c<code>O(len(need_hash))</code>\u7684\u65f6\u95f4\u590d\u6742\u5ea6. </p> <p>\u8fd9\u9898\u8ba9\u6211\u5361\u4f4f\u7684\u70b9\u5728\u4e8e\u5de6\u6307\u9488\u7684\u66f4\u65b0\uff0c\u6709\u4ee5\u4e0b\u4e24\u70b9: - <code>\u5de6\u6307\u9488\u4e0d\u9700\u8981back track:</code> \u6309\u7167\u6211\u539f\u6765\u7684\u601d\u8def\uff0c\u6bcf\u6b21<code>right++</code></p>"},{"location":"leetcode/76-minimum-window-substring/#code","title":"Code","text":"<pre><code>class Solution:\n    def minWindow(self, s: str, t: str) -&gt; str:\n        # edge case\n        if len(s) &lt; len(t): return \"\"\n\n        # construct two hashmap to record what we need and have\n        need_hash = collections.defaultdict(int)\n        for char in t:\n            need_hash[char] += 1\n\n        have_hash = collections.defaultdict(int)\n\n        # two integers to record how many conditions we have met so far\n        need,have = len(need_hash),0\n\n        res,res_len = (-1,-1),float(\"infinity\")\n        left = 0\n        for right in range(len(s)):\n            c = s[right]\n            have_hash[c] += 1\n\n            if c in need_hash and have_hash[c] == need_hash[c]:\n                have += 1\n\n            # \u5f00\u59cb\u66f4\u65b0\u5de6\u6307\u9488\n            while have == need:\n                # update our result if current window_size &lt; res_len\n                if (right - left + 1) &lt; res_len:\n                    res = (left, right)\n                    res_len = right - left + 1\n                # pop from the left of our window\n                have_hash[s[left]] -= 1\n                # update hash count\n                if s[left] in need_hash and have_hash[s[left]] &lt; need_hash[s[left]]:\n                    have -= 1\n                # back track\n                left += 1\n\n        left,right = res\n        return s[left:right+1] if res_len != float(\"infinity\") else \"\"\n</code></pre>"},{"location":"leetcode/76-minimum-window-substring/#complexity-analysis","title":"Complexity Analysis","text":"- time complexity space complexity - <code>O(n)</code> <code>O(1)</code>"},{"location":"leetcode/77-combinations/","title":"77 combinations","text":"<p>The decision tree in this case is not symmetric, in each layer, the number of branches decreases by 1.</p> <pre><code>class Solution:\n    def combine(self, n: int, k: int) -&gt; List[List[int]]:\n        res = []\n\n        def backtrack(start,curr):\n            # base case\n            if len(curr) == k:\n                res.append(curr.copy())\n                return\n\n            # \u53ea\u770b\u53f3\u8fb9\u7684\u89e3\uff0cright hand exclusive in python\n            for i in range(start,n+1):\n                curr.append(i)\n                backtrack(i+1,curr)\n                curr.pop()\n\n        # starting from 1\n        backtrack(1,[])\n        return res \n</code></pre>"},{"location":"leetcode/771-jewels-and-stones/","title":"771 Jewels and Stones","text":"","tags":["Hash Table","String"]},{"location":"leetcode/771-jewels-and-stones/#on-time-on-space","title":"O(N) time, O(N) space","text":"<p>Arguably, it's O(1) in space since the lookup set is at most 52 characters (26 alphabets x 2).</p> <pre><code>class Solution:\n    def numJewelsInStones(self, jewels: str, stones: str) -&gt; int:\n        lookup = set(jewels)\n        res = 0\n        for stone in stones:\n            res += 1 if stone in lookup else 0\n        return res\n</code></pre>","tags":["Hash Table","String"]},{"location":"leetcode/78-subsets/","title":"78 subsets","text":"<pre><code>class Solution:\n    def subsets(self, nums: List[int]) -&gt; List[List[int]]:\n        res = []\n\n        subset = []\n        def dfs(i):\n            # base case\n            if i &gt;= len(nums):\n                res.append(subset.copy())\n                return\n\n            # decide to include (goint left)\n            subset.append(nums[i])\n            dfs(i+1)\n\n            # decide not to include\n            subset.pop()\n            dfs(i+1)\n\n        # initiate\n        dfs(0)\n        return res\n</code></pre>"},{"location":"leetcode/78-subsets/#reference","title":"Reference","text":"<ul> <li>https://www.youtube.com/watch?v=CUzm-buvH_8&amp;ab_channel=HuaHua</li> <li>https://www.youtube.com/watch?v=REOH22Xwdkk&amp;ab_channel=NeetCode</li> </ul>"},{"location":"leetcode/79-word-search/","title":"79 Word Search","text":"<p>\u5f88\u7ecf\u5178\u7684\u4e00\u9053backtracking\u7684\u9898\u76ee\uff0c\u8fd9\u9053\u9898\u76ee\u662f\u4e00\u4e2a<code>matrix</code>\u4e2d\u627e\u4e00\u4e2a<code>word</code>\uff0c\u8fd9\u4e2a<code>word</code>\u53ef\u4ee5\u662f\u4efb\u610f\u65b9\u5411\uff0c\u4f46\u662f\u4e0d\u80fd\u91cd\u590d\u4f7f\u7528\u540c\u4e00\u4e2acell.</p> <p></p> <p>Input: board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCCED\"</p> <p>Output: true</p>","tags":["Array","Backtracking","String","Matrix"]},{"location":"leetcode/79-word-search/#approach-1-backtracking","title":"Approach 1: Backtracking","text":"","tags":["Array","Backtracking","String","Matrix"]},{"location":"leetcode/79-word-search/#intuition","title":"Intuition","text":"<p>\u8fd9\u9053\u9898\u76ee\u8ba9\u6211\u60f3\u5230\u8d2a\u5403\u86c7\uff0c\u5f88\u7c7b\u4f3c\uff0c\u5728\u4e00\u4e2arectangle\u4e2d\uff0c\u627e\u5230\u4e00\u4e2aword\uff0c\u8fd9\u4e2aword\u53ef\u4ee5\u662f\u4efb\u610f\u65b9\u5411\uff0c\u4f46\u662f\u4e0d\u80fd\u91cd\u590d\u4f7f\u7528\u540c\u4e00\u4e2acell.</p> <p></p> <p>\u800c\u5728\u8fd9\u91cc\uff0c\u8fd9\u4e2aword\u5c31\u662f\u86c7\uff0c\u800cboard\u5c31\u662f\u8fd9\u4e2arectangle. \u5047\u8bbe\u6211\u4eec\u8981\u627e\u7684<code>word = \"ABCCED\"</code>, \u6211\u4eec\u7b2c\u4e00\u6b65\u4e5f\u5c31\u662f\u627e\u5230\u86c7\u5934\u7684\u4f4d\u7f6e</p> <p></p> <p>\u7136\u540e\u86c7\u600e\u4e48\u6837\u624d\u80fd\u751f\u957f\u5462? \u4e5f\u5c31\u662fstring\u4e2d\u4e0b\u4e00\u4e2achar, \u5728\u6211\u56db\u5468\u7684cell\u4e2d\uff0c\u6709\u6ca1\u6709\u548c\u6211\u4e0b\u4e00\u4e2achar\u76f8\u540c\u7684cell\u5462? \u5982\u679c\u6709\uff0c\u6211\u5c31\u53ef\u4ee5\u751f\u957f\uff0c\u5982\u679c\u6ca1\u6709\uff0c\u8fd9\u91cc\u5c31\u957f\u4e0d\u51fa\u4e00\u6761\u6ee1\u8db3\u6761\u4ef6\u7684\u86c7.</p> <p>\u5177\u4f53\u7684\u601d\u8def\u4e3a:</p> <ul> <li>traverse\u4e00\u904d\u6240\u6709\u7684cell\uff0c\u627e\u5230\u7b2c\u4e00\u4e2a\u548cword\u7684\u7b2c\u4e00\u4e2a\u5b57\u6bcd\u76f8\u540c\u7684cell, \u4e5f\u5c31\u662f\u786e\u5b9a\u86c7\u5934\u7684\u4f4d\u7f6e.</li> <li>\u6bcf\u4e00\u4e2a\u86c7\u5934\uff0c\u5f00\u5c55\u4e00\u4e2arecursive DFS\uff0c\u627e\u5230\u6240\u6709\u7684\u53ef\u80fd\u6027\uff0c\u5982\u679c\u6709\u4e00\u6761\u86c7\u80fd\u591f\u627e\u5230.<ul> <li><code>\u8d2a\u5403\u86c7\u6210\u957f\u6761\u4ef6</code>: \u5728\u86c7\u5934\u7684\u56db\u5468\uff0c\u6709\u4e00\u4e2acell\u548cword\u7684\u4e0b\u4e00\u4e2a\u5b57\u6bcd\u76f8\u540c. \u4e14\u8fd9\u4e2a\u5355\u5143\u4e0d\u80fd\u662f\u86c7\u8eab\u4f53\u5176\u5b83\u90e8\u4f4d(\u8bbf\u95ee\u8fc7).</li> <li><code>\u8d2a\u5403\u86c7\u9635\u4ea1\u6761\u4ef6</code>:</li> <li>\u4e0d\u80fd\u78b0\u5230\u81ea\u8eab</li> <li>\u4e0d\u80fd\u51fa\u754c</li> <li><code>\u8d2a\u5403\u86c7\u80dc\u5229\u6761\u4ef6</code>: \u627e\u5230\u4e86word\u7684\u6700\u540e\u4e00\u4e2a\u5b57\u6bcd</li> </ul> </li> </ul> <p>For those who are a bit nerdy, we could go for a more formal definition of the problem:</p> - - initial condition traverse <p>\u4f20\u7edf\u601d\u7ef4\u65b9\u5f0f:</p> <p>backtracking\u9898\u76ee, \u8111\u888b\u91cc\u5148\u60f3\u51fa\u4e00\u4e2aN\u53c9\u6811\uff0c\u6bcf\u4e00\u4e2a\u6811\u7684node\u4ee3\u8868\u7740\u4e00\u6b21recursive call to <code>dfs function</code>.</p>","tags":["Array","Backtracking","String","Matrix"]},{"location":"leetcode/79-word-search/#dfs","title":"dfs\u51fd\u6570\u8bbe\u8ba1","text":"<p><code>dfs(board, word, i, j, k)</code>: \u4ece<code>board[i][j]</code>\u5f00\u59cb\uff0c\u662f\u5426\u80fd\u591f\u627e\u5230<code>word[k:]</code>\uff0c\u5982\u679c\u4efb\u4f55\u4e00\u6761\u652f\u8def\u80fd\u591f\u627e\u5230\uff0c\u8fd4\u56de<code>True</code>\uff0c\u5426\u5219\u8fd4\u56de<code>False</code></p>","tags":["Array","Backtracking","String","Matrix"]},{"location":"leetcode/79-word-search/#trick","title":"Trick","text":"<p>\u5982\u4f55\u4fdd\u8bc1\u81ea\u5df1\u4e0d\u5403\u56de\u5934\u8349\u5462?</p> <ul> <li>neetcode\u7528\u4e86<code>path = set()</code>, \u6765\u8bb0\u5f55\u5df2\u7ecf\u8bbf\u95ee\u8fc7\u7684cell\uff0c\u6bcf\u4e2acell\u5b58\u6210\u4e00\u4e2atuple, \u4e5f\u5c31\u662f<code>path.add((r,c))</code> where <code>r</code> is row and <code>c</code> is column.</li> <li>\u82b1\u82b1\u9171\u7528\u4e86<code>board[r][c] = 0</code>\uff0c\u628a\u5f53\u524d\u7684cell\u7684\u503c\u6539\u62100\uff0c\u8fd9\u6837\u5c31\u4e0d\u4f1a\u548cword\u4e2d\u7684\u4efb\u4f55\u4e00\u4e2achar\u76f8\u7b49\u4e86.\u522b\u5fd8\u4e86\u8981\u6362\u56de\u6765</li> </ul>","tags":["Array","Backtracking","String","Matrix"]},{"location":"leetcode/79-word-search/#_1","title":"\u590d\u6742\u5ea6\u5206\u6790","text":"<ul> <li><code>time complexity</code>:\\(O(m\\times n \\times 3^{L})\\) where m and n are the number of rows and columns of the board and L is the length of the word to be matched.<ul> <li>\\(m\\times n\\): traverse the board of size m and n.</li> <li>\\(3^{L}\\): for each cell, we have 3 choices to go, except the cell we just came from.</li> </ul> </li> <li><code>space complexity</code>: \\(O(L)\\)<ul> <li>The main consumption of the memory lies in the recursion call of the backtracking function. The maximum length of the call stack would be the length of the word. Therefore, the space complexity of the algorithm is \\(O(L)\\).</li> </ul> </li> </ul>","tags":["Array","Backtracking","String","Matrix"]},{"location":"leetcode/79-word-search/#code-implementation","title":"Code Implementation","text":"<p>\u80dc\u5229\u6761\u4ef6\u53ef\u4ee5\u662f<code>if i == len(word)-1: return True</code> <pre><code>class Solution:\n    def exist(self, board: List[List[str]], word: str) -&gt; bool:\n        # get ROWS and \n        ROWS,COLS = len(board),len(board[0])\n\n        # dfs helper function\n        def dfs(r,c,i):\n            # 1. out of bounds\n            if (r &lt; 0 or c &lt; 0 or r &gt;= ROWS or c &gt;= COLS):\n                return False\n\n            # 2. character not match\n            if word[i] != board[r][c]:\n                return False\n\n            # 3. found the last char\n            if i == len(word) - 1: return True\n\n            temp = board[r][c]\n            # mark the current value as integer, so it is not matching\n            # with any char in the word to prevent revisiting\n            board[r][c] = 0\n\n            res = (dfs(r + 1, c, i + 1) or\n                   dfs(r - 1, c, i + 1) or\n                   dfs(r, c + 1, i + 1) or\n                   dfs(r, c - 1, i + 1))\n\n            board[r][c] = temp\n\n            return res\n\n        for r in range(ROWS):\n            for c in range(COLS):\n                if dfs(r,c,0):\n                    return True\n\n        return False\n</code></pre></p> <p>\u4e5f\u53ef\u4ee5\u662f<code>if i == len(word): return True</code> <pre><code>class Solution:\n    def exist(self, board: List[List[str]], word: str) -&gt; bool:\n        # get ROWS and \n        ROWS,COLS = len(board),len(board[0])\n\n        # dfs helper function\n        def dfs(r,c,i):\n            # 3. found the last char in last iteration\n            if i == len(word): return True\n\n            # 1. out of bounds\n            if (r &lt; 0 or c &lt; 0 or r &gt;= ROWS or c &gt;= COLS):\n                return False\n\n            # 2. character not match\n            if word[i] != board[r][c]:\n                return False\n\n\n            temp = board[r][c]\n            # mark the current value as integer, so it is not matching\n            # with any char in the word to prevent revisiting\n            board[r][c] = 0\n\n            res = (dfs(r + 1, c, i + 1) or\n                   dfs(r - 1, c, i + 1) or\n                   dfs(r, c + 1, i + 1) or\n                   dfs(r, c - 1, i + 1))\n\n            board[r][c] = temp\n\n            return res\n\n        for r in range(ROWS):\n            for c in range(COLS):\n                if dfs(r,c,0):\n                    return True\n\n        return False\n</code></pre></p> <p>\u4e3a\u4ec0\u4e48\u6709\u4fe9\u80dc\u5229\u6761\u4ef6\u5462\uff0c\u4e14offset by one\u5462? \u4f60\u53ef\u4ee5\u601d\u8003\u4e00\u4e0b\u54e6.</p>","tags":["Array","Backtracking","String","Matrix"]},{"location":"leetcode/79-word-search/#reference","title":"Reference","text":"<ul> <li>LC 79 \u82b1\u82b1\u9171</li> <li>neetcode</li> <li>Abdul Bari, introduction to backtracking</li> </ul>","tags":["Array","Backtracking","String","Matrix"]},{"location":"leetcode/791-custom-sort-string/","title":"791 Custom Sort String","text":"","tags":["Hash Table","String","Sorting"]},{"location":"leetcode/791-custom-sort-string/#approach-1-hash-table-heap","title":"Approach 1 Hash Table + Heap","text":"<ul> <li>\u5efa\u7acb\u4e00\u4e2a<code>dict</code>\u6765\u5b58\u50a8order\u4e2d\u7684\u5b57\u7b26\u7684rank, \u4ee5\u53ca\u6c42common characters in both <code>order</code>  and <code>s</code> string</li> <li>one pass scan over the <code>s</code> to compute <code>suffix</code> and <code>prefix</code>. <ul> <li><code>suffix</code> is the characters only in <code>s</code> but not in <code>order</code>, we don't care about the order of them</li> <li><code>prefix</code> is the characters in <code>s</code> and in <code>order</code>, we need to make sure they appear in the order of <code>order</code>, according to the <code>dict</code> we built in the first step. The way to do it is to use a <code>min heap</code> to store the rank of the characters in <code>s</code> and <code>order</code>, and then later pop them out in the order of the rank.</li> </ul> </li> <li>combine <code>prefix</code> and <code>suffix</code> to get the result</li> </ul> <p>Complexity</p> <ul> <li>Time: \\(O(n\\log n)\\) when scanning over <code>s</code> to build <code>heap</code></li> <li>Space: \\(O(m + n)\\)</li> </ul> <p>where \\(n\\) is the length of <code>s</code>, and \\(m\\) is the length of <code>order</code></p> <pre><code>from collections import defaultdict\nfrom heapq import heapify,heappush,heappop\nclass Solution:\n    def customSortString(self, order: str, s: str) -&gt; str:\n        # for those char appeared in both order and s, we need to make sure they appear in those order.\n        # brute force :\n        \"\"\"\n        1. find the common characters in both order and s (thinking hash set)\n        2. order those common characters , call it common, first\n        3. append (s - common) to it\n        \"\"\"\n        # for \"cba\", rank(c) as 1, rank(a) as len(\"cba\")\n        order_map = dict()\n        order_set = set()\n        for rank, char in enumerate(order):\n            order_map[char] = rank\n            order_set.add(char)\n\n        # find the common chars\n        common_chars = order_set.intersection(set(s))\n\n        # two pass\n        # 1. to get the char in common char\n        # 2. get the char only in s but not in order\n        prefix = []\n        suffix = []\n        heap = []\n        for c in s:\n            # if in both then\n            if c in common_chars and c in order_map:\n                rank = order_map[c]\n                heappush(heap,(rank,c))\n            else:\n                suffix.append(c)\n\n        while heap:\n            _,curr = heappop(heap)\n            prefix.append(curr)\n\n        return \"\".join(prefix+suffix)\n</code></pre>","tags":["Hash Table","String","Sorting"]},{"location":"leetcode/791-custom-sort-string/#approach-2-frequency-table-and-counting","title":"Approach 2 Frequency Table and Counting","text":"<p>\u601d\u8def\u662f\u4e00\u6837\u7684\uff0c\u4f46\u662f\u8fd9\u6b21\u7528<code>Counter</code>\u6765\u505a\uff0c\u66f4\u52a0\u7b80\u6d01, </p> <ul> <li>\u7528<code>Counter</code>\u6765\u7edf\u8ba1<code>s</code>\u4e2d\u6bcf\u4e2a\u5b57\u7b26\u7684\u9891\u7387</li> <li>one-pass scan the <code>order</code>, if the character is in counter, then append it to <code>prefix</code> x times, where x is the frequency of the character in <code>s</code>, i.e. <code>counter[c]</code></li> <li>one-pass scan the <code>counter</code>, if the character is not in <code>order</code> (use a hashset for faster lookup), then append it to <code>suffix</code> x times, where x is the frequency of the character in <code>s</code>, i.e. <code>counter[c]</code></li> </ul> <p>Complexity</p> <ul> <li>Time: \\(O(n)\\) in building <code>counter</code>, O(26) in both linearly scanning <code>order</code> and <code>counter</code></li> <li>Space: \\(O(26)\\) for counter, prefix + suffix takes \\(O(n)\\), O(26) for order_set</li> </ul> <p>where \\(n\\) is the length of <code>s</code>.</p> <pre><code>from collections import Counter\nclass Solution:\n    def customSortString(self, order: str, s: str) -&gt; str:\n        \"\"\"\n        1. Counter(s)\n        {\n            \"a\": 2,\n            \"c\": 1,\n            \"d\": 2,\n            ...\n        }\n        2. one-pass to generate prefix for common chars\n        3. one-pass to generate prefix for non-common chars\n        \"\"\"\n        counter = Counter(s)\n\n\n        prefix = []\n        for c in order:\n            if c in counter:\n                frequencies = counter[c]\n                prefix += [c] * frequencies\n\n        suffix = []\n        order_set = set(order)\n        for c in counter:\n            if c not in order_set:\n                frequencies = counter[c]\n                suffix += [c] * frequencies\n\n        return \"\".join(prefix+suffix)\n</code></pre> <p>Clean the method up a little bit and write it pythonic</p> <pre><code>from collections import Counter\nclass Solution:\n    def customSortString(self, order: str, s: str) -&gt; str:\n        \"\"\"\n        1. Counter(s)\n        {\n            \"a\": 2,\n            \"c\": 1,\n            \"d\": 2,\n            ...\n        }\n        2. one-pass to generate prefix for common chars\n        3. one-pass to generate prefix for non-common chars\n        \"\"\"\n        # O(n), n length of s\n        counter = Counter(s)\n\n        # O(m), m length of order\n        prefix = [c * counter[c] for c in order if c in counter]\n\n        # O(k), k is the number of unique chars in \"s\", worst case degenrates to O(n), when char in s is all unique\n        order_set = set(order)\n        suffix = [c * freq for c,freq in counter.items() if c not in order_set]\n\n        return \"\".join(prefix+suffix)\n</code></pre>","tags":["Hash Table","String","Sorting"]},{"location":"leetcode/85-maximal-rectangle/","title":"85 Maximal Rectangle","text":"<p>\u548c84 largest rectangle in histogram\u7b97\u662f\u59d0\u59b9\u9898\u4e86. \u8fd9\u9898\u8fd8\u6ca1\u5b8c\u5168\u5403\u900f\uff0c\u9700\u8981\u518d\u770b\u770b\u3002</p>","tags":["Array","Matrix","Dynamic Programming","Monotonic Stack","Stack"]},{"location":"leetcode/85-maximal-rectangle/#approach-1-dp","title":"Approach 1 DP","text":"<p>\u4e3a\u4e86\u8ba1\u7b97\u9762\u79ef\u6700\u5927\u7684\u77e9\u9635\uff0carea = width * height. \u6211\u4eec\u6709\u4e24\u79cd\u65b9\u6cd5\u6c42:</p> <ul> <li>\u4fdd\u5b58\u6bcf\u4e2a\u70b9\u7684\u6700\u5927\u9ad8\u5ea6\uff0c\u7136\u540e\u8fed\u4ee3\u6240\u6709\u53ef\u80fd\u7684\u5bbd\u5ea6</li> <li>\u4fdd\u5b58\u6bcf\u4e2a\u70b9\u7684\u6700\u5927\u5bbd\u5ea6\uff0c\u7136\u540e\u8fed\u4ee3\u6240\u6709\u53ef\u80fd\u7684\u9ad8\u5ea6</li> <li>\u679a\u4e3e\u6240\u6709\u53ef\u80fd\u6027(\u66b4\u529b\u89e3)</li> </ul> <p>\u8fd9\u91cc\u6211\u4eec\u9009\u62e9\u7b2c\u4e8c\u79cd\u65b9\u6cd5\uff0c\u4fdd\u5b58\u5bbd\u5ea6.</p> <p><code>dp[i][j]</code> is defined as the maximum width of the rectangle that ends at <code>(i,j)</code>.</p> <p>It's state transition function is </p> \\[ \\begin{equation} \\text{{dp}}[i][j] = \\begin{cases}  0 &amp; \\text{if } \\text{{matrix}}[i][j] = \"0\" \\\\ 1 &amp; \\text{if } j = 0 \\text{ (i.e., first column)} \\\\ \\text{dp}[i][j-1] + 1 &amp; \\text{otherwise} \\\\ \\end{cases} \\end{equation} \\] <p>Tip</p> <p>\u6709\u65f6\u5019\uff0cdp\u7684\u5b9a\u4e49\u4e0d\u4e00\u5b9a\u662f\u6700\u7ec8\u7684\u7b54\u6848\uff0c\u4f46\u662f\u53ef\u4ee5\u5e2e\u52a9\u6211\u4eec\u627e\u5230\u6700\u7ec8\u7684\u7b54\u6848\u3002\u8fd9\u91cc\u7684<code>dp[i][j]</code>\u662f\u6700\u5927\u5bbd\u5ea6\uff0c\u4f46\u662f\u6700\u7ec8\u7684\u7b54\u6848\u662f\u9762\u79ef\uff0c\u6240\u4ee5\u6211\u4eec\u8981\u5728dp\u7684\u57fa\u7840\u4e0a\uff0c\u518d\u6b21\u8ba1\u7b97\u9762\u79ef\u3002\u6211fell into the trap of \u60f3\u76f4\u63a5\u5b9a\u4e49<code>dp[i][j]</code>\u4e3a\u9762\u79ef\uff0c\u4f46\u662f\u8fd9\u6837\u7684\u8bdd\uff0c<code>dp[i][j]</code>\u7684\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b\u5c31\u65e0\u6cd5\u5b9a\u4e49\u4e86.</p> <p>\u63a5\u4e0b\u6765\uff0c\u5728\u6bcf\u4e00\u4e2atime step, \u6211\u4eec\u9700\u8981\u5f80\u4e0atraversal to calculate the histogram, \u5982\u4e0b\u56fe.</p> <p>\u8fd9\u662f\u4e00\u4e2a\u8d8a\u5f80\u4e0a\uff0cwidth\u6761\u4ef6\u8d8a\u4e25\u82db\u7684\u95ee\u9898\uff0c\u6240\u4ee5\u6211\u4eec\u8981\u5728\u6bcf\u4e00\u4e2atime step, \u66f4\u65b0width\u7684\u503c\uff0c\u53d6\u6700\u5c0f\u503c,\u9ad8\u5ea6\u5219\u9012\u51cf\u3002</p> <p>\u590d\u6742\u5ea6\u5206\u6790</p> <ul> <li>time complexity: \\(O(m^2n)\\), \u7531\u4e8e\u6211\u4eec\u9700\u8981\u5f80\u4e0atraverse\u4e00\u4e2a<code>len(matrix)</code>. </li> <li>space complexity: \\(O(mn)\\).</li> </ul>","tags":["Array","Matrix","Dynamic Programming","Monotonic Stack","Stack"]},{"location":"leetcode/85-maximal-rectangle/#code-implementation","title":"Code Implementation","text":"<pre><code>class Solution:\n    def maximalRectangle(self, matrix: List[List[str]]) -&gt; int:\n        \"\"\"\n        dp[i][j]: maximum width ends at (i,j).\n        state transition function:\n            dp[i][j] = 0 if matrix[i][j] = \"0\"\n                     = 1 if j == 0 i.e. first column\n                     = dp[i][j-1] + 1 otherwise        \n        \"\"\"\n        maxarea = 0\n        m,n = len(matrix),len(matrix[0])\n\n        dp = [[0 for _ in range(n)] for _ in range(m)]\n\n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == \"0\":\n                    continue\n                # consecutive width so far\n                # j==0,\u7b2c\u4e00\u5217\u4e3a0\n                if j:\n                    width = dp[i][j-1] + 1\n                    dp[i][j] = dp[i][j-1] + 1\n                else:\n                    dp[i][j] = width = 1\n                # width = dp[i][j] = dp[i][j-1] + 1 if j else 1\n\n                # \u5f80\u4e0a\u8ba1\u7b97histogram\n                # height: i-k+1\n                for k in range(i,-1,-1):\n                    # \u8d8a\u5f80\u4e0a\uff0cwidth\u6761\u4ef6\u8d8a\u4e25\u82db\n                    width = min(width,dp[k][j])\n                    maxarea = max(maxarea,width * (i-k+1))\n        return maxarea\n</code></pre>","tags":["Array","Matrix","Dynamic Programming","Monotonic Stack","Stack"]},{"location":"leetcode/85-maximal-rectangle/#approach-2-dp-maximum-height","title":"Approach 2 DP maximum height","text":"","tags":["Array","Matrix","Dynamic Programming","Monotonic Stack","Stack"]},{"location":"leetcode/862-shortest-subarray-with-sum-at-least-K/","title":"862 Shortest Subarray with Sum at Least K","text":"<p>Prefix Sum + Monotonic Queue. \u662f209 Minimum Size Subarray\u7684follow-up. 209\u9898\u56e0\u4e3a\u5168\u662f\u6b63\u6570\u6570\u7ec4\uff0c\u53ef\u4ee5\u7528sliding window. \u5f53\u4f60\u7684\u6570\u7ec4\u4e2d\u5b58\u5728\u8d1f\u6570\u7684\u65f6\u5019\uff0c\u4f60\u5c31\u65e0\u6cd5\u7528sliding window\u4e86\u3002\u8fd9\u4e2a\u65f6\u5019\u5c31\u9700\u8981\u7528monotonic queue\u4e86.</p>","tags":["Array","Prefix Sum","Monotonic Queue","Sliding Window"]},{"location":"leetcode/862-shortest-subarray-with-sum-at-least-K/#approach-1-monotonic-queue","title":"Approach 1 Monotonic Queue","text":"<p>\u5206\u6210\u4ee5\u4e0b\u51e0\u6b65:</p> <ul> <li>pre-processing <code>nums</code>, \u6216\u8005prefix sum\u7684\u6570\u7ec4\uff0c\u522b\u5fd8\u4e86left padding zero</li> <li>\u7ef4\u62a4\u4e00\u4e2amonotonically increasing queue, linear scan <code>prefix_sum</code> array, \u5bf9\u6bcf\u4e00\u4e2a\u65b0\u6765\u7684prefix_sum, \u8fdb\u884c\u5224\u5b9a<ul> <li><code>\u53f3\u51fa</code>: \u4fdd\u8bc1queue\u7684\u4e25\u683c\u5355\u8c03\u9012\u589e. \u6807\u51c6\u7684\u5355\u8c03\u961f\u5217\u64cd\u4f5c</li> <li><code>\u5de6\u51fa</code>: \u5224\u65adqueue\u4e2d\u7684\u5143\u7d20\u548c\u65b0\u6765\u7684prefix_sum\u7684\u5dee\u503c\u5927\u4e8e\u7b49\u4e8ek\uff0c\u4e00\u76f4\u5faa\u73af\u5230\u6240\u6709\u7b26\u5408\u6761\u4ef6\u7684\u90fdpop\u51fa\u53bb.\u8fd9\u4e00\u6b65\u6709\u51e0\u70b9\u8981\u6ce8\u610f:<ul> <li>window size = \u53f3\u8fb9\u65b0\u6765\u7684index - \u5de6\u8fb9pop\u51fa\u53bb\u7684index (\u76ee\u524d\u6700\u5c0f\u7684)</li> <li>monotonic queue\u4e2d\u7ef4\u62a4\u7684\u662fprefix_sum\u7684index, \u90a3\u4e48\u53ea\u53ef\u80fd\u662f[1,2,3] \u6216\u8005[2]. \u4e0d\u5b58\u5728\u5927\u7684index\u5728\u524d\u9762\uff0c\u5c0f\u7684index\u5728\u540e\u9762\u7684\u60c5\u51b5.</li> <li>\u867d\u7136\u7b2c\u4e00\u4e2a<code>\u5de6\u51fa</code>\u7684\u6700\u5c0f\u7684\uff0c\u90a3\u4e48right - left\u53cd\u800c\u662f\u6700\u5927\u7684. \u6211\u4eec\u8fd8\u6709\u4e2a<code>while</code>\u5462\uff0c\u603b\u4f1a\u9047\u5230\u7684?</li> <li>\u5982\u679c\u6211\u4eecpopleft()\u4e86\uff0c\u4ee5\u540e\u7684array\u7528\u5230\u600e\u4e48\u529e? \u4e0d\u53ef\u80fd\uff0c\u6211\u4eec\u4ee5\u540e\u9047\u5230\u7684\uff0c\u53f3\u8fb9\u754c\u90fd\u4f1a\u6bd4curr right\u8981\u5927\uff0c\u6240\u4ee5window size\u4e5f\u4f1a\u5927. \u7b97\u8fc7\u5c31\u6254\u6389.</li> </ul> </li> </ul> </li> </ul> <p>Warning</p> <p>\u5173\u952e\u5728\u4e8e\u60f3\u660e\u767d\u4e3a\u4ec0\u4e48\u53ef\u4ee5<code>\u5de6\u51fa</code>, \u53ea\u8981\u6709\u7b26\u5408\u6761\u4ef6\u7684right - left, \u6211\u4eec\u5c31\u8ba1\u7b97window size\u4e86\u3002\u4e4b\u540eleft\u5c31\u53ef\u4ee5\u6254\u6389\u4e86\uff0c\u56e0\u4e3a\u518d\u5f80\u540e\u9047\u5230\u7684right\u90fd\u4f1a\u6bd4\u73b0\u5728\u7684right\u5927\uff0c\u6240\u4ee5window size\u4e5f\u4f1a\u5927.</p> <pre><code>from collections import deque\nclass Solution:\n    def shortestSubarray(self, nums: List[int], k: int) -&gt; int:\n        # pre-processing an array, with left padding zero\n        n = len(nums)\n        prefix_sum = [0]\n        curr_sum = 0\n        for num in nums:\n            curr_sum += num\n            prefix_sum.append(curr_sum)\n\n        # small,big,very big \n        # monotonically increasing queue, \u4fdd\u6301\u6700\u5c0f\u7684\u5728\u5de6\u8fb9\n        # \u91cc\u9762\u50a8\u5b58\u7684\u662f\u7b26\u5408\u6761\u4ef6\u7684prefix sum\u7684index\n        # cuz k &gt; 0, \u6211\u4eec\u5e0c\u671b\u53f3\u8fb9\u7684prefix\u8d8a\u5927\u8d8a\u597d\uff0c\u5de6\u8fb9\u7684\u8d8a\u5c0f\u8d8a\u597d\n        res = n+1\n        queue = deque()\n\n        for i,curr_sum in enumerate(prefix_sum):\n            # \u53ea\u8981\u6211\u961f\u5217\u91cc\u6709\u6bd4\u8fd9\u4e2a\u65b0\u6765\u7684\u8fd9\u4e2a\u6570pre_i\u5927\u7684\uff0c\u7edf\u7edfpop\u8d70\uff0c\u4fdd\u6301\u4ece\u5de6\u5230\u53f3\u662f\u4ece\u5c0f\u5230\u5927\u7684\n            while queue and curr_sum &lt;= prefix_sum[queue[-1]]: # right out\n                queue.pop()\n\n            # \u628a\u7b26\u5408\u6761\u4ef6\u7684\uff0c\u90fd\u8bb0\u5f55\u4e00\u904d\n            # \u6761\u4ef6\u662f: pre_i - \u5355\u8c03\u961f\u5217\u7684\u6700\u5c0f\u503c\n            while queue and curr_sum - prefix_sum[queue[0]] &gt;= k: # left out\n                res = min(res,i - queue.popleft())\n\n            queue.append(i)\n\n        return res if res != n+1 else -1\n</code></pre>","tags":["Array","Prefix Sum","Monotonic Queue","Sliding Window"]},{"location":"leetcode/873-length-of-longest-fibonacci-subsequence/","title":"Approach 1: Bottom-up, linear space, <code>DP[i][j]</code> ending on","text":"<p>For this question, it is asked to find the length of the fib sequences. It does not ask for subarray where elements have to be continuous. It is a strong indicator that it requires a 2D array, just like LIS.</p> <ul> <li><code>base case</code>:</li> <li><code>DP[i][j]</code>: length of longest fibonacci subsequence ending on <code>arr[i], arr[j]</code></li> <li><code>initialization</code>: \u5168\u90e8\u521d\u59cb\u53162, \u56e0\u4e3a\u53ea\u8981\u8fde\u6210\u4e09\u4e2a\uff0c2 + 1 = 3\uff0c \u5982\u679c\u6700\u540ereturn\u7684\u662f2, \u5c31\u8bf4\u660e\u6ca1\u6709\u627e\u5230\u4efb\u4f55fib-like sequence</li> <li><code>transition function</code>:</li> </ul> <p>Let'see an en example <code>arr = [1,2,3,4,5]</code>, \u5176\u5b9e\u8fd9\u662f\u4e2asparse matrix, \u7531\u4e8e\u9650\u5236\u6761\u4ef6 \\(arr[i]&lt;arr[j]\\), \u521d\u59cb\u5316\u540e\u5982\u4e0b\u8868</p> - 1 2 3 4 5 1 - 2 2 2 2 2 - - 2 2 2 3 - - - 2 4 4 - - - - 2 5 - - - - - <p>\u8fd9\u65f6\u5019\u4f60\u9700\u8981update\u4fe1\u606f, \u8fd9\u65f6\u5019\u4f60\u53ea\u9700\u8981\u627e \\(target = arr[j] - arr[i]\\) \u662f\u5426\u8fd9\u4e2a\u6570\u7ec4\u5b58\u5728\\(arr[k] = target\\) \u4e14\u6ee1\u8db3 \\(arr[k] &lt; arr[i] &lt; arr[j]\\)\u7684\u89c4\u5f8b\u5373\u53ef</p> - 1 2 3 4 5 1 - 2 2 2 2 2 - - 3 2 2 3 - - - 3 4 4 - - - - 1 5 - - - - -"},{"location":"leetcode/873-length-of-longest-fibonacci-subsequence/#algorithm","title":"Algorithm","text":""},{"location":"leetcode/873-length-of-longest-fibonacci-subsequence/#code","title":"Code","text":"<pre><code>class Solution:\n    def lenLongestFibSubseq(self, arr: List[int]) -&gt; int:\n        # DP[i][j]: length of longest fibonacci subsequence ending on arr[i], arr[j]\n        # for example: arr = [1,3,7,11,12,14,18], DP[3][4] = 3; [1,11,12] = [arr[0],arr[3],arr[4]]\n\n        fib_hash = {}\n\n        # create a hash for look up\n        for i in range(len(arr)):\n            fib_hash[arr[i]] = i\n\n        # initialze 2D array\n        DP = [[2 for _ in range(len(arr))] for _ in range(len(arr))]\n\n        for j in range(len(arr)):\n            for i in range(j):\n                target = arr[j] - arr[i] # k\u589e\u52a0,arr[k]\u589e\u52a0,target\u5355\u8c03\u9012\u589e\n                # target &lt; arr[i] &lt; arr[j]\n                if target &lt; arr[i] and target in fib_hash:\n                    k = fib_hash[target]\n                    DP[i][j] = DP[k][i] + 1\n\n        ans = max([max(value) for value in DP])\n\n        return ans if ans &gt;= 3 else 0\n</code></pre>"},{"location":"leetcode/875-koko-eating-bananas/","title":"875 Koko Eating Bananas","text":"\u6700\u5927\u6536\u83b7! <p>\u8fd9\u9898\u6211\u5b66\u5230\u6700\u5927\u7684\u662f, \u91cd\u70b9\u5728\u4e8e\u66f4\u65b0\u6761\u4ef6\u7684\u8bbe\u5b9a, \u5982\u4e0b. <pre><code>if hours &lt;= h:\n    # koko need to eat slower (less aggressive)\n    right = mid\nelse:\n    # koko should eat faster\n    left = mid + 1\n</code></pre> \u6240\u6709hours &lt;= h\u7684\u60c5\u51b5\uff0ckoko\u90fd\u80fd\u5403\u5b8c\uff0c\u6240\u4ee5\u5728\u8fd9\u91cc\u66f4\u65b0\u6761\u4ef6\u53ef\u4ee5less aggressive, \u8bf4\u4e0d\u5b9a\u7b54\u6848\u5c31\u5728\u8fb9\u754c\u5462. \u4f46\u5bf9\u4e8ehours &gt; h\u7684\u60c5\u51b5\uff0ckoko\u5c31\u5403\u4e0d\u5b8c\u4e86\uff0c\u6240\u4ee5\u8981\u66f4aggressive, \u5fc5\u987b\u5403\u5feb\u70b9\u554a\uff0cmid\u662f\u4e00\u5b9a\u6ee1\u8db3\u4e0d\u4e86\u6761\u4ef6\u7684.</p>","tags":["Array","Binary Search"]},{"location":"leetcode/875-koko-eating-bananas/#approach-1-binary-search","title":"Approach 1 Binary Search","text":"<p>koko\u5403\u9999\u8549\u7684\u901f\u5ea6\uff0c\u6700\u6162\u662f1\uff0c\u6700\u5feb\u662fmax(piles), \u4e4b\u540e\u518d\u5feb\u4e5f\u5f97\u7b49\u7740\uff0cdiminishing return. \u4e4b\u540e\u6211\u4eec\u53ef\u4ee5\u7528binary search\u6765\u627e\u5230\u6700\u5c0f\u7684k\u6ee1\u8db3\u5403\u5b8c\u9999\u8549\u7684\u603b\u65f6\u95f4\u4e0d\u8d85\u8fc7h. \u6211\u4eec\u6240\u6709\u7684valid solution\u4e2d\uff0c\u627e\u5230\\(k_{min}\\) such that:</p> \\[ \\begin{align*} \\sum_{i=0}^{n-1} \\lceil \\frac{piles[i]}{k} \\rceil \\leq h \\quad k \\in \\mathbb{Z}^{+}\\\\ \\sum_{i=0}^{n-1} \\lceil \\frac{piles[i]}{k_{min}} \\rceil = h \\\\ \\end{align*} \\] <pre><code>import math\nclass Solution:\n    def minEatingSpeed(self, piles: List[int], h: int) -&gt; int:\n        # \u7531\u4e8ediminishing return, \u6700\u5feb\u5403\u5b8c\u662f\u901f\u5ea6K = max(piles), \u4e4b\u540e\u518d\u5feb\u4e5f\u5f97\u7b49\u7740\n        # \u6700\u6162\u901f\u5ea6\u4e3ak = 1\n        # \u8981\u6c42, \u6700\u5c0f\u7684k\u6ee1\u8db3 sum([ceil(pile/k) for pile in piles]) == h\n        # O(nlogn) + O(nlogn)\n\n        # piles.sort()\n        left,right = 1,max(piles)\n\n        while left &lt; right:\n            mid = (left + right)//2\n            hours = sum([math.ceil(pile/mid) for pile in piles])\n            # print(f\"{mid} {hours}\")\n            if hours &lt;= h:\n                # koko need to eat slower (less aggressive)\n                right = mid\n            else:\n                # koko should eat faster\n                left = mid + 1\n\n        return left\n</code></pre>","tags":["Array","Binary Search"]},{"location":"leetcode/876-middle-of-the-linked-list/","title":"876 Middle of the Linked List","text":"<p>\u8fd9\u9898\u4e24\u79cd\u505a\u6cd5:</p> <ul> <li>\u4e24\u4e2apointer <code>fast</code> and <code>slow</code>, slow\u8d70\u4e00\u6b65, fast\u8d70\u4e24\u6b65, \u4fdd\u8bc1fast\u8d70\u5230\u5c3d\u5934\u7684\u65f6\u5019, slow\u8d70\u5230\u4e2d\u95f4</li> <li>\u5148\u6570\u4e00\u904dlinked list\u7684\u957f\u5ea6, \u7136\u540e\u518d\u8d70\u4e00\u904d\u627e\u5230\u4e2d\u95f4</li> </ul> <p>Anecdote</p> <p>2023\u5e74\u7684\u6211\u60f3\u51fa\u65b9\u6cd52\uff0c2024\u5e74\u7684\u6211\u60f3\u51fa\u65b9\u6cd51. Slowly, but getting better</p> <p>\u4fe9\u7b97\u6cd5\u590d\u6742\u5ea6\u90fd\u4e00\u6837\uff0c\u90fd\u662f\\(O(n)\\) in time, \\(O(1)\\) in space. \u53ea\u4e0d\u8fc7\u65b9\u6cd51 is cleaner and one-pass while \u65b9\u6cd52 is two-pass.</p>","tags":["Linked List","Two Pointers"]},{"location":"leetcode/876-middle-of-the-linked-list/#approach-1-two-pointers","title":"Approach 1: Two pointers","text":"<p>\u8003\u8651\u4fe9edge cases:</p> <ul> <li>\u5982\u679clinked list\u4e3a\u7a7a, \u90a3\u4e48\u76f4\u63a5\u8fd4\u56de</li> <li>\u5982\u679clinked list\u53ea\u6709\u4e00\u4e2anode, \u90a3\u4e48\u76f4\u63a5\u8fd4\u56de</li> </ul> <p>\u4e4b\u540e\u8ba8\u8bba\u7684\u90fd\u662flinked list\u6709\u81f3\u5c11\u4e24\u4e2anode\u7684\u60c5\u51b5. \u5982\u679cfor every fast advances two, slow advanced one, when it's odd, <code>fast.next == None</code>, when it's even, <code>fast == None</code></p> <pre><code># Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def middleNode(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:\n        if not head:\n            return \n        if not head.next:\n            return head\n\n        slow = fast = head\n\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n\n        return slow\n</code></pre>","tags":["Linked List","Two Pointers"]},{"location":"leetcode/876-middle-of-the-linked-list/#approach-2-count-the-length-of-the-linked-list","title":"Approach 2: Count the length of the linked list","text":"<pre><code># Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n\nclass Solution:\n    def get_length(self, head):\n        \"\"\"\n        return the total length of the linekd list\n        \"\"\"\n        length = 0\n        probe = head\n        while probe != None:\n            length += 1\n            probe = probe.next\n        return length\n\n    def middleNode(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:\n\n        # \u8ba1\u7b97linked list\u7684\u603b\u957f\u5ea6\n        total_length = self.get_length(head)         \n\n        # \u65e0\u8bba\u5947\u6570\u8fd8\u662f\u5076\u6570\uff0c\u7528floor division\u90fd\u80fd\u4e00\u6837\u5904\u7406\n        probe = head\n        mid_index = total_length//2\n        counter = 0\n        while counter &lt; mid_index:\n            probe = probe.next\n            counter += 1\n\n        return probe\n</code></pre>","tags":["Linked List","Two Pointers"]},{"location":"leetcode/881-boats-to-save-people/","title":"881 Boats to Save People","text":"","tags":["Two Pointers","Greedy"]},{"location":"leetcode/881-boats-to-save-people/#approach-1-greedy","title":"Approach 1: Greedy","text":"<p>\u8981\u627e\u5230\u6700\u5c0f\u6570\u91cf\u7684\u8239\u6765\u88c5\u6240\u6709\u7684\u4eba\uff0c\u6709\u4e24\u4e2aconstraints</p> <ul> <li>\u4e00\u8258\u8239\u6700\u591a\u53ea\u80fd\u88c5\u4e24\u4e2a\u4eba</li> <li>\u4e00\u8258\u8239\u7684\u6700\u5927\u8f7d\u91cd\u662f <code>limit</code></li> </ul> <p>\u6240\u4ee5\u662f\u4e00\u4e2a\u6709constraints\u7684optimization\u95ee\u9898\uff0c\u6709\u4e24\u79cd\u53ef\u80fd\u6027</p> <ul> <li>greedy</li> <li>dp</li> </ul> <p>\u90a3\u4e48\u6211\u4eec\u9700\u8981\u5728\u6bcf\u641c\u8239\u4e2d\u5c3d\u53ef\u80fd\u591a\u7684\u88c5\u4eba\u548c\u5c3d\u53ef\u80fd\u591a\u7684\u91cd\u91cf\uff0c\u6240\u4ee5\u6211\u4eec\u9996\u5148\u60f3\u5230\u7684\u662f\u7c7b\u4f3c\u4e8e\u9ad8\u65af\u7b97\u6cd5, </p> <pre><code>1 2 3 4 5 6 7 8 9 10 = 55\n</code></pre> <p>\u6211\u4eecsort()\u4e4b\u540e\uff0c\u6700\u91cd\u7684\u4eba\u548c\u6700\u8f7b\u7684\u4eba\u4e00\u8d77\u5750\u8239\uff0c\u5982\u679c\u4ed6\u4eec\u7684\u91cd\u91cf\u5c0f\u4e8e\u7b49\u4e8elimit\uff0c\u90a3\u4e48\u4ed6\u4eec\u4e00\u8d77\u5750\u8239\uff0c\u5426\u5219\u6700\u91cd\u7684\u4eba\u53ea\u80fd\u81ea\u5df1\u5750\u8239\u3002\u8fd9\u4e2a\u7ed9\u4e88\u6211\u4eec\u7684\u601d\u8def\u662f:</p> <ul> <li>\u6700\u91cd\u7684\u4eba\uff0c\u5982\u679c\u548c\u5f53\u524d\u6700\u8f7b\u7684\u4eba\u4e00\u641c\u8239\u90fd\u88c5\u4e0d\u4e0b\uff0c\u90a3\u4e48\u6700\u91cd\u7684\u4eba\u53ea\u80fd\u81ea\u5df1\u5750\u8239.</li> <li>\u6700\u8f7b\u7684\u4eba\uff0c\u5982\u679c\u90fd\u80fd\u548c\u6700\u91cd\u7684\u4eba\u4e00\u8d77\u5750\u8239\uff0c\u90a3\u4e48\u5c31\u80fd\u5339\u914d\u6240\u6709\u4eba, \u90a3\u8fd8\u4e0d\u5982\u5339\u914d\u6700\u91cd\u7684\u4eba.</li> </ul> <p>Warning</p> <p>\u8fd9\u9898\u53ef\u4ee5\u8fd9\u6837\u7406\u89e3\uff0c\u6392\u5e8f\u4e4b\u540e\uff0c\u6bcf\u4e00\u6b65\u5bfb\u627e:</p> <ul> <li>\u5f53\u524d\u6700\u8f7b\u7684\u4eba\u7684\u6700\u4f18\u89e3<ul> <li><code>case 1:</code> \u4e24\u4eba\u5750\u4e0d\u4e0b\uff0c\u5f53\u524d\u6700\u91cd\u7684\u4eba\u7684\u505a\u8fdb\u53bb</li> <li><code>case 2:</code> \u4e24\u4eba\u5750\u5f97\u4e0b\uff0c\u4e24\u4eba\u4e00\u8d77\u5750\u8fdb\u53bb, \u8fdb\u5165\u4e0b\u4e00\u4e2a\u89e3</li> </ul> </li> <li>\u5f53\u524d\u7b2c\u4e8c\u8f7b\u7684\u4eba\u7684\u6700\u4f18\u89e3 (case 1) or \u7ee7\u7eed\u6c42\u89e3\u5f53\u524d\u6700\u8f7b\u7684\u4eba\u7684\u6700\u4f18\u89e3 (case 1)</li> <li>\u91cd\u590d\u4e0a\u8ff0\u6b65\u9aa4\u76f4\u5230\u6240\u6709\u4eba\u90fd\u5750\u8239</li> </ul>","tags":["Two Pointers","Greedy"]},{"location":"leetcode/881-boats-to-save-people/#code-implementation","title":"Code Implementation","text":"<pre><code>class Solution:\n    def numRescueBoats(self, people: List[int], limit: int) -&gt; int:\n        \"\"\"\n        observation:\n        - optimization problem, might be greedy. Each boat need \n        to fill as many people and as many weight as possible\n        - sort\u4e4b\u540etwo pointer, \u5982\u679clightest person\u548cheavist person\u4e00\u8d77\n        \u5750\u8239\uff0c\u90a3\u4e48\u505a; \u5982\u679c\u4e0d\u80fd\uff0c\u90a3\u6700\u540eheavist person\u53ea\u80fd\u81ea\u5df1\u505a.\n        \"\"\"\n        res = 0\n        i,j = 0,len(people)-1\n        people.sort()\n        while i &lt;= j:\n            # lightest + heavist --&gt; value\n            if people[i] + people[j] &lt;= limit:\n                i += 1                \n            # heavist person take your own boat\n            j -= 1\n            res += 1\n\n        return res\n</code></pre>","tags":["Two Pointers","Greedy"]},{"location":"leetcode/887-super-egg-drop/","title":"887 Super Egg Drop","text":"<p>\u8fd9\u4e00\u9898\u76f8\u5f53\u96be\uff0c\u6211\u7684intuition\u662fbinary search, \u8fd9\u6837\u7684\u8bddsolution\u5c31\u5e94\u8be5\u662f\\(O(\\log_2\\left(n\\right))\\). \u4f46\u9898\u76ee\u4e2d\u8fd8\u6709\\(k\\)\u4e2a\u9e21\u86cb\uff0c\u4e0d\u53ef\u80fd\u662f\u6ca1\u7528\u7684\u4fe1\u606f\u3002\u5047\u8bbe\u6211\u4eec\u53ea\u6709\u4e00\u9897\u9e21\u86cb\u7684\u8bdd\uff0c\u6211\u4eec\u6839\u672c\u6ca1\u529e\u6cd5binary search, \u552f\u4e00\u80fd\u591f\u505a\u7684\u7b56\u7565\u5c31\u662f\u4ece\u7b2c\u4e00\u5c42\u5f00\u59cb\uff0c\u4e00\u5c42\u4e00\u5c42\u7684\u8bd5\uff0c\u76f4\u5230\u9e21\u86cb\u788e\u4e86\u3002\u8fd9\u6837\u7684\u8bdd\uff0c\u6211\u4eec\u7684solution\u5c31\u662f\\(O(n)\\). \u4f60\u53ef\u4ee5\u628a\u9e21\u86cb\u60f3\u8c61\u6210\u4f60\u6709\u7684\u8d44\u4ea7\uff0c\u4f60\u6295\u8d44\u7684\u7b56\u7565\u6709\u4e24\u4e2a\u6781\u7aef:</p> <ul> <li>\u6781\u7aef\u4fdd\u5b88: \u4e00\u5c42\u4e00\u5c42\u7684\u8bd5\uff0c\u76f4\u5230\u9e21\u86cb\u788e\u4e86\uff0c\u4e5f\u5c31\u786e\u8ba4\u4e86. \u6548\u7387\u4f4e\u4f46\u4fdd\u9669\uff0c\u6700\u591a\u53ea\u635f\u5931\u4e00\u9897\u9e21\u86cb.</li> <li><code>binary search</code>: \u4e8c\u5206\u6cd5\uff0c\u6bcf\u6b21\u8bd5\u4e00\u534a\uff0c\u76f4\u5230\u627e\u5230\u7b54\u6848, \u6548\u7387\u6781\u5176\u9ad8, \u635f\u5931\u9e21\u86cb\u6570\u91cf\u5728\u6700\u574f\u60c5\u51b5\u4e0b\u662f\\(\\log_2\\left(n\\right)\\).</li> </ul> <p>\u968f\u7740\u7ed9\u4e88\u4f60\u7684<code>(k,n)</code>, \u4f60\u7684\u7b56\u7565\u5e94\u8be5\u662f\u5728\u8fd9\u4e24\u4e2a\u6781\u7aef\u4e4b\u95f4\u627e\u5230\u4e00\u4e2a\u5e73\u8861\u70b9. \u6240\u4ee5\u8fd9\u4e00\u9898\u53c8\u662f\u4e00\u4e2a\u4f18\u5316\u7684\u95ee\u9898</p> <p>Tip</p> <p>\u8d44\u4ea7\u8d8a\u591a\uff0c\u4f60\u5c31\u8d8a\u6709\u80fd\u529b\u53bb\u627f\u62c5\u98ce\u9669\uff0c\u4e5f\u5c31\u662f\u8bf4\u4f60\u53ef\u4ee5\u66f4\u52a0aggressive. \u8d44\u4ea7\u8d8a\u5c11\uff0c\u4f60\u5c31\u8d8a\u5e94\u8be5\u4fdd\u5b88\uff0c\u56e0\u4e3a\u4f60\u7684\u635f\u5931\u662f\u4e0d\u53ef\u627f\u53d7\u7684. \u4eceleetcode\u770b\u8d22\u5bcc.</p>","tags":["Math","Binary Search","Dynamic Programming"]},{"location":"leetcode/887-super-egg-drop/#reference","title":"Reference","text":"<ul> <li>huahua</li> </ul>","tags":["Math","Binary Search","Dynamic Programming"]},{"location":"leetcode/9-palindrome-number/","title":"9 Palindrome Number","text":""},{"location":"leetcode/92-reverse-linked-list-II/","title":"Problem","text":""},{"location":"leetcode/92-reverse-linked-list-II/#intuition","title":"Intuition","text":"<p>For this problem, we need to break it down to three steps,</p> <p>In step one, we need to create a dummy header node (good practice and generalization), we use two pointers technique to advance both <code>prevLeft</code> and <code>curr</code> pointer until <code>curr</code> points at left node.</p> <pre><code># construction dummy header node and points to head\ndummy = ListNode(0,head)\n\nprevLeft, curr = dummy,head\n# advance (left - 1) times\nfor i in range(left - 1):\n    prevLeft, curr = prevLeft.next, curr.next\n</code></pre> <p>\u5f53\u4f60\u5206\u4e0d\u6e05\u695aiteration\u51e0\u6b21\u7684\u65f6\u5019\uff0c\u4ee3\u5165left = 1, \u5e76\u6bd4\u8f83\u4e00\u4e0b</p> <p></p> <p>For 2nd step, we need to perform the 206 reverse linked list I on Leetcode, please refer to this question if you are confused.</p> <p>For now, you need to construct a new pointer <code>prev</code>. Because we have to use the location of <code>prevNode</code> later. <pre><code>prev = None\nfor i in range(right - left + 1):\n    temp = curr.next\n    curr.next = prev\n    prev = curr\n    curr = temp\n</code></pre> </p> <p>For the 3rd step, you notice two things: - left node (node 2) is currently pointing to <code>None</code> - node 5 is cut loose but we have <code>curr</code> pointer points to it so it doesn't get garbage-collected! - <code>prevLeft</code> is node 1 and it still points to left node (<code>node 2</code>) - <code>prev</code> points to right node</p> <p>We summarize them into a table</p> pointer - <code>prev</code> points to right node (node 4) <code>prevLeft</code> points to the node before left node (node 1) <code>curr</code> points to the node after right node (node 5) <p>In order to reach the target position, we need to - point the node 1 to node 4 - point node 2 to node 5 </p> <p>Then we put down the following codes</p> <pre><code>prevLeft.next.next = curr\nprevLeft.next = prev\n</code></pre> <p></p>"},{"location":"leetcode/92-reverse-linked-list-II/#solution","title":"Solution","text":"<pre><code># Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def reverseBetween(self, head: Optional[ListNode], left: int, right: int) -&gt; Optional[ListNode]:\n\n        dummy = ListNode(0,head)\n\n        prevLeft, curr = dummy,head\n        for i in range(left - 1):\n            prevLeft, curr = prevLeft.next, curr.next\n\n\n        prev = None\n        for i in range(right - left + 1):\n            temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = temp\n\n\n        prevLeft.next.next = curr\n        prevLeft.next = prev\n\n        return dummy.next\n</code></pre>"},{"location":"leetcode/930-binary-subarrays-with-sum/","title":"930 Binary Subarrays With Sum","text":"<p>\u7b2c\u4e00\u76f4\u89c9\u662fsliding window, \u4f46\u6ca1\u60f3\u51fa\u6765. </p>","tags":["Array","Hash Table","Sliding Window","Prefix Sum"]},{"location":"leetcode/930-binary-subarrays-with-sum/#approach-0-brute-force","title":"Approach 0 Brute Force","text":"<p>By enumeration to exhaust all the subarrays, it's \\(O(n^2)\\) time complexity. Hit TLE. </p> <p>Info</p> <p>\u5176\u5b9e\u770bconstraints\u4e5f\u80fd\u6392\u9664. \u56e0\u4e3an\u7684\u8303\u56f4\u662f[1, 3*10^4]\uff0c\u6240\u4ee5O(n^2)\u7684\u89e3\u6cd5\u80af\u5b9a\u4f1aTLE, \u4f30\u6478\u7740\u6700\u591a\u80fd\u5230O(nlogn)\u7684\u89e3\u6cd5.</p> <pre><code>class Solution:\n    def numSubarraysWithSum(self, nums: List[int], goal: int) -&gt; int:\n        n = len(nums)\n        count = 0\n        # nums[j:i+1]\n        for i in range(n):\n            prefix_sum = 0\n            for j in range(i,n):\n                prefix_sum += nums[j]\n                if prefix_sum == goal:\n                    count += 1\n        return count\n</code></pre>","tags":["Array","Hash Table","Sliding Window","Prefix Sum"]},{"location":"leetcode/930-binary-subarrays-with-sum/#code-implementation","title":"Code Implementation","text":"<pre><code>class Solution:\n    def numSubarraysWithSum(self, nums: List[int], goal: int) -&gt; int:\n        n = len(nums)\n        count = 0\n        # nums[j:i+1]\n        for i in range(n):\n            prefix_sum = 0\n            for j in range(i,n):\n                prefix_sum += nums[j]\n                if prefix_sum == goal:\n                    count += 1\n        return count\n</code></pre>","tags":["Array","Hash Table","Sliding Window","Prefix Sum"]},{"location":"leetcode/930-binary-subarrays-with-sum/#approach-1-prefix-sum-hash-table","title":"Approach 1 Prefix Sum + Hash Table","text":"<p>Hashtable\u8bb0\u5f55prefix sum\u7684\u6b21\u6570. \u6211\u4eec\u9700\u8981traverse the array, \u6c42total_sum. \u5728\u6bcf\u4e00\u4e2aiteration, \u6211\u4eec\u90fd\u505a\u4e24\u4ef6\u4e8b</p> <ul> <li>\u4ece0\u5f00\u59cb\u7684subarray\u7684\u548c == <code>target</code> (\u4e5f\u5c31\u662fthe sum we are iterating through)</li> <li>\u5728\u8fc7\u53bb\u7684prefix_sum\u4e2d\uff0c\u627e\u5230\u6ee1\u8db3current prefix_sum - previous prefix_sum == target\u7684\u6b21\u6570</li> </ul> <p>Prefix Sum\u89e3\u51b3\u7684\u95ee\u9898</p> <p>\u9488\u5bf9\u8fde\u7eedn\u4e2a\u6570\u7684\u548c\u7b49\u4e8etarget\u7684\u95ee\u9898, \u53ef\u4ee5\u4f7f\u7528prefix sum + hash\u7684\u65b9\u6cd5\u6765\u89e3. hash key\u662fprefix sum\u7684\u503c, value\u662f\u51fa\u73b0\u7684\u6b21\u6570. \u7528hash\u7684\u539f\u56e0\u662f\u4e3a\u4e86\u50a8\u5b58previous prefix sum\u7684\u6b21\u6570. \u6240\u6709\u7684subarray\u7684\u548c\uff0c\u90fd\u53ef\u4ee5\u7531\u4e24\u4e2asubarray\u7684prefix sum\u76f8\u51cf\u5f97\u5230. \u4f60\u53ef\u4ee5\u601d\u8003\u4e00\u4e0b\uff0c\u662f\u4e0d\u662f\u6240\u6709\u7684subarray\u90fd\u53ef\u4ee5\u7531\u4e24\u4e2a\u4ee50\u4e3a\u8d77\u70b9\u7684subarray\u76f8\u51cf\u5f97\u5230\uff1f</p> <p>\u601d\u8003\u4e00\u4e0binfo panel\u91cc\u7684\u95ee\u9898\uff0c\u987a\u4fbf\u770b\u770b\u4e0b\u56fe,</p> <p></p>","tags":["Array","Hash Table","Sliding Window","Prefix Sum"]},{"location":"leetcode/930-binary-subarrays-with-sum/#code-implementation_1","title":"Code Implementation","text":"<pre><code>from collections import defaultdict\nclass Solution:\n    def numSubarraysWithSum(self, nums: List[int], goal: int) -&gt; int:\n        # Problem: contiguous k number summing up to goal\n        # BF: running all the subarray from length of 1, 2,..., 5\n        # O(n^2) for traversing O(n) for summing, O(n^3) total, TLE for size of 3*10^4\n        # looking at something O(nlogn) worst\n\n        total_count = 0\n        prefix_sum = 0\n        freq = defaultdict(int)\n\n        for num in nums:\n            prefix_sum += num\n            if prefix_sum == goal:\n                total_count += 1\n\n            # check if there is any existing prefix sum that can be subtracted from the curr prefix sum\n            # to get the desired goal\n            if prefix_sum - goal in freq:\n                total_count += freq[prefix_sum - goal]\n\n            # update map\n            freq[prefix_sum] += 1\n\n        return total_count\n</code></pre>","tags":["Array","Hash Table","Sliding Window","Prefix Sum"]},{"location":"leetcode/930-binary-subarrays-with-sum/#approach-2-sliding-window","title":"Approach 2 Sliding Window","text":"<p>Sliding Window\u7684\u903b\u8f91\uff0c\u6211\u4eec\u7ef4\u62a4\u4e00\u4e2awindow with left and right pointer. \u7531\u4e8e\u8fd9\u4e2a\u6570\u7ec4\u91cc\u9762\u7684\u6570\u90fd\u662f0\u548c1\uff0c\u4e0d\u5b58\u5728\u8d1f\u6570\uff0c\u4e5f\u5c31\u662f\u8bf4\uff0c</p> <ul> <li>when moving right pointer, subarray sum\u662f\u9012\u589e\u7684(\u4e0d\u53d8 or increase).</li> <li>when moving left pointer, subarray sum\u662f\u9012\u51cf\u7684(\u4e0d\u53d8 or decrease).</li> </ul> <p>\u6211\u4eec\u53ea\u9700\u8981move right pointer till the subarray sum &gt; goal, \u7136\u540emove left pointer till the subarray sum &lt; goal. \u8fd9\u6837\u7684\u8bdd\uff0c\u6211\u4eec\u5c31\u53ef\u4ee5\u5f97\u5230\u6240\u6709\u7684subarray sum \u4e3a goal\u7684subarray. \u5177\u4f53\u5982\u4e0b\u56fe,</p> <p></p> <p>\u4f46\u8fd9\u91cc\u6709\u4e00\u4e2aedge case, \u5f53goal = 0\u65f6\u5019\uff0c\u5f53\u6211\u4eecright pointer encounter 1\u7684\u65f6\u5019\uff0c\u6211\u4eec\u5f00\u59cbmove left pointer, \u7ed3\u679c\u53d1\u73b0\u4e0d\u7ba1\u600e\u4e48\u79fb\u52a8\uff0csubarray sum\u90fd\u662f1, \u5982\u4e0b\u56fe.</p> <p></p> <p>\u8fd9\u91cc\u8981\u7528\u5230\u4e00\u4e2atrick, \u6bd4\u5982\u8ba1\u7b97\u6240\u6709\u4e3agoal = 2\u7684subarray\uff0c\u6211\u4eec\u8ba1\u7b97\u6240\u6709&lt;=3\u7684subarray\uff0c\u7136\u540e\u51cf\u53bb\u6240\u6709&lt;=1\u7684subarray\uff0c\u5c31\u5f97\u5230\u4e86\u6240\u6709\u4e3agoal = 2\u7684subarray. Two pass solution. \u5728right pointer traverse\u7684\u65f6\u5019\uff0c\u6211\u4eec\u8ba1\u7b97\u7b26\u5408\u6761\u4ef6\u7684\u6700\u5927window size, \u8fd9\u4e2awindow size\u7b49\u4ef7\u4e8eending at right pointer\u7684subarray\u7684\u4e2a\u6570. \u4f60\u53ef\u4ee5\u81ea\u5df1\u6570\u6570\u4e0b\u9762\u8fd9\u56fe, </p> <p></p> <p>\u601d\u8003</p> <p>\u6240\u6709\u4ee5right pointer\u4e3a\u7ed3\u5c3e,\u4e14\u7b26\u5408<code>prefix_sum &lt;= goal</code>\u7684subarray\u7684\u4e2a\u6570\uff0c\u6b63\u597d\u7b49\u4e8e\u7b26\u5408\u6761\u4ef6\u7684\u6700\u5927window size. \u6709\u4e24\u4e2a\u6761\u4ef6:</p> <ul> <li>\u4ee5right pointer\u4e3awindows\u7ed3\u5c3e</li> <li>\u6700\u5927\u7b26\u5408\u6761\u4ef6\u7684window size. \u7531\u4e8e\u6211\u4eec\u6709\u4e2a<code>while curr_sum &gt; x</code>, \u5f53curr_sum == x\u7684\u65f6\u5019\u8df3\u51fa\u5faa\u73af, \u6211\u4eec\u5c31\u6b63\u597d\u5f97\u5230\u4e86\u6700\u5927window size.</li> </ul> <p>\u8fd9\u4e2a\u601d\u60f3\u5728DP\u91cc\u9762\u7ecf\u5e38\u7528\u5230\uff0c\u4ee5i\u4e3a\u7ed3\u5c3e\u554a\uff0c\u4ee5i\u4e3a\u5f00\u5934\u554a.</p>","tags":["Array","Hash Table","Sliding Window","Prefix Sum"]},{"location":"leetcode/930-binary-subarrays-with-sum/#code-implementation_2","title":"Code Implementation","text":"<pre><code>class Solution:\n    def numSubarraysWithSum(self, nums: List[int], goal: int) -&gt; int:\n        def helper(x):\n            \"\"\"\n            return number of subarray with sum &lt;= x\n            \"\"\"\n            # edge case\n            if x &lt; 0:\n                return 0\n\n            l = 0\n            curr_sum = 0\n            res = 0\n            for r in range(len(nums)):\n                curr_sum += nums[r]\n                while curr_sum &gt; x:\n                    curr_sum -= nums[l]\n                    l += 1                \n                # size of the window\n                res += (r - l + 1)\n\n            return res\n\n        return helper(goal) - helper(goal-1)\n</code></pre>","tags":["Array","Hash Table","Sliding Window","Prefix Sum"]},{"location":"leetcode/930-binary-subarrays-with-sum/#reference","title":"Reference","text":"<ul> <li>Neetcode LC 930</li> </ul>","tags":["Array","Hash Table","Sliding Window","Prefix Sum"]},{"location":"leetcode/931-minimum-falling-path-sum/","title":"931 Minimum Falling Path Sum","text":"<p>classic 2D dp problem.</p>","tags":["Array","Matrix","Dynamic Programming"]},{"location":"leetcode/931-minimum-falling-path-sum/#approach-1-bottom-up","title":"Approach 1: bottom-up","text":"<p>time complexity</p> <ul> <li>\\(O(n^2)\\) in time</li> <li>\\(O(n^2)\\) in space since we store the path sum of each cell.</li> </ul> <p>\u8fd9\u4e00\u9898\u9996\u5148\u5148\u753b\u4e2a\u6811\uff0c\u6211\u4eec\u53d1\u73b0, \u53ef\u4ee5\u5206\u7c7b\u8ba8\u8bba</p> <p>|-|diagonally left|down|diagonally right| |-|-|-| |first column|\ud83d\udeab|\u2705|\u2705| |last column|\u2705|\u2705|\ud83d\udeab| |other columns|\u2705|\u2705|\u2705|</p> <p>\u90a3\u8fd9\u6837\u7684\u8bdd\uff0c\u6211\u4eec\u5c31\u53ef\u4ee5dp\u4e09\u90e8\u66f2\u4e86.</p> <p>Tip</p> <p>Definition of DP:</p> <p><code>dp[i][j]: \u8868\u793a\u5230\u8fbecell[i][j]\u7684\u6700\u5c0f\u8def\u5f84\u548c</code></p> <p>Initialization:</p> \\[ dp[0][j] = matrix[0][j] \\quad \\text{for} \\quad j \\in [0,n) \\] <p>State Transition:</p> <p>$$ dp\\left[i\\right][j] = \\begin{cases} matrix[i][j] + min(dp[i-1][j],dp[i-1][j+1])\\quad j=0\\ matrix[i][j] + min(dp[i-1][j-1],dp[i-1][j],dp[i-1][j+1])\\quad j \\in [1,n)\\ matrix[i][j] + min(dp[i-1][j],dp[i-1][j-1])\\quad j=n\\ \\end{cases} $$ where i &gt;= 1</p>","tags":["Array","Matrix","Dynamic Programming"]},{"location":"leetcode/931-minimum-falling-path-sum/#code-implementation","title":"Code Implementation","text":"<pre><code>class Solution:\n    def minFallingPathSum(self, matrix: List[List[int]]) -&gt; int:\n        # dp[i][j] the min path sum reach cell[i][j]\n        n = len(matrix)\n\n        # edge case\n        if n == 1: return matrix[0][0]\n\n        dp = [[0 for j in range(n)] for i in range(n)]\n\n        for j in range(n):\n            dp[0][j] = matrix[0][j]\n\n        # scan vertical\n        for i in range(1,n):\n            # scan horizontally\n            for j in range(n):\n                # left boundary nodes\n                if j == 0:\n                    dp[i][j] = matrix[i][j] + min(dp[i-1][j],dp[i-1][j+1])\n                    continue\n\n                # right bounday nodes\n                if j == n-1:\n                    dp[i][j] = matrix[i][j] + min(dp[i-1][j-1],dp[i-1][j])\n                    continue\n\n                # interior nodes\n                dp[i][j] = matrix[i][j] + min(dp[i-1][j-1],dp[i-1][j],dp[i-1][j+1])\n\n        return min(dp[-1])\n</code></pre>","tags":["Array","Matrix","Dynamic Programming"]},{"location":"leetcode/931-minimum-falling-path-sum/#approach-2-bottom-up-with-space-optimization","title":"Approach 2: bottom-up with space optimization","text":"<p>In state transition function, we realize that we only need the previous row to calculate the current row. Therefore, we only need to maintain two rows of dp array.</p> <pre><code>class Solution:\n    def minFallingPathSum(self, matrix: List[List[int]]) -&gt; int:\n        n = len(matrix)\n        if n == 1:\n            return matrix[0][0]\n\n        # initialize first row\n        prev = [val for val in matrix[0]]\n        curr = [0 for _ in range(n)]\n\n        for i in range(1,n):\n            for j in range(n):\n                if j == 0:\n                    curr[j] = matrix[i][j] + min(prev[j],prev[j+1])\n                elif j == n-1:\n                    curr[j] = matrix[i][j] + min(prev[j-1],prev[j])\n                else:\n                    curr[j] = matrix[i][j] + min(prev[j-1],prev[j],prev[j+1])\n\n            prev = curr.copy()\n        return min(curr)\n</code></pre>","tags":["Array","Matrix","Dynamic Programming"]},{"location":"leetcode/948-bag-of-tokens/","title":"948 Bag of Tokens","text":"<p>The game rule is shown as follows:</p> <ul> <li><code>face-up</code>: consume power worth <code>tokens[i]</code> but gain 1 score</li> <li><code>face-down</code>: if you have at least 1 score, you can consume 1 score to gain <code>tokens[i]</code> power</li> </ul> <p>You have an initial power of <code>power</code> and an initial score of 0. To maximum the score you get, you could play the game greedily by following the rules below:</p> <ul> <li>sort the tokens ascendingly</li> <li>if you have enough power to play cheapest token, play <code>face-up</code></li> <li>if you don't have enough power but you do have score, play <code>face-down</code> on the most expensive token</li> <li>repeat until you can't play no more</li> </ul> <p>You also need to maintain a variable to keep track of the maximum score you can get.</p> <p>Note</p> <p>greedy works here because each subproblem is independent of each other and doesn't affect the overall result. </p> <pre><code>class Solution:\n    def bagOfTokensScore(self, tokens: List[int], power: int) -&gt; int:\n        # Yoooo! \n        # power &gt;= tokens[i], \u53ef\u4ee5\u53d1\u52a8\u6280\u80fdface-up. losing power for 1 score\n        # score&gt;= 1, you lost 1 score, but you gain tokens[i] power\n        \"\"\"\n        \u6211\u4eec\u53ef\u4ee5\u505a\u4ee5\u4e0b\u6b65\u9aa4\n        1. sort them ascendingly and initialize two pointer, lo and hi\n        2. play face-up when have enough power to increase score\n        3. if we don't have enough power for step 2, and we do have &gt;= 1 score, we play face down to gain power\n        4. if we don't have power nor enough score, we can't play no more\n        \"\"\"\n        tokens.sort()\n        left,right = 0,len(tokens)-1\n        score = 0\n        best = 0\n        while left &lt;= right:\n            if power &gt;= tokens[left]:\n                score += 1\n                power -= tokens[left]\n                left += 1\n                best = max(best,score)\n            elif score &gt;= 1:\n                score -= 1\n                power += tokens[right]\n                right -= 1\n            else:\n                break\n\n        return best\n</code></pre>","tags":["Array","Two Pointers","Greedy","Sorting"]},{"location":"leetcode/950-reveal-cards-in-increasing-order/","title":"950 Reveal Cards In Increasing Order","text":"","tags":["Array","Queue","Simulation","Sorting"]},{"location":"leetcode/950-reveal-cards-in-increasing-order/#approach-1-simulation-with-queue","title":"Approach 1 Simulation with Queue","text":"<p>\u6211\u4eec\u77e5\u9053\u51fa\u6765\u7684\u987a\u5e8f\uff0c\u8981\u53cd\u63a8\u51fa\u4ec0\u4e48\u6837\u7684\u987a\u5e8f\u53ef\u4ee5\u5f97\u5230\u8fd9\u4e2a\u7ed3\u679c\uff0c\u6211\u4eec\u53ef\u4ee5\u7528\u4e00\u4e2adeque\u6765\u6a21\u62df\u8fd9\u4e2a\u8fc7\u7a0b.</p> <ul> <li>\u5efa\u4e00\u4e2adeque\uff0c\u91cc\u9762\u653e0..n-1\u7684index</li> <li>\u6784\u9020\u4e00\u4e2aresult\u6570\u7ec4\uff0c\u957f\u5ea6\u4e3an, \u7528\u6765\u5b58\u653e\u6700\u540e\u7684\u7ed3\u679c</li> <li>\u5bf9deck\u8fdb\u884c\u6392\u5e8f</li> <li>\u5bf9deck\u4e2d\u7684\u6bcf\u4e00\u4e2acard\uff0c<ul> <li>\u6211\u4eec\u4ecedeque\u7684\u5de6\u8fb9\u53d6\u51fa\u4e00\u4e2aindex\uff0c\u7136\u540e\u5c06card\u653e\u5230result\u4e2d\u8fd9\u4e2aindex\u7684\u4f4d\u7f6e</li> <li>\u53ea\u8981deque\u4e0d\u4e3a\u7a7a\uff0c\u6211\u4eec\u5c31\u5c06deque\u5de6\u8fb9\u518d\u53d6\u51fa\u4e00\u4e2aindex\uff0c\u7136\u540e\u653e\u5230deque\u7684\u53f3\u8fb9</li> </ul> </li> </ul> <pre><code>from collections import deque\nclass Solution:\n    def deckRevealedIncreasing(self, deck: List[int]) -&gt; List[int]:\n        n = len(deck)\n        # 0..n-1 \u6240\u6709\u7684index\n        queue = deque([i for i in range(n)])\n\n        deck.sort()\n\n        result = [0 for _ in range(n)]\n\n        for card in deck:\n            # reveal card from left end\n            result[queue.popleft()] = card\n\n            if queue:\n                queue.append(queue.popleft())\n\n        return result\n</code></pre>","tags":["Array","Queue","Simulation","Sorting"]},{"location":"leetcode/953-verifying-an-alien-dictionary/","title":"Problem","text":"<p>\u8fd9\u4e00\u9898\u9898\u76ee\u5982\u4e0b, \u8f93\u5165\u662f: - <code>words</code>: list, containing strings only such as <code>words = [\"hello\",\"leetcode\"]</code> - <code>order</code>: string, \u7531\u4e71\u5e8f\u768424\u4e2a\u82f1\u6587\u5b57\u6bcd\u7ec4\u6210\uff0c\u4ee3\u8868\u7740\u5916\u661f\u8bed\u8a00\u7684\"abc...z\"\u7684\u987a\u5e8f,\u4f8b\u5982<code>order = \"hlabcdefgijkmnopqrstuvwxyz\"</code></p> <p>\u5224\u65ad\u8fd9\u4e2alist\u4e2d\u7684string,\u662f\u5426\u662fsorted lexicographically? return boolean result.</p> <pre><code>graph LR\n    words &amp; order --&gt; a(\"is sorted?\")\n    a --&gt; True &amp; Flase</code></pre>"},{"location":"leetcode/953-verifying-an-alien-dictionary/#_1","title":"\u9519\u8bef\u601d\u8def","text":"<p>\u6211\u4e00\u5f00\u59cb\u7684\u601d\u8def\u662f: - \u5efa\u7acb\u4e00\u4e2ahash, \u7ed9\u8fd924\u4e2acharacter in order, \u8d4b\u4e88\u4e0d\u540c\u7684numerical value - \u7d2f\u52a0\u6bcf\u4e2astring\u7684\u603b\u5206\u503c\\(\\sum c_i\\) for <code>string = 'hello'</code> - \u6bd4\u8f83\u6700\u540e\u603b\u5206\u503c</p> <p>\u8fd9\u4e2a\u601d\u8def\u6709\u4e24\u4e2a\u5f0a\u7aef: - \u9700\u8981\u5bf9\u6bcf\u4e00\u4e2astring\u8fdb\u884c\u4f30\u5206\u540e\uff0c\u518d\u6bd4\u8f83, \u6bd4\u5982\u6bd4\u8f83<code>hello</code>\u548c<code>leetcode</code>\u4fe9string, \u53ea\u9700\u8981\u6bd4\u8f83\u7b2c\u4e00\u4e2acharacter\u5c31\u80fd\u77e5\u9053\u5927\u5c0f\u4e86,\u6c42\u5206\u6570\u603b\u548c\u5c31\u5f88\u6d6a\u8d39\u4e86; - \u4f60\u5f88\u96be\u8bbe\u8ba1\u6b63\u786e\u7684\u5206\u503c\uff0c\u5047\u8bbea-z\u7684\u5206\u503c\u4e3a1-24, \u90a3\u4e48<code>acd</code> \u4e3a 1+3+4 = 8, <code>abe</code> \u4e3a 1+2+5 = 8; \u6240\u4ee5\u8fd9\u79cd\u7d2f\u52a0\u7684\u65b9\u5f0f\u4e5f\u4e0d\u9002\u5408;   - \u6211\u4e00\u5f00\u59cb\u7684\u601d\u8def\u8fd8\u6709\u8bbe\u7f6e\u4e00\u4e2a10\u4f4d\uff0c100\u4f4d\uff0c\u5343\u4f4d\uff0c\u4e5f\u5c31\u662f\u8d8a\u524d\u9762\u7684\u6570\u5b57\uff0c\u5360\u7684\u6bd4\u91cd\u5c31\u8d8a\u5927\uff0c\u5b9e\u9645\u4e0a\u5c31\u662f\u4e3a\u4e86\u5265\u79bb\u4e0a\u6761\u6240\u8bf4\u7684\u60c5\u51b5\uff0c\u6bcf\u4e00\u4f4d\u6570\uff0c\u81f3\u5c11\u6bd4\u524d\u4e00\u4f4d\u592724,\u624d\u80fd\u4fdd\u8bc1\u4e0a\u4e00\u4f4d\u6bd4\u8fd9\u4e00\u4f4d\u5927; \u6700\u540e24n, n\u4e3astring\u7684\u957f\u5ea6\uff0c\u4e5f\u5c31\u662f\u8bf4\uff0cstring\u8fc7\u957f\u7684test case\u4f1a\u6709overflow\u7684\u60c5\u51b5\uff1b</p>"},{"location":"leetcode/953-verifying-an-alien-dictionary/#approach-1-compare-adjacent-string","title":"Approach 1: Compare adjacent string","text":"<p>\u601d\u8def\u5c31\u662f: - \u5c06order\u8f6c\u5316\u4e3ahash,\u8d4b\u4e88\u4e0d\u540c\u7684\u503c - traverse through words, \u4e24\u4e24\u6bd4\u8f83\u5927\u5c0f, \u5229\u7528transitive property of equality i.e. a &lt; b, b &lt; c then a &lt; b &lt; c, then [a,b,c] is sorted - traverse\u76f8\u90bb\u4fe9string, sequentially\u6bd4\u8f83\u9010\u4e2a\u7684\u5927\u5c0f;</p>"},{"location":"leetcode/953-verifying-an-alien-dictionary/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: \\(O(nm)\\) where n is the size of the words list, m is the average length of string in the list;</li> </ul> <ul> <li>Space complexity: \\(O(1)\\)</li> </ul>"},{"location":"leetcode/953-verifying-an-alien-dictionary/#code","title":"Code","text":"<pre><code>class Solution:\n    def isAlienSorted(self, words: List[str], order: str) -&gt; bool:\n\n        # hashmap for orders\n        hashtable = {}\n\n        # assgin value for each character\n        for i,char in enumerate(order):\n            # \n            hashtable[char] = i\n\n        # \u5916\u5faa\u73af. iter list O(n)\n        for i in range(len(words)-1):\n            # \u6bd4\u8f83\u76f8\u90bb\u4fe9string\u7684\u957f\u5ea6\n            min_length = min(len(words[i]),len(words[i+1]))\n\n            # \u5185\u5faa\u73af iter \u4fe9\u76f8\u90bbstring\u4e2d\u8f83\u77ed\u7684\u90a3\u4e00\u4e2a\u7684\u957f\u5ea6\n            for j in range(min_length):\n\n                if words[i][j] == words[i+1][j]:\n                    # \u5982\u679c\u4e24\u4e2a\u5b57\u7b26\u76f8\u7b49, jump to next iteration,\u6bd4\u8f83\u4e0b\u4e24\u4e2acharacter\n                    continue    \n                else:\n                    # \u5982\u679c\u4e24\u4e2a\u5b57\u7b26\u4e0d\u7b49\uff0c\u6bd4\u8f83\u5927\u5c0f\n                    if hashtable[words[i+1][j]] &gt; hashtable[words[i][j]]:\n                        # \u76ee\u524d sorted, break \u5185\u5faa\u73af \n                        break\n                    else:\n                        # \u4e0dsorted, return false\n                        return False\n\n            # \u5982\u679c\u80fd\u5faa\u73af\u5230\u8fd9\u91cc\uff0c\u5c31\u662f[\"apple\",\"app\"] \u8fd9\u79cd\u60c5\u51b5\u4e86\n            if len(words[i]) &gt; len(words[i+1]) and hashtable[words[i+1][min_length-1]] == hashtable[words[i][min_length-1]]:\n                return False\n\n        # \u6bd4\u8f83\u4e0b\u6765\uff0c\u6bcf\u4e00\u4e2a\u90fd\u662fsorted\n        return True\n</code></pre>"},{"location":"leetcode/953-verifying-an-alien-dictionary/#code_1","title":"\u4f18\u5316code","text":"<p>\u518d\u51e0\u4e2a\u5730\u65b9\u53ef\u4ee5\u4f18\u5316: - boudnaries: \u7531\u4e8e\u4fe9\u76f8\u90bb\u7684string, length\u4e0d\u786e\u5b9a\uff0c\u4e0d\u77e5\u9053\u7528\u54ea\u4e2a\u4f5c\u4e3a\u5faa\u73af\u6761\u4ef6\uff0c\u6211\u91c7\u7528\u7684\u65b9\u6cd5\u662f\u627e\u5230\u76f8\u90bbstring\u7684min length, \u7136\u540e\u5faa\u73afmin length\u6b21\u6570,\u4f46\u5b9e\u9645\u4e0a\u4e0d\u7528; - naming: \u4ee5\u540ehashtable\u8fd9\u6837\u7684\u547d\u540d\u65b9\u5f0f, \u53ef\u4ee5\u6839\u636e\u5177\u4f53\u7528\u610f\u6539<code>for index,val in enumerate(order): order_map[val] = index</code> \u8fd9\u6837\u6bd4\u8f83\u6e05\u6670;</p> <pre><code>class Solution:\n    def isAlienSorted(self, words: List[str], order: str) -&gt; bool:\n\n        order_map = {}\n        for index,char in enumerate(order):\n            order_map[char] = index\n\n        # iterate through the list\n        for i in range(len(words)-1):\n            # iterate throught the 1st string in the string pair\n            for j in range(len(words[i])):\n\n\n                # \u5982\u679c\u575a\u6301\u5230\u8fd9,\u8fd8\u6ca1\u5206\u51fa\u5927\u5c0f, \u6bd4\u8f83string\u957f\u5ea6\n                # [\"apple\",\"app\"]\n                if j &gt;= len(words[i+1]):\n                    return False\n\n                # \u627e\u5230\u4fe9\u76f8\u90bbstring\u7684\u7b2c\u4e00\u4e2a\u4e0d\u540c\u7684character\n                if words[i][j] != words[i+1][j]:\n                    # \u6bd4\u8f83char in string one \u662f\u5426\u5927\u4e8echar in string two\n                    if order_map[words[i][j]] &gt; order_map[words[i+1][j]]:\n                        return False\n\n                    # not sorted, \u6bd4\u8f83\u4e0b\u4e24\u4e2astring\u53bb\n                    break\n                \"\"\"\n                \u4e09\u79cd\u65b9\u5f0f\u8df3\u51fa\u5185\u5faa\u73af:\n                1. \u6bd4\u8f83current index j with \u4e0b\u4e00\u4e2astring\u7684\u957f\u5ea6\uff0ccover corner cases [\"apple\",\"app\"]\n                if j &gt;= len(words[i+1])\n                2. \u7b2c\u4e00\u4e2a\u4e0d\u76f8\u540c\u7684char, \u6ee1\u8db3sorted, then break\n                3. \u7b2c\u4e00\u4e2a\u4e0d\u76f8\u540c\u7684char,\u4e0d\u6ee1\u8db3sorted, return False\n                \u90a3\u4e48\u4e0d\u8df3\u51fa\u5185\u5faa\u73af\u7684\u53ef\u80fd\u6027\uff0c\u5c31\u662f:\n                [\"app\",\"apple\"] \u6ee1\u8db3app &lt; apple, sorted;\n                \"\"\"\n\n\n        return True\n</code></pre>"},{"location":"leetcode/973-K-closest-points-to-origin/","title":"973 K Closest Points to Origin","text":"","tags":["Array","Math","Divide and Conquer","Geometry","Sorting","Heap (Priority Queue)","Quickselect"]},{"location":"leetcode/973-K-closest-points-to-origin/#approach-1-heap-priority-queue","title":"Approach 1: Heap (Priority Queue)","text":"<p>Note</p> <p>time complexity: \\(O(k\\log n + n)\\), \\(O(n)\\) in space for auxiliary data structure</p> <pre><code>import math\nfrom heapq import heapify,heappop\nclass Solution:\n    def kClosest(self, points: List[List[int]], k: int) -&gt; List[List[int]]:\n        # \u6700\u8fd1\u7684k\u4e2a\u70b9;\n        # 0. write a helper funcion to calculate the distance from point to (0,0)\n        # 1. one-pass scan to calculate the distance, O(n), prob store it as (distance, index)\n        # 2. heapify it (O(n))\n        # 3. pop the first k\n        def get_distance(x,y):\n            \"\"\"return the distance from (x,y) to (0,0)\"\"\"\n            return (x-0)**2 + (y-0)**2\n\n        # O(n)\n        distances = [(get_distance(point[0],point[1]),i) for i,point in enumerate(points)]\n        # O(n)\n        heapify(distances)\n\n        res = []\n        # O(k*logn)\n        while k &gt; 0:\n            _, i = heappop(distances)\n            res.append(points[i])\n            k -= 1\n\n        return res\n</code></pre>","tags":["Array","Math","Divide and Conquer","Geometry","Sorting","Heap (Priority Queue)","Quickselect"]},{"location":"leetcode/974-subarray-sums-divisible-by-K/","title":"974 Subarray Sums Divisible by K","text":"","tags":["Array","Hash Table","Prefix Sum"]},{"location":"leetcode/974-subarray-sums-divisible-by-K/#approach-1-prefix-sum-hash-table","title":"Approach 1: Prefix Sum + Hash Table","text":"<p>\u8fd9\u9898\u96be\u70b9\u5728\u4e8e\uff0c\u600e\u4e48\u628a\u8fd9\u4e00\u9898\u76ee\u7684sum divisible by k\u8981\u6c42\uff0c\u8f6c\u5316\u4e3aprefix sum equals to k\u7684\u5df2\u77e5\u7c7b\u578b\u3002\u5982\u679c\u4e24\u4e2aprefix sum % k\u7684\u7ed3\u679c\u76f8\u7b49\uff0c\u5219\u8fd9\u4fe9subarray\u7684\u5dee\u5f62\u6210\u7684subarray\u5fc5\u5b9a\u80fd\u88abdivisiable by k, \u89c1\u4f8b\u5b50</p> <pre><code>x x x  x  [x  x x x]\n      j-1  j      i\n\nsum[j..i] = prefix_sum[i] - prefix_sum[j-1]\n\nprefix_sum[i] % k = a\nprefix_sum[j-1] % k = a\n\nthen we will have,\n(prefix_sum[i] - prefix_sum[j-1]) % k = 0\nsum[j..i] % k = 0 \u7b26\u5408\u6761\u4ef6\n</code></pre> <p>\u5982\u6b64\u53ef\u77e5\uff0c\u6211\u4eec\u9700\u8981\u4e00\u4e2ahashmap\u6765\u5b58\u50a8<code>prefix sum % k</code> as our key\uff0cand frequencies as the value. \u8fd8\u6709\u5904\u7406\u5de6\u8fb9\u754c\uff0c\u4e5f\u5c31\u662f\u6240\u6709\u4ee50\u4e3a\u8d77\u70b9\u7684subarray\uff0c\u8fd9\u4e9bsubarray\u7684prefix sum % k = 0, \u9700\u8981\u627e\u5230\u4e00\u4e2a\u521d\u59cb\u6761\u4ef6, \u4e5f\u5c31\u662f\u4e00\u4e2a\u7a7a\u96c6\u7684\u548c\uff0c\u81ea\u7136\u662f0\uff0c<code>0%k == 0</code> as key, <code>1</code> as value since it appears once</p> <pre><code>  \"\"[x x x]  x x  x x x\n  -1     i\n</code></pre>","tags":["Array","Hash Table","Prefix Sum"]},{"location":"leetcode/974-subarray-sums-divisible-by-K/#code-implementation","title":"Code Implementation","text":"<pre><code>from collections import defaultdict\nclass Solution:\n    def subarraysDivByK(self, nums: List[int], k: int) -&gt; int:\n        # \u5047\u8bbe\u4e24\u4e2aprefix sum\u7684modulus\u76f8\u7b26\uff0c\u5219\u8fd9\u4fe9subarray\u7684\u5dee\u5f62\u6210\u7684\n        # subarray\u6bd4\u80fd\u88abdivisiable by k\n        hashtable = defaultdict(int)\n        # initial condition (key:value) \n        # key empty array, counter once\n        hashtable[0] = 1\n        prefix = total = 0\n\n        for i,num in enumerate(nums):\n            prefix += num\n            target = prefix % k\n            if target in hashtable:\n                total += hashtable[target]\n\n            hashtable[target] += 1\n\n        return total\n</code></pre>","tags":["Array","Hash Table","Prefix Sum"]},{"location":"leetcode/977-squares-of-a-sorted-array/","title":"977 Squares of a Sorted Array","text":"","tags":["Two Pointers","Array","Sorting"]},{"location":"leetcode/977-squares-of-a-sorted-array/#approach-1-two-pointers","title":"Approach 1 Two Pointers","text":"<pre><code>class Solution:\n    def sortedSquares(self, nums: List[int]) -&gt; List[int]:\n        lo,hi = 0,len(nums)-1\n\n        res = []\n        while lo &lt;= hi:\n            if abs(nums[hi]) &gt; abs(nums[lo]):\n                res.append(nums[hi]*nums[hi])\n                hi -= 1\n            elif abs(nums[hi]) &lt; abs(nums[lo]):\n                res.append(nums[lo]*nums[lo])\n                lo += 1\n            else:\n                # lo == hi, \u53ea\u52a0\u4e00\u6b21\n                res.append(nums[hi]*nums[hi])\n                if lo != hi:\n                    # lo != hi\uff0c\u518d\u52a0\u4e00\u6b21\n                    res.append(nums[hi]*nums[hi])\n\n                hi -= 1\n                lo += 1\n\n        return res[::-1]\n</code></pre>","tags":["Two Pointers","Array","Sorting"]},{"location":"leetcode/978-longest-turbulent-subarray/","title":"Approach 1: Bottom up, Linear Space","text":"<p>My intuition when i see turbuelnce subarry is that  <pre><code>&gt; &lt; &gt; &lt; &gt; &lt; &gt; &lt;\n</code></pre> For a simple array [a, b, c] to be a turbulent array, we could have <pre><code>Situation1: a &gt; b &lt; c\nSituation2: a &lt; b &gt; c\n</code></pre> The signs are fliping with every single time and it exisits a concise way to represent the state. If a, b ,c are distinct numbers (no duplicate) then the array <code>[a,b,c]</code> is turbulent is equivalent to the following statement <pre><code>(a &gt; b) XOR (b &gt; c)\n</code></pre></p> <p>Then, Similar to bottom-up solution for maximum subarray, we just need to define a <code>DP[i]</code> function that means the maximum turbulent subarray ending on <code>array[i]</code> (must include element <code>array[i]</code>). Then we do one pass solution while calculating <code>DP[i]</code> based on the state info stored in XOR.</p>"},{"location":"leetcode/978-longest-turbulent-subarray/#algorithm","title":"Algorithm","text":"<ul> <li>construct <code>DP[i]</code></li> <li>initialize <code>DP[0]</code> and <code>DP[1]</code></li> <li>iterate throught the <code>array[2:]</code><ul> <li>case when <code>array[i]</code> = <code>array[i-1]</code>, it means the maximun turbulent subarray ending on <code>array[i]</code> is 1. Example:  array = [2,1,3,3], DP[3] = 1.</li> <li>case when XOR returns <code>True</code>, it means we increment by one</li> <li>else, it means XOR returns <code>False</code>, it means we reset to 2.</li> </ul> </li> <li>return maximum in the <code>DP</code> array</li> </ul>"},{"location":"leetcode/978-longest-turbulent-subarray/#state-transition-diagram","title":"State transition diagram","text":"<pre><code>flowchart TD\n    init(\"initial state&lt;br&gt; DP[0] = 1, DP[1] = 1 or 2\")\n    reset_a(\"reset state 1&lt;br&gt;DP[i] = 1\")\n    reset_b(\"reset state 2&lt;br&gt;DP[i] = 2\")\n    init --&gt; accumulative\n    accumulative(\"acc state&lt;br&gt;DP[i] = DP[i-1] + 1\")\n    accumulative --&gt; |XOR = True| accumulative\n    accumulative --&gt; |\"arr[i]==arr[i-1]\"| reset_a\n    accumulative --&gt; |XOR = False|reset_b</code></pre>"},{"location":"leetcode/978-longest-turbulent-subarray/#complexity","title":"Complexity","text":"<ul> <li>Time complexity: \\(O(n)\\)</li> </ul> <ul> <li>Space complexity: \\(O(n)\\) to store previous maximum turbulent subarray length </li> </ul>"},{"location":"leetcode/978-longest-turbulent-subarray/#code","title":"Code","text":"<pre><code>class Solution:\n    def maxTurbulenceSize(self, arr: List[int]) -&gt; int:\n        # DP[i]: length of maximum turbulent subarray ending on arr[i]\n        # bottomUp constant space Solution\n\n        if len(arr) == 1: return 1\n        # initialize DP, at first two elements\n        DP = [None for _ in range(len(arr))]\n        DP[0] = 1        \n        if arr[0] == arr[1]:\n            DP[1] = 1\n        else:\n            DP[1] = 2\n\n        # bollean flag\n        flag = arr[1] &gt; arr[0]\n\n        for i in range(2,len(arr)):\n            # edge case when equal, we reset to 1\n            if arr[i] == arr[i-1]:\n                DP[i] = 1\n                continue\n\n            if flag ^ (arr[i] &gt; arr[i-1]):\n                # successfully update\n                DP[i] = DP[i-1] + 1\n\n                # update flag\n                flag = arr[i] &gt; arr[i-1]\n            else:\n                # update fails, rest to maximum turbulent subarray length ending on arr[i], which is 2.\n                DP[i] = 2\n\n        return max(DP)\n</code></pre>"},{"location":"leetcode/978-longest-turbulent-subarray/#approach-2-bottom-up-constant-space","title":"Approach 2: Bottom up, Constant space","text":"<p>We don't need to store the whole array and just need to track and update the maximum length of turbulent subarray for return. We do the following:</p> <pre><code>class Solution:\n    def maxTurbulenceSize(self, arr: List[int]) -&gt; int:\n        # bottom up, constant space\n        # current_length: current maximum turbulent ending on\n\n        if len(arr) == 1: return 1\n\n        # initialize DP, at first two elements\n        if arr[1] == arr[0]:\n            current_length = 1\n        else:\n            current_length = 2\n\n        maximum_length = current_length\n\n        # bollean flag\n        flag = arr[1] &gt; arr[0]\n\n        for i in range(2,len(arr)):\n            # edge case when equal, we reset to 1\n            if arr[i] == arr[i-1]:\n                current_length = 1\n                maximum_length = max(maximum_length,current_length)\n                continue\n\n            if flag ^ (arr[i] &gt; arr[i-1]):\n                # turbulent, so increment current length\n                current_length += 1\n                # update flag\n                flag = arr[i] &gt; arr[i-1]\n            else:\n                # rest current_length to 2, which only has two elements [0,1,2] --&gt; [1,2] \n                current_length = 2\n\n            maximum_length = max(maximum_length,current_length)\n\n        return maximum_length\n</code></pre>"},{"location":"leetcode/978-longest-turbulent-subarray/#summary","title":"Summary","text":"<p>The problem is very similar to maximum subarry and this solution provides: - a solution framework similar to the editoral of the maximum subarray  - the trick using <code>XOR</code> to represent state.</p>"},{"location":"leetcode/983-minimum-cost-for-tickets/","title":"Approach 1 Bottom up linear","text":"<ul> <li><code>base case:</code> It doesn't have a base case for this problem</li> <li><code>initialization:</code> Just initialize it to zeros for all.</li> <li><code>DP[i] definition</code>: naively generate a rolling</li> <li><code>transition function:</code> </li> </ul> <p>A couple of key takeaway for this problem: - this problem uses the \"brute-ish\" DP jerry was telling me about. It is going to make things easier. - it doesn't matter how large you set you <code>DP array</code> is as long as you are covering all the solution - don't be too dependent on <code>list()</code> and please use more <code>defaultdict</code> or <code>set</code></p> <pre><code>class Solution:\n    def mincostTickets(self, days: List[int], costs: List[int]) -&gt; int:\n        # problem is like climbing stairs but with more options\n        # brute force will be 365 days of 1 and 0s\n        # DP[i]: minimum cost you have to pay for traveling till brute_days[i]\n\n        days = set(days)\n        dp = [0 for _ in range(366)]\n\n        for i in range(1,366):\n            if i in days:\n                dp[i] = min(dp[max(i-1,0)] + costs[0],dp[max(i-7,0)] + costs[1],dp[max(i-30,0)] + costs[2],)\n            else:\n                dp[i] = dp[i-1]\n        return dp[-1]\n</code></pre>"},{"location":"leetcode/986-interval-list-intersections/","title":"986 Interval List Intersections","text":"<p>\u51e0\u79cd\u89e3\u6cd5</p> <ul> <li>line sweep</li> <li>two pointers, O(m+n) in time</li> </ul>","tags":["Array","Two Pointers","Line Sweep"]},{"location":"leetcode/986-interval-list-intersections/#approach-1-line-sweep","title":"Approach 1 Line Sweep","text":"<p>\u81ea\u5df1\u60f3\u51fa\u6765\u7684\uff0c\u5f88\u62c9\u8de8.</p> <pre><code>class Solution:\n    def intervalIntersection(self, firstList: List[List[int]], secondList: List[List[int]]) -&gt; List[List[int]]:\n        # each list of intervals is pairwise disjoint and sorted.\n        \"\"\"\n        instinct: gotta use the sorted feature otherwise it degenerates to O(nlogn)\n        - two pointer\n        - fancy trick\n        sweep line:\n        prev != 2, curr == 2, entering it        \n        \"\"\"\n        intervals = []\n\n        for start,end in firstList:\n            intervals.append((start,1))\n            intervals.append((end,-1))\n\n        for start,end in secondList:\n            intervals.append((start,1))\n            intervals.append((end,-1))\n\n        intervals.sort()\n\n        prev_time = -1\n        prev_cost = -1\n        res = []\n        curr_cost = 0\n        for time,cost in intervals:\n            curr_cost += cost\n            # for cases like [5,5]\n            if prev_cost + curr_cost == 1 and prev_time == time and (not res or time != res[-1][1]):\n                res.append([time,time])\n            elif prev_cost != 2 and curr_cost == 2:\n                res.append([time])\n            elif prev_cost == 2 and curr_cost != 2:\n                res[-1].append(time)\n\n            # update\n            prev_time,prev_cost = time,curr_cost     \n        return res\n</code></pre> <p>We can improve on the time complexity and readability by</p> <ul> <li>using the sorted array of <code>firstList</code> and <code>secondList</code></li> <li>make the logic more clear</li> </ul> <p>\u8bd5\u60f3\u4e00\u4e0b, firstList and secondList\u90fd\u662fsorted by start time, \u90a3\u4e48\u4ed6\u4eec\u7684end time\u81ea\u7136\u4e5f\u662fsorted. \u8fd9\u4e0d\u5c31\u662fmerge 4 sorted array\u5417\uff1frecall merge k sorted array. \u6709\u70b9\u96be\u5ea6\u7684.</p> <pre><code>Input: firstList = [[0,2],[5,10],[13,23],[24,25]], secondList = [[1,5],[8,12],[15,24],[25,26]]\nOutput: [[1,2],[5,5],[8,10],[15,23],[24,24],[25,25]]\n</code></pre>","tags":["Array","Two Pointers","Line Sweep"]},{"location":"leetcode/986-interval-list-intersections/#approach-2-two-pointers","title":"Approach 2 Two Pointers","text":"","tags":["Array","Two Pointers","Line Sweep"]},{"location":"leetcode/988-smallest-string-starting-from-leaf/","title":"988 Smallest String Starting From Leaf","text":"<p>\u8fd9\u9898tricky\u7684\u70b9\u5728\u4e8e, \u4eceleaf\u5230root, \u800c\u4e0d\u662froot to leaf.</p>","tags":["Tree","String","Depth-First Search","Breadth-First Search","Binary Tree"]},{"location":"leetcode/988-smallest-string-starting-from-leaf/#approach-1-dfs-recursive","title":"Approach 1 DFS Recursive","text":"<p>\u7531\u4e8e\u662fstring from leaf to root, \u5bfb\u627e\u6240\u6709\u7684path\u7ec4\u6210\u7684string, \u7136\u540e\u627e\u5230\u6700\u5c0f\u7684string. \u6709\u51e0\u70b9\u9700\u8981\u6ce8\u610f:</p> <ul> <li>node.val \u662f0-25\u7684\u6570\u5b57, \u4ee3\u8868a-z. \u7528<code>chr()</code> and <code>ord()</code>\u6765\u8f6c\u6362</li> <li>\u6bcf\u4e00\u6b21string concatenation, \u90fd\u662fprefix</li> </ul>","tags":["Tree","String","Depth-First Search","Breadth-First Search","Binary Tree"]},{"location":"leetcode/988-smallest-string-starting-from-leaf/#code-implementation","title":"Code Implementation","text":"<pre><code>class Solution:\n    def smallestFromLeaf(self, root: Optional[TreeNode]) -&gt; str:\n        \"\"\"\n        1. record everything to a list\n        2. cash in the results\n        observation:\n        - probably DFS\n        \"\"\"\n        def helper(node,curr):\n            if not node:\n                return None\n\n            curr = chr(ord('a') + node.val) + curr\n\n            if node.left and node.right:\n                return min(helper(node.left,curr),helper(node.right,curr))\n            if node.left:\n                return helper(node.left,curr)\n            if node.right:\n                return helper(node.right,curr)\n            return curr\n\n        return helper(root,\"\")\n</code></pre>","tags":["Tree","String","Depth-First Search","Breadth-First Search","Binary Tree"]},{"location":"leetcode/988-smallest-string-starting-from-leaf/#approach-2-bfs","title":"Approach 2 BFS","text":"<p>\u8981\u7279\u522b\u6ce8\u610fleaf node\u65f6\uff0c\u5bf9\u4e8e\u7a7a\u5b57\u7b26\u4e32\u7684\u5904\u7406</p>","tags":["Tree","String","Depth-First Search","Breadth-First Search","Binary Tree"]},{"location":"leetcode/988-smallest-string-starting-from-leaf/#code-implementation_1","title":"Code Implementation","text":"<pre><code>from collections import deque\nclass Solution:\n    def smallestFromLeaf(self, root: Optional[TreeNode]) -&gt; str:\n        if not root:\n            return None\n\n        # Add root node to deque along with its value converted to a character\n        queue = deque()        \n        smallest_string = \"\"\n        queue.append([root, chr(root.val + ord('a'))])\n\n\n        while queue:\n            # Pop the leftmost node and its corresponding string from deque\n            node, current_string = queue.popleft()\n\n            # If current node is a leaf node\n            if not node.left and not node.right:\n                # Update smallest_string if it's empty or current string is smaller\n                smallest_string = min(smallest_string, current_string) if smallest_string else current_string\n\n            # If current node has a left child, append it to deque\n            if node.left:\n                queue.append([node.left, chr(node.left.val + ord('a')) + current_string])\n\n            # If current node has a right child, append it to deque\n            if node.right:\n                queue.append([node.right, chr(node.right.val + ord('a')) + current_string])\n\n        return smallest_string\n</code></pre>","tags":["Tree","String","Depth-First Search","Breadth-First Search","Binary Tree"]},{"location":"leetcode/992-subarrays-with-k-different-integers/","title":"992 Subarrays With K Different Integers","text":"<p>Sum of the following</p> <ul> <li>max length of the subarray that ends at index 0 that it's # of uniques == k</li> <li>max length of the subarray that ends at index 1 that it's # of uniques == k ...</li> <li>max length of the subarray that ends at index n-1 that it's # of uniques == k</li> </ul> <p>Since we want it to be exactly k, so while we are moving left pointer, we must went from having distinct elements in subarray x <code>x &gt; k</code> to <code>x==k</code> to <code>x &lt; k</code>. We can simulate this process</p>","tags":["Array","Hash Table","Sliding Window","Counting"]},{"location":"leetcode/992-subarrays-with-k-different-integers/#approach-1-simulation-tle","title":"Approach 1: simulation (TLE)","text":"<p>copy hashmap\u7684cost\u592a\u9ad8\u4e86.</p> <pre><code>from collections import defaultdict\nclass Solution:\n    def subarraysWithKDistinct(self, nums: List[int], k: int) -&gt; int:\n        \"\"\"\n        observation:\n        - good subarray: length of its set == k\n        - decompose the problems into a series of subproblems ending at index i\n        - sliding window\n        Goal:\n        Sum of the following\n        - max length of the subarray that ends at index 0 that it's # of uniques == k\n        - max length of the subarray that ends at index 1 that it's # of uniques == k\n        ...\n        - max length of the subarray that ends at index n-1 that it's # of uniques == k\n        Nope, we want it to be exactly k\n        \"\"\"\n        n = len(nums)\n        res = 0\n        left = 0\n        hashmap = defaultdict(int)\n        for right,num in enumerate(nums):\n            hashmap[num] += 1            \n            while len(hashmap) &gt; k:\n                # moving left\n                hashmap[nums[left]] -= 1\n                if hashmap[nums[left]] == 0:\n                    del hashmap[nums[left]]\n                left += 1\n            # if reach here, it's the max subarray length == k\n            # that we need to see how far it can last\n            left_cp = left\n            hashmap_cp = hashmap.copy()\n            count = 0\n            while len(hashmap_cp) == k:\n                if hashmap_cp[nums[left_cp]] == 1:\n                    # \u4e0d\u80fd\u518d\u8d70\u4e86\uff0c\u5220\u6389\u5c31\u4e0d\u662f\u4e86\n                    break\n                hashmap_cp[nums[left_cp]] -= 1\n                left_cp += 1\n                count += 1\n\n            if len(hashmap) == k:\n                res += count + 1\n        return res\n</code></pre>","tags":["Array","Hash Table","Sliding Window","Counting"]},{"location":"leetcode/992-subarrays-with-k-different-integers/#approach-2-sliding-window","title":"Approach 2: sliding window","text":"<p>\u6709\u70b9\u50cfrecursion\u548cDP\u4e2d\u7684\u601d\u8def\uff0cin approach 1, \u6211\u4eec\u6709\u4e2a\u6a21\u62df\u6211\u4eec<code>x == k</code> to <code>x &lt; k</code>\u7684\u8fc7\u7a0b\uff0c\u5e76\u8ba1\u7b97count. \u4f46\u6211\u4eec\u53ef\u4ee5\u76f4\u63a5\u5ffd\u7565\u6389\u8fd9\u4e2a\u8fc7\u7a0b\u53d8\u6210\uff0c</p> <ul> <li>max length of the subarray that ends at index 0 that it's # of uniques == k</li> <li>max length of the subarray that ends at index 1 that it's # of uniques == k ...</li> <li>max length of the subarray that ends at index n-1 that it's # of uniques == k</li> </ul> <p>\u7136\u540e\u8ba1\u7b97</p> <ul> <li>max length of the subarray that ends at index 0 that it's # of uniques == k-1</li> <li>max length of the subarray that ends at index 1 that it's # of uniques == k-1 ...</li> <li>max length of the subarray that ends at index n-1 that it's # of uniques == k-1</li> </ul> <p>\u8fd9\u5c31\u53d8\u6210\u4e86\u7ecf\u5178medium sliding window\u95ee\u9898, \u6211\u4eec\u76f8\u51cf\u5373\u53ef.</p> <pre><code>from collections import defaultdict\nclass Solution:\n    def subarraysWithKDistinct(self, nums: List[int], k: int) -&gt; int:\n        def helper(nums,k):\n            n = len(nums)\n            res = 0\n            left = 0\n            hashmap = defaultdict(int)\n            for right,num in enumerate(nums):\n                hashmap[num] += 1\n                while len(hashmap) &gt; k:\n                    # moving left\n                    hashmap[nums[left]] -= 1\n                    if hashmap[nums[left]] == 0:\n                        del hashmap[nums[left]]\n                    left += 1\n                # if reach here, it's the max subarray length == k\n                # that we need to see how far it can last\n                res += right - left + 1\n            return res\n\n        return helper(nums,k) - helper(nums,k-1)\n</code></pre>","tags":["Array","Hash Table","Sliding Window","Counting"]},{"location":"leetcode/992-subarrays-with-k-different-integers/#approach-3-sliding-window-with-three-pointers","title":"Approach 3 Sliding Window with three pointers","text":"<p>Approach 1\u7684simulation:</p> <ul> <li>initialize a burner left pointer and burner hashmap to simulate the process of moving left pointer</li> </ul> <p>What if we go that this route early and keep track of another pointer sitting in the middle of left and right pointer? \u8fd9\u5c31\u662fthree pointers\u601d\u60f3.</p> <ul> <li><code>l_far</code>: the farthest left pointer such that <code>[l_far,right]</code> is the maximum subarray has k distinct elements in it</li> <li><code>l_near</code>: the left pointer such that <code>[l_near,right]</code> is the minimum subarray has k distinct elements in it</li> </ul> <p>\u800c\u4e14\u4f60\u53ea\u7ef4\u62a4\u7684hashmap, \u5b9e\u9645\u4e0a\u662f\u7ef4\u62a4\u7684\u662f<code>[l_near,right]</code>\u4e2d\u7684\u4fe1\u606f. \u4e24\u8005\u552f\u4e00\u7684\u533a\u522b\u662f\uff0c\u7ef4\u62a4<code>[l_far,right]</code>\u6bd4\u7ef4\u62a4<code>[l_near,right]</code>\u591a\u4e86\u51e0\u4e2aredundant\u5143\u7d20. </p> <p>Do a little dry run,</p> <pre><code>nums = [1,2,1,2,3], k = 2\noutput = 7\n</code></pre> l_far l_near r [l_far,r] [l_near,r] candidates 0 0 0 [1] [1] 0 0 1 [1,2] [1,2] <code>[1,2]</code> 0 1 2 [1,2,1] [2,1] <code>[2,1]</code>,<code>[1,2,1]</code> 0 2 3 [1,2,1,2] [1,2] <code>[1,2]</code>,<code>[2,1,2]</code>,<code>[1,2,1,2]</code> 3 3 4 [2,3] [2,3] <code>[2,3]</code> <pre><code>from collections import defaultdict\nclass Solution:\n    def subarraysWithKDistinct(self, nums: List[int], k: int) -&gt; int:\n        \"\"\"\n        [l_far,l_near]: largest subarray that has k distinct elements in it\n        [l_near,r]: smallest subarray that has k distinct elements in it        \n        \"\"\"\n        l_far = l_near = 0\n        res = 0\n        count = defaultdict(int)\n\n        for r in range(len(nums)):\n            count[nums[r]] += 1\n\n            while len(count) &gt; k:\n                count[nums[l_near]] -= 1\n                if count[nums[l_near]] == 0:\n                    count.pop(nums[l_near])\n                l_near += 1\n                l_far = l_near\n\n            while count[nums[l_near]] &gt; 1:\n                count[nums[l_near]] -= 1\n                l_near += 1\n\n\n            if len(count) == k:\n                res += l_near - l_far + 1\n\n        return res\n</code></pre>","tags":["Array","Hash Table","Sliding Window","Counting"]},{"location":"leetcode/997-find-the-town-judge/","title":"997 find the town judge","text":"","tags":["Array","Graph","Hash Table"]},{"location":"leetcode/997-find-the-town-judge/#997-find-the-town-judge","title":"997 Find the Town Judge","text":"<p>\u5165\u95e8\u7684\u56fe\u8bba\u9898\u76ee, \u6709\u5411\u56fe\u7684\u5165\u5ea6\u548c\u51fa\u5ea6\u7684\u5173\u7cfb, \u91cd\u70b9\u5728\u4e8e\u7406\u89e3judge\u7684\u5b9a\u4e49:</p> <ul> <li>judge\u7684\u5165\u5ea6\u662f<code>N-1</code></li> <li>judge\u7684\u51fa\u5ea6\u662f<code>0</code></li> </ul> <p>\u7528hashmap\u6765\u8bb0\u5f55\u6bcf\u4e2a\u4eba\u7684\u5165\u5ea6\u548c\u51fa\u5ea6, \u7136\u540e\u904d\u5386\u4e00\u904dhashmap, \u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684judge.</p>","tags":["Array","Graph","Hash Table"]},{"location":"leetcode/997-find-the-town-judge/#approach-1","title":"Approach 1:","text":"<pre><code>from collections import defaultdict\nclass Solution:\n    def findJudge(self, n: int, trust: List[List[int]]) -&gt; int:\n        # judge: \n        #   incoming: n-1 (every1 trust except himself)\n        #   outgoing: 0\n\n        # edge case, just 1 person then that person would be judge\n        if n == 1: return 1\n\n        incoming = defaultdict(int)\n        outgoing = defaultdict(int)\n\n        for a,b in trust:\n            incoming[b] += 1\n            outgoing[a] += 1\n\n        # check if there is one key that satisfies the above condition\n        for candidate,val in incoming.items():\n            if val == n - 1 and outgoing[candidate] == 0:\n                return candidate\n\n        return -1\n</code></pre>","tags":["Array","Graph","Hash Table"]},{"location":"string/","title":"String","text":"<p>String (\u5b57\u7b26\u4e32)\uff0c\u662f\u7531\u5b57\u7b26\u62fc\u63a5\u800c\u6210\u7684finite sequence\u3002Immutable object. \u4e00\u822c\u8bb0\u4e3a\\(s =a_{0}a_{1}\\ldots a_{n-1} \\quad(0\\le n &lt; n)\\)</p>"},{"location":"string/#_1","title":"\u5e38\u89c1\u95ee\u9898","text":"<p>\u8fd9\u4e00\u7ae0\u5728\u4ecb\u7ecd\u5b8c\u57fa\u7840\u77e5\u8bc6\u540e\uff0c\u4f1a\u6839\u636e\u5e38\u89c1\u95ee\u9898\u5206\u7c7b\u8bb2\u89e3\uff1a</p> <pre><code>flowchart TD\na(\"\u5b57\u7b26\u4e32\u95ee\u9898\")\nb(\"pattern matching\")\nc(\"substring\")\nd(\"subsequence\")\ne(\"palindrome\")\nf(\"prefix/suffix\")\n\na --&gt; b &amp; c &amp; d &amp; e &amp; f</code></pre> <p>\u4e00\u4e9b\u4e3b\u8981\u7684\u4f1a\u63a5\u89e6\u5230\u7684\u672f\u8bed\u5982\u4e0b,</p> <ul> <li><code>Null String</code>: \u7a7a\u5b57\u7b26\u4e32\uff0c\u957f\u5ea6\u4e3a0</li> <li><code>\u4e3b\u4e32</code>: \u539f\u59cb\u5b57\u7b26\u4e32, \\(s = a_{0}a_{1}\\ldots a_{n-1} \\quad(0\\le n &lt; n)\\)</li> <li><code>substring</code>: \u5728\u5b57\u7b26\u4e32\u4e2d\u4efb\u610f\u4e2a\u8fde\u7eed\u7684\u5b57\u7b26\u4e32\u6240\u7ec4\u6210\u540e\u53eb\u505asubstring, \u8868\u8fbe\u4e3a\\(s[i\\ldots j]\\) where \\(0\\le i \\le j &lt; ns\\). \u5176\u4e2d\u6709\u4e24\u4e2a\u7279\u6b8a\u7684\u5b50\u4e32\uff0c<code>prefix</code> and <code>suffix</code><ul> <li><code>prefix</code>: \u4ee5index 0\u5f00\u59cb\u7684substring, \u957f\u5ea6\u4e3ak. \u5982<code>abc</code> is a prefix for <code>abcde</code></li> <li><code>suffix</code>: \u4ee5index n-1\u5f00\u59cb\u7684substring, \u957f\u5ea6\u4e3ak. \u5982<code>cde</code> is a suffix for <code>abcde</code></li> </ul> </li> <li><code>palindrome</code>: \u56de\u6587\u4e32\uff0c\u5373\u6b63\u8bfb\u548c\u53cd\u8bfb\u90fd\u4e00\u6837\u7684\u5b57\u7b26\u4e32\u3002\u5982<code>abba</code>, <code>abcba</code></li> </ul> <p>\u4e4b\u540e\u6211\u4eec\u4f1a\u5bf9\u8fd9\u4e9b\u95ee\u9898\u7ec6\u8bb2.</p>"},{"location":"string/automata/","title":"Automata \u81ea\u52a8\u673a","text":"<p>\u8fd9\u91cc\u4e3b\u8981\u8ba8\u8bba\u786e\u5b9a\u6709\u9650\u72b6\u6001\u81ea\u52a8\u673a(deterministic finite automation (DFA)), \u8fd9\u662f\u4e00\u79cd\u6570\u5b66\u6a21\u578b\uff0c\u7528\u4e8e\u63cf\u8ff0\u6709\u9650\u4e2a\u72b6\u6001\u4e4b\u95f4\u7684\u8f6c\u79fb, \u5728DP\u95ee\u9898\u4e2d\u6211\u4eec\u7684state transition function\u5c31\u662f\u4e00\u79cd\u81ea\u52a8\u673a\u3002</p> <p>Info</p> <p>Finite State Machine (FSM)\u662f\u6700\u7b80\u5355\u7684\u4e00\u79cd\u81ea\u52a8\u673a, DFA\u662fFSM\u7684\u4e00\u79cd\u7279\u4f8b.\u6211\u4eec\u5c31\u5b66\u4e60\u8fd9\u4e2a\u95ee\u9898\u5c31\u597d\u4e86.</p>"},{"location":"string/automata/#_1","title":"\u6570\u5b66\u63cf\u8ff0","text":"<p>\u4e00\u4e2a\u81ea\u52a8\u673a\u53ef\u4ee5\u7528\u4e00\u4e2a\u4e94\u5143\u7ec4(tuple)\u6765\u63cf\u8ff0, where \\(M = \\Sigma,\\Gamma,\\mathbb{Q},\\delta,\\lambda\\)</p> <ul> <li>\\(\\Sigma\\) \u662f\u8f93\u5165\u5b57\u6bcd\u8868, \u662f\u4e00\u4e2a\u6709\u9650\u7684\u96c6\u5408</li> <li>\\(\\Gamma\\) \u662f\u8f93\u51fa\u5b57\u6bcd\u8868, \u662f\u4e00\u4e2a\u6709\u9650\u7684\u96c6\u5408</li> <li>\\(\\mathbb{Q}\\) \u662f\u72b6\u6001\u96c6\u5408.</li> <li>\\(\\delta\\): \u72b6\u6001\u8f6c\u79fb\u51fd\u6570(state transition function). \\(\\Sigma \\times \\mathbb{Q} \\rightarrow \\mathbb{Q}\\) \u662f, \u5c06\u72b6\u6001\u8f93\u5165Q\u6620\u5c04\u5230\u540e\u7eed\u72b6\u6001. \u53ef\u4ee5\u7406\u89e3\u4e3a\u63a5\u53d7\u521d\u59cb\u6761\u4ef6\u540e\uff0c\u72b6\u6001\u7684\u4e0d\u65ad\u81ea\u6211\u66f4\u65b0\u3002\u53ef\u4ee5\u7406\u89e3\u4e3a\u6570\u503c\u8ba1\u7b97\u4e2d\u5bf9\u4e8estate variable\u7684\u4e0d\u65ad\u8fed\u4ee3\u66f4\u65b0\uff0c\u8ba1\u7b97residual\u76f4\u5230\u5c0f\u4e8ecertain convergence criteria, \u7136\u540e\u6536\u655b.</li> <li>\\(\\lambda\\): \u8f93\u51fa\u51fd\u6570(output function). \\(\\Sigma  \\times \\mathbb{Q} \\rightarrow \\Gamma\\), \u5c06\u72b6\u6001\u8f93\u5165Q\u6620\u5c04\u5230\u8f93\u51fa. </li> </ul> <p>\u5982\u679c\\(\\mathbb{Q}\\)\u662f\u6709\u9650\u7684\uff0c\u90a3\u4e48\\(M\\)\u662f\u4e00\u4e2a\u6709\u9650\u81ea\u52a8\u673a.</p>"},{"location":"string/automata/#state-transition-diagram","title":"\u72b6\u6001\u8f6c\u79fb\u56fe(state transition diagram)","text":""},{"location":"string/automata/#reference","title":"Reference","text":"<ul> <li>cs standford</li> <li>lumin article</li> <li>lingero article</li> <li>OI wiki</li> </ul>"},{"location":"string/basics/","title":"String Fundamentals","text":"<p>String (\u5b57\u7b26\u4e32)\uff0c\u662f\u7531\u5b57\u7b26\u62fc\u63a5\u800c\u6210\u7684finite sequence, \u4e5f\u662f\u4e00\u79cd\u6570\u636e\u7c7b\u578b. Immutable object. \u4e00\u822c\u8bb0\u4e3a\\(s =a_{0}a_{1}\\ldots a_{n-1} \\quad(0\\le n &lt; n)\\)</p>"},{"location":"string/basics/#_1","title":"\u5b57\u7b26\u4e32\u7684\u7f16\u7801","text":"<p>\u5b57\u7b26\u4e32\u7684\u7f16\u7801\u662f\u6307\u5c06\u5b57\u7b26\u4e32\u8f6c\u6362\u4e3a\u4e8c\u8fdb\u5236\u7684\u8fc7\u7a0b\u3002\u5e38\u89c1\u7684\u7f16\u7801\u65b9\u5f0f\u6709ASCII, Unicode, UTF-8, UTF-16\u7b49\u3002</p> <p>\u9700\u8981\u7406\u89e3\u8fd9\u4e00\u7ae0\u662f\u56e0\u4e3a\u63a5\u4e0b\u6765\u7684\u5b57\u7b26\u4e32\u6bd4\u8f83\u95ee\u9898\uff0c\u90fd\u662f\u57fa\u4e8e\u5b57\u7b26\u4e32\u7684\u7f16\u7801\u6765\u8fdb\u884c\u7684\u3002\u5bf9\u4e8enumbers, \u6211\u4eecintuitive\u7684\u7406\u89e3<code>2&gt;1</code>\uff0c\u8ba1\u7b97\u673a\u6bd4\u8f832\u8fdb\u5236\u600e\u4e48\u6837\uff0c\u6211\u4eec\u53ef\u4ee5\u5b8c\u5168\u4e0d\u5728\u4e4e\u3002\u4f46<code>\u6c49\u5821&gt;\u85af\u6761</code> and <code>zeb vs abc</code>\u4f60\u600e\u4e48\u76f4\u89c2\u7684\u6bd4? \u6240\u4ee5\u5f97dig into the encoding of string.</p> <p>\u8ba1\u7b97\u673a\u5904\u7406\u6570\u5b57\u7684\u65f6\u5019\uff0c\u662f\u76f4\u63a5\u6bd4\u8f83\u4e8c\u8fdb\u5236\u7684\u5927\u5c0f\u3002\u5982\u679c\u6211\u4eec\u60f3\u505a\u4efb\u4f55<code>text processing</code>, \u5fc5\u987b\u5148\u628atext -&gt; binary. \u8fd9\u5c31\u662f\u4e3a\u4ec0\u4e48\u6211\u4eec\u9700\u8981\u4e86\u89e3\u5b57\u7b26\u4e32\u7684\u7f16\u7801\u3002\u7531\u4e8e\u6700\u65e9\u8ba1\u7b97\u673a\u662f\u7531\u7f8e\u56fd\u53d1\u660e\u7684\uff0c\u521a\u53d1\u660e\u7684\u7b2c\u4e00\u4ee3\uff0c\u53ea\u6709127\u4e2a\u5b57\u7b26, \u53ea\u653e\u4e86\u4e00\u4e9balphabet <code>a-z</code>, <code>A-Z</code>\u4e00\u4e9b\u6570\u5b57\u548c\u7b26\u53f7\u3002\u8fd9\u4e2a\u7f16\u7801\u53eb\u505aASCII, \u5176\u4e2d<code>A</code>\u7684\u7f16\u7801\u662f<code>65</code>, <code>a</code>\u7684\u7f16\u7801\u662f<code>97</code>. ASCII\u7801\u53ea\u75281 byte = 8 bits = \\(2^8\\) = <code>0-255</code></p> <p>\u7136\u540e\u9762\u4e34\u7740\u4e24\u4e2a\u95ee\u9898, </p> <ul> <li>\u968f\u7740\u9700\u6c42\uff0c\u9700\u8981\u4e0d\u65ad\u7684\u6269\u5c55\u5b57\u7b26\u96c6. ASCII\u75281 byte\u8868\u8fbe\u662f\u4e0d\u591f\u7528\u7684</li> <li>\u4e0d\u540c\u56fd\u5bb6\u6709\u4e0d\u540c\u7684\u5b57\u7b26\u96c6\uff0c\u6bd4\u5982\u4e2d\u6587\uff0c\u65e5\u6587\uff0c\u97e9\u6587\u7b49\u3002\u6bcf\u4e2a\u4eba\u90fd\u5f00\u53d1\u4e86\u81ea\u5df1\u7684\u7f16\u7801\u7cfb\u7edf\uff0c\u4e2d\u6587<code>GB2312</code>, \u97e9\u6587<code>Euc-kr</code>, \u65e5\u6587<code>Shift-JIS</code>. \u8fd9\u6837\u5c31\u5bfc\u81f4\u4e86\u4e0d\u540c\u7684\u7f16\u7801\u7cfb\u7edf\u4e4b\u95f4\u7684\u4e0d\u517c\u5bb9\u3002\u8fd9\u4e5f\u662f\u6211\u4eec\u5c0f\u65f6\u5019\u73a9\u6e38\u620f\u770b\u5230\u4e71\u7801\u7684\u539f\u56e0\u3002</li> </ul> <p>\u4e3a\u4e86\u89e3\u51b3\u8fd9\u4e24\u4e2a\u95ee\u9898, one code to rule them all, <code>unicode</code>\u5e94\u8fd0\u800c\u751f\uff0c\u628a\u6240\u6709\u7684\u8bed\u8a00\u7edf\u4e00\u5230\u4e00\u5957\u7f16\u7801\u91cc\u7684. Unicode\u4e0d\u65ad\u5728\u8fdb\u5316\uff0c\u5e38\u89c1\u7684\u6709<code>UCS-16</code>, \u9700\u89812\u4e2a\u5b57\u8282. \u8868\u8fbe\u5f88\u751f\u50fb\u7684\u7b26\u53f7\uff0c\u9700\u8981\u7528<code>UCS-32</code>, \u5360\u636e4\u4e2a\u5b57\u8282.</p> <p>\u6a2a\u5411\u6bd4\u8f83ASCII\u76841 byte, Unicode's UCS-16\u76842 bytes, \u4f60\u4f1a\u53d1\u73b0\u6781\u5927\u7684\u50a8\u5b58\u7a7a\u95f4\u6d6a\u8d39\u3002\u6211\u4eec\u62ff<code>A</code>\u4f5c\u6bd4\u65b9, </p> \u5b57\u7b26 ASCII Unicode UTF-8 A 01000001 00000000 01000001 01000001 <p>\u4f60\u4f1a\u53d1\u73b0<code>A</code>\u5728ASCII\u8f6c\u5316\u5230Unicode\u7684\u65f6\u5019\uff0c\u524d\u9762\u591a\u4e868\u4e2aleft padding zeros. \u56e0\u4e3a\u6d6a\u8d39\u7a7a\u95f4\uff0c\u6240\u4ee5\u53ef\u53d8\u957f\u7684\u7f16\u7801\u65b9\u5f0f<code>UTF-8</code>\u5e94\u8fd0\u800c\u751f\u3002UTF-8\u662f\u4e00\u79cd\u53d8\u957f\u7684\u7f16\u7801\u65b9\u5f0f\uff0c\u5b83\u53ef\u4ee5\u75281-4\u4e2abytes\u6765\u8868\u793a\u4e00\u4e2a\u5b57\u7b26\u3002\u5bf9\u4e8e\u82f1\u6587\u5b57\u7b26\uff0cUTF-8\u7f16\u7801\u548cASCII\u7f16\u7801\u662f\u4e00\u6837\u7684\u3002\u6240\u4ee5UTF-8\u517c\u5bb9ASCII. \u7efc\u4e0a\u6240\u793a\uff0c\u53d1\u5c55\u53f2\u5982\u4e0b,</p> <p></p> <p>\u5177\u4f53\u5de5\u4f5c\u7684\u65f6\u5019\uff0c\u4e0d\u7ba1\u4f60\u662f\u7528word,\u8fd8\u662f\u7528python <code>with open()</code>, \u90fd\u662f\u5c06\u50a8\u5b58\u4e8e\u786c\u76d8\u7684UTF-8\u8f6c\u5316\u4e3aunicode\u8fdb\u884c\u7f16\u8f91\u548c\u64cd\u4f5c\uff0c\u7136\u540e\u518d\u8f6c\u5316\u4e3aUTF-8\u5b58\u50a8. \u540c\u7406\uff0c\u4f60\u5728\u6d4f\u89c8\u7f51\u9875\u7684\u65f6\u5019\u53d1\u73b0\uff0cserver\u7aef\u7f51\u9875\u7684\u6e90\u4ee3\u7801\u662fUTF-8, \u4f46\u662f\u4f60\u5728\u6d4f\u89c8\u5668(\u6d4f\u89c8\u5668\u4e5f\u662fword)\u4e0a\u770b\u5230\u7684\u662f\u8f6c\u5316\u4e3aunicode\u540e\u7684, \u5982\u4e0b\u56fe\u6240\u793a</p> <p></p> <p>\u603b\u7ed3\u4e00\u4e0b, </p> <ul> <li>encoding\u662f\u4e3a\u4e86text processing\u548c\u50a8\u5b58\u800c\u670d\u52a1\u7684. \u6211\u4eec\u5b66\u4e60\u4e86\u5b83\u7684\u53d1\u5c55\u53f2\uff0c\u548c\u4e3a\u4ec0\u4e48\u9700\u8981.</li> <li>UTF-8\u7684\u5b58\u5728\u662f\u4e3a\u4e86\u89e3\u51b3unicode\u7684\u7a7a\u95f4\u6d6a\u8d39\u95ee\u9898\u7684\u77ed\u677f, \u8fd8\u517c\u5bb9ASCII, \u8282\u7701\u4e0b\u6765\u7684\u7a7a\u95f4\u5927\u5927\u63d0\u9ad8\u4e86\u5b58\u50a8efficiency\u548c\u7f51\u7edc\u4e0a\u7684\u4f20\u8f93\u6548\u7387.</li> </ul>"},{"location":"string/basics/#_2","title":"\u5b57\u7b26\u4e32\u7684\u6bd4\u8f83","text":"<p>\u5b66\u4e60\u4e86\u7f16\u7801\uff0c\u5c31\u53ef\u4ee5\u7406\u89e3string\u6bd4\u8f83\u4e86. \u4e24\u4e2a\u5b57\u7b26\u4e32<code>str1</code> and <code>str2</code>\u5982\u679c\u76f8\u7b49\u7684\u5145\u8981\u6761\u4ef6\u662f:</p> <ul> <li>\u5b57\u7b26\u4e32\u957f\u5ea6\u76f8\u7b49</li> <li>\u5bf9\u5e94\u4f4d\u7f6e\u7684\u5b57\u7b26\u76f8\u7b49</li> </ul> <p>\u6bd4\u8f83\u4e24\u4e2a\u5b57\u7b26\u4e32\u5982\u4e0b\uff0c</p> <ul> <li>from index \\(i\\) where \\(i \\in \\left[0,n-1\\right]\\), \u6328\u4e2a\u6bd4\u8f83\u5b57\u7b26<ul> <li>\u5982\u679c<code>str1[i] == str2[i]</code>, \u7ee7\u7eed\u6bd4\u8f83\u4e0b\u4e00\u4e2a\u5b57\u7b26</li> <li>\u5982\u679c<code>str1[i] &lt; str2[i]</code>, \u5219<code>str1</code> &lt; <code>str2</code>, \u6bd4\u5982<code>abc</code> &lt; <code>abd</code></li> <li>\u5982\u679c<code>str1[i] &gt; str2[i]</code>, \u5219<code>str1</code> &gt; <code>str2</code>, \u6bd4\u5982<code>abz</code> &gt; <code>aby</code></li> </ul> </li> <li>\u5982\u679c\u6bd4\u8f83\u5230\uff0c\u6700\u540e\u4e00\u4e2a\u5b57\u7b26\uff0c\u5176\u4e2d\u4e00\u4e2a\u5b57\u7b26\u4e32\u5df2\u7ecf\u7ed3\u675f\u4e86\uff0c\u53e6\u4e00\u4e2a\u5b57\u7b26\u4e32\u8fd8\u6709\u5b57\u7b26\uff0c\u90a3\u4e48\u957f\u5ea6\u957f\u7684\u5b57\u7b26\u4e32\u5927. \u6bd4\u5982<code>abc</code> &lt; <code>abcd</code>.<ul> <li>\u5982\u679c<code>str1</code>\u7ed3\u675f\u4e86\uff0c<code>str2</code>\u8fd8\u6709\u5b57\u7b26\uff0c\u90a3\u4e48<code>str1</code> &lt; <code>str2</code>, \u6bd4\u5982<code>abc</code> &lt; <code>abcd</code>.</li> </ul> </li> <li>\u5982\u679c\u6bd4\u8f83\u5230\uff0c\u6700\u540e\u4e00\u4e2a\u5b57\u7b26\uff0c\u4e24\u4e2a\u5b57\u7b26\u4e32\u90fd\u7ed3\u675f\u4e86\uff0c\u90a3\u4e48\u4e24\u4e2a\u5b57\u7b26\u4e32\u76f8\u7b49. \u6bd4\u5982<code>abc</code> == <code>abc</code>.</li> </ul> ASCII <p>A-Z: 65-90, a-z: 97-122. \u5927\u5199\u5728\u5c0f\u5199\u524d\u9762.</p> <p>\u7531\u4ee5\u4e0a\u89c4\u5219\uff0c\u6211\u4eec\u53ef\u4ee5design a <code>strcmp</code> method, \u5982\u4e0b\uff0c</p> <ul> <li>\u5982\u679c<code>str1</code> &lt; <code>str2</code>, \u8fd4\u56de-1</li> <li>\u5982\u679c<code>str1</code> == <code>str2</code>, \u8fd4\u56de0</li> <li>\u5982\u679c<code>str1</code> &gt; <code>str2</code>, \u8fd4\u56de1</li> </ul> <pre><code>def strcmp(str1, str2):\n    index1, index2 = 0, 0\n    while index1 &lt; len(str1) and index2 &lt; len(str2):\n        if ord(str1[index1]) == ord(str2[index2]):\n            index1 += 1\n            index2 += 1\n        elif ord(str1[index1]) &lt; ord(str2[index2]):\n            return -1\n        else:\n            return 1\n\n    if len(str1) &lt; len(str2):\n        return -1\n    elif len(str1) &gt; len(str2):\n        return 1\n    else:\n        return 0\n</code></pre>"},{"location":"string/basics/#reference","title":"Reference","text":"<ul> <li>\u7b97\u6cd5\u901a\u5173\u624b\u518c</li> </ul>"},{"location":"string/pattern_matching/","title":"String Pattern Matching","text":"<p>Pattern Matching (\u6a21\u5f0f\u5339\u914d): \u7ed9\u5b9a\u5b57\u7b26\u4e32\\(S\\)\u548c\\(T\\), \u5728\u4e3b\u4e32\\(S\\)\u4e2d\u627e\u5230\u6a21\u5f0f\u4e32\\(T\\)\u7684\u4f4d\u7f6e. </p> <p>\u6839\u636e\u7c7b\u578b\uff0c\u53ef\u4ee5\u5206\u4e3a</p> <ul> <li><code>\u5355\u4e32\u5339\u914d</code>: \u53ea\u6709\u4e00\u4e2apattern string\u548c\u4e00\u4e2a\u4e3b\u4e32\uff0c\u627e\u51fa\u524d\u8005\u5728\u540e\u8005\u4e2d\u7684\u6240\u6709\u4f4d\u7f6e\u3002</li> <li><code>\u591a\u4e32\u5339\u914d</code>: \u6709\u591a\u4e2apattern string\u548c\u4e00\u4e2a\u4e3b\u4e32\uff0c\u627e\u51fa\u6bcf\u4e2apattern string\u5728\u4e3b\u4e32\u4e2d\u7684\u4f4d\u7f6e\u3002<ul> <li>\u53ef\u4ee5\u76f4\u63a5\u7528<code>\u5355\u4e32\u5339\u914d</code>\u7684\u65b9\u6cd5\uff0c\u4e00\u4e2a\u4e00\u4e2a\u627e\uff0c\u4f46\u6548\u7387\u5f88\u4f4e\u3002</li> </ul> </li> <li><code>\u5176\u4ed6\u7c7b\u578b</code>: \u5339\u914d\u4e32\u7684\u4efb\u610f\u540e\u7f00\uff0c\u6216\u8005\u5339\u914d\u591a\u4e2a\u4e32\u7684\u4efb\u610f\u540e\u7f00\u3002<ul> <li>\u8fd9\u79cd\u7b97\u662f<code>partial string pattern matching</code>\u4e86\uff0cpartial string\u5176\u5b9e\u4e5f\u5c31\u662fsubstring, prefix is substring starting from index <code>0</code>, suffix is substring ending at index <code>n-1</code>.</li> </ul> </li> </ul>"},{"location":"string/pattern_matching/#string-pattern-matching_1","title":"string pattern matching \u5e94\u7528","text":"<p>pattern matching\u51e0\u4e4e\u662f\u6240\u6709\u5b57\u7b26\u4e32\u5904\u7406\u7684\u57fa\u7840\uff0c\u56e0\u6b64\u6709\u5f88\u591a\u5e94\u7528\u573a\u666f\uff0c\u6bd4\u5982\uff1a</p> <ul> <li>command + F: \u641c\u7d22\u4f60\u60f3\u8981\u7684\u6587\u5b57,\u5728IDE, browser etc</li> </ul>"},{"location":"string/pattern_matching/single_pattern_matching/brute_force/","title":"Brute Force","text":"<p>Brute Force: \u66b4\u529b\u5339\u914d, \u4e5f\u53eb\u6734\u7d20\u5339\u914d\u7b97\u6cd5 (naive string matching), \u662f\u4e00\u79cd\u7b80\u5355\u76f4\u63a5\u7684\u5b57\u7b26\u4e32\u5339\u914d\u7b97\u6cd5. \u8be5\u7b97\u6cd5\u7684\u57fa\u672c\u601d\u60f3\u662f: \u4ece\u4e3b\u4e32\\(T\\)\u7684\u7b2c\u4e00\u4e2a\u5b57\u7b26\u5f00\u59cb, \u4f9d\u6b21\u6bd4\u8f83\u4e3b\u4e32\\(T\\)\u548c\u6a21\u5f0f\u4e32\\(P\\)\u7684\u5b57\u7b26, \u5982\u679c\u76f8\u7b49, \u7ee7\u7eed\u6bd4\u8f83\u4e0b\u4e00\u4e2a\u5b57\u7b26, \u5982\u679c\u4e0d\u76f8\u7b49, \u4e3b\u4e32\\(T\\)\u7684\u6307\u9488\u540e\u9000\u4e00\u4f4d, \u6a21\u5f0f\u4e32$P\u7684\u6307\u9488\u5f52\u96f6, \u91cd\u65b0\u5f00\u59cb\u5339\u914d. \u8fd9\u79cd\u7b97\u6cd5\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u662fO(m*n), \u5176\u4e2dm\u548cn\u5206\u522b\u662f\u4e3b\u4e32\u548c\u6a21\u5f0f\u4e32\u7684\u957f\u5ea6. \u7531\u4e8e\u8be5\u7b97\u6cd5\u7684\u6548\u7387\u8f83\u4f4e, \u56e0\u6b64\u5728\u5b9e\u9645\u5e94\u7528\u4e2d\u5f88\u5c11\u4f7f\u7528.</p>"},{"location":"string/pattern_matching/single_pattern_matching/brute_force/#_1","title":"\u601d\u8def","text":"<ol> <li>\u8ba1\u7b97\u6a21\u5f0f\u4e32\u7684\u957f\u5ea6\\(m\\)\u548c\u4e3b\u4e32\u7684\u957f\u5ea6\\(n\\), \u7528\u4e24\u4e2a\u6307\u9488\\(i\\)\u548c\\(j\\)\u5206\u522b\u6307\u5411\u4e3b\u4e32\u548c\u6a21\u5f0f\u4e32\u7684\u7b2c\u4e00\u4e2a\u5b57\u7b26.</li> <li>\u540c\u65f6traverse\u4e3b\u4e32\u548c\u6a21\u5f0f\u4e32, \\(T[i]\\) and \\(P[j]\\)<ol> <li>\u5982\u679c\u76f8\u7b49\uff0cadvance both pointers\u76f4\u5230\u8d70\u5230\u6a21\u5f0f\u4e32\u7684\u672b\u5c3e</li> <li>\u5982\u679c\u4e0d\u76f8\u7b49\uff0c\u5219reset i's pointer \u5230\u5e94\u8be5\u5339\u914d\u7684\u4e0b\u4e00\u4e2a\u4f4d\u7f6e\uff0creset j's pointer \u5230\u6a21\u5f0f\u4e32\u7684\u5f00\u5934</li> </ol> </li> <li>\u5982\u679c\u4e3b\u4e32\u6216\u8005\u6a21\u5f0f\u4e32\u8d70\u5230\u4e86\u672b\u5c3e\uff0c\u5219\u8fd4\u56de\u5339\u914d\u7684\u8d77\u59cb\u4f4d\u7f6e</li> </ol>"},{"location":"string/pattern_matching/single_pattern_matching/brute_force/#_2","title":"\u4ee3\u7801\u5b9e\u73b0","text":"<pre><code>def brute_force(T,P):\n    n,m = len(T), len(P)\n    i,j = 0,0\n    while i &lt; n and j &lt; m:\n        if T[i] == P[j]:\n            i += 1\n            j += 1\n        else:\n            # not matching, reset to i-j, move to next by increment 1\n            i = i - j + 1\n            j = 0\n\n    # \u5230\u8fd9\u91cc\u6709\u4e24\u79cd\u60c5\u51b5\n    # 1. j == m, \u8bf4\u660e\u627e\u5230\u4e86\u5339\u914d\u7684\u6a21\u5f0f\u4e32, \u7b49\u4ef7\u4e8eexhaust all pattern string\n    # 2. \u5176\u5b83\u4efb\u4f55\u60c5\u51b5\u90fd\u662f\u6ca1\u627e\u5230\n    if j == m:\n        return i - j\n    else:\n        return -1\n</code></pre>"},{"location":"string/pattern_matching/single_pattern_matching/brute_force/#_3","title":"\u590d\u6742\u5ea6\u5206\u6790","text":"<p>Time complexity\u662f\\(O(m*n)\\), \u5176\u4e2d\\(m\\)\u548c\\(n\\)\u5206\u522b\u662f\u4e3b\u4e32\u548c\u6a21\u5f0f\u4e32\u7684\u957f\u5ea6\uff0c\u4e0d\u662f\u5f88\u9ad8\u6548\u7684\u7b97\u6cd5\uff0c\u6709\u91cd\u590d\u8ba1\u7b97\u7684\u98ce\u9669. Worst case\u662f</p> <pre><code>T = 'aaaaaaaaaa'\nP = 'aaaf'\n</code></pre> <p>\u53ef\u4ee5\u770b\u5230\uff0c\u6211\u4eec\u6bcf\u4e00\u6b21\u5339\u914d\uff0c\u90fd\u4f1a\u6bd4\u8f83\u5230\u6700\u540e\u4e00\u6b21\uff0c\u7136\u540e\u624d\u4f1a\u53d1\u73b0\u4e0d\u5339\u914d\uff0c\u7136\u540e\u91cd\u7f6ei\u548cj\u7684\u6307\u9488. \u4f46\u6211\u4eec\u660e\u660e\u77e5\u9053\uff0c\u5982\u679c\u524d\u9762\u7684\u5b57\u7b26\u90fd\u662fa\uff0c\u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u76f4\u63a5\u8df3\u5230\u6700\u540e\u4e00\u4e2aa\u7684\u4f4d\u7f6e\uff0c\u800c\u4e0d\u9700\u8981\u4e00\u4e2a\u4e00\u4e2a\u7684\u6bd4\u8f83. \u8fd9\u5c31\u662fBrute Force\u7684\u7f3a\u70b9\uff0c\u91cd\u590d\u8ba1\u7b97, \u8fd9\u5c31\u662f\u6211\u4eec\u53ef\u4ee5\u4f18\u5316\u7684\u7a7a\u95f4\u6240\u5728\u3002</p>"},{"location":"string/pattern_matching/single_pattern_matching/kmp/","title":"KMP","text":"<p>KMP\u662f\u4e00\u4e2a\u9ad8\u6548\u7684\u5b57\u7b26\u4e32\u5339\u914d\u7b97\u6cd5\uff0c\u5b83\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u662fO(m+n)\uff0c\u5176\u4e2dm\u662fpattern\u7684\u957f\u5ea6\uff0cn\u662ftext\u7684\u957f\u5ea6. </p> <p>KMP\u6709\u4e24\u4e2a\u96be\u70b9\uff0c</p> <ul> <li>\u5982\u4f55\u7406\u89e3<code>next</code>\u6570\u7ec4\uff0c\u4ee5\u53ca\u5982\u4f55\u751f\u6210<code>next</code>\u6570\u7ec4.</li> <li>\u5982\u4f55\u5229\u7528<code>next</code>\u6570\u7ec4\u6765\u4f18\u5316\u5339\u914d\u8fc7\u7a0b</li> </ul>"},{"location":"string/pattern_matching/single_pattern_matching/kmp/#kmp_1","title":"KMP\u7684\u5e94\u7528","text":"<p>KMP\u867d\u7136\u5feb\uff0c\u4f46\u5f88\u5c11\u88abbuilt-in function\u4f7f\u7528\u3002KMP\u64c5\u957f\u7684\u662fpattern string\u6709\u5f88\u591aduplicate substring\u7684\u5de5\u51b5\uff0cin real-world strings, \u4f60\u5728ctrl + F\u65f6\uff0c\u5f88\u5c11\u9047\u5230\u9700\u8981KMP\u7684\u5de5\u51b5\u3002Plus, it requires O(n) space. \u4f46\u5728DNA sequencing\u4e2d\uff0c\u8fd9\u662f\u4e00\u4e2a\u5f88\u597d\u7684\u7b97\u6cd5\uff0c\u56e0\u4e3aDNA\u4e2d\u6709\u5f88\u591a\u91cd\u590d\u7684\u5e8f\u5217, \u8fd9\u4e5f\u662fKMP\u6700\u4e3b\u8981\u7684\u5e94\u7528\u573a\u666f\u4e4b\u4e00.</p> <p>\u601d\u8003\u9898</p> <p>\u5982\u679c\u4f60\u7684pattern string\u4e3a<code>abcde</code>, \u4f60\u7684next\u6570\u7ec4\u662f\u5168\u4e3a0\uff0c\u90a3\u4e48\u4f60\u7684KMP\u7b97\u6cd5\u4f1a\u9000\u5316\u6210?</p>"},{"location":"string/pattern_matching/single_pattern_matching/kmp/#next","title":"next\u6570\u7ec4","text":"<p>next\u6570\u7ec4\uff0c\u4e5f\u53eblongest prefix suffix (LPS) \u6570\u7ec4 or \u524d\u7f00\u6570\u7ec4\uff0c\u662f\u57fa\u4e8epattern string\u751f\u6210\u7684\u4e00\u4e2a\u6570\u7ec4\uff0c\u7528\u6765\u5e2e\u52a9\u6211\u4eec\u5728\u5339\u914d\u7684\u65f6\u5019\uff0c\u8df3\u8fc7\u4e00\u4e9b\u4e0d\u5fc5\u8981\u7684\u6bd4\u8f83. </p> <p>\\(\\pi[i]\\)\u7684\u5b9a\u4e49\u4e3a: \u4eceindex 0\u5230index i\u7684\u5b50\u4e32\u4e2d\uff0c\u6700\u957f\u4e14\u76f8\u7b49\u7684\u4ece0\u5f00\u59cb\u7684\u524d\u7f00\u548c\u540e\u7f00ending in i. </p> <p>\u524d\u540e\u7f00\u5b9a\u4e49</p> <ul> <li>\u524d\u7f00\uff1a\u4e0d\u5305\u62ec\u6700\u540e\u4e00\u4e2a\u5b57\u7b26\u7684\u6240\u6709\u4ee5\u7b2c\u4e00\u4e2a\u5b57\u7b26\u5f00\u5934\u7684\u6240\u6709\u5b57\u7b26</li> <li>\u540e\u7f00\uff1a\u4e0d\u5305\u62ec\u7b2c\u4e00\u4e2a\u5b57\u7b26\u7684\u6240\u6709\u4ee5\u6700\u540e\u4e00\u4e2a\u5b57\u7b26\u7ed3\u5c3e\u7684\u6240\u6709\u5b57\u7b26</li> </ul> <p>\u4e3e\u4e2a\u4f8b\u5b50, </p> <p></p> substring lps prefix suffix \"a\" 0 \"ab\" 0 \"abc\" 0 \"abca\" 1 \"a\" \"a\" \"abcab\" 2 \"ab\" \"ab\" \"abcabf\" 0 <p>\u6211\u4eec\u6570\u5b66\u63cf\u8ff0\u4e00\u4e0b, for a string <code>s</code></p> \\[ \\pi[i] = \\begin{cases}          0 \\quad i = 0 \\\\       \\max_{j=0...i} \\{j: s[0:j-1] = s[i-(j-1):i]\\} \\quad otherwise\\\\    \\end{cases} \\]"},{"location":"string/pattern_matching/single_pattern_matching/kmp/#approach-1","title":"Approach 1 \u66b4\u529b\u751f\u6210\u524d\u7f00\u6570\u7ec4 (\u6210\u957f\u671f)","text":"<ul> <li>\u521d\u59cb\u5316\u4e00\u4e2a\u957f\u5ea6\u4e3an\u7684\u6570\u7ec4pi\uff0c\u5168\u90e8\u5143\u7d20\u521d\u59cb\u5316\u4e3a0, \u521d\u59cb\u6761\u4ef6\u662fpi[0] = 0.</li> <li>\u4ecei=1\u5f00\u59cb\u904d\u5386\uff0c\u5bf9\u4e8e\u6bcf\u4e00\u4e2ai\uff0c\u6211\u4eec\u627e\u5230\u6700\u5927\u7684j\uff0c\u4f7f\u5f97<code>s[0:j] == s[i-j+1:i]</code>. \u7531\u4e8e\u6211\u4eec\u53ea\u5173\u5fc3\u6700\u5927\u7684,\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u628aj\u4ece\u540e\u5f80\u524dtraverse, \u4e00\u65e6\u627e\u5230\u4e00\u4e2aj\u4f7f\u5f97<code>s[0:j] == s[i-j+1:i]</code></li> </ul> <pre><code>def prefix_function(s):\n    n = len(s)\n    pi = [0] * n\n    for i in range(1, n):\n        for j in range(i, -1, -1):\n            # right hand exclusive, so it's [i-j+1:i+1] instead of [i-j+1:i]\n            # string comparison also costs O(n)\n            if s[0 : j] == s[i - j + 1 : i + 1]:\n                pi[i] = j\n                break\n    return pi\n</code></pre> <p>Traversal cost \\(O(n^2)\\), \u52a0\u4e0astring comparison costs \\(O(n)\\). The total time complexity is \\(O(n^3)\\).</p>"},{"location":"string/pattern_matching/single_pattern_matching/kmp/#approach-2","title":"Approach 2 \u4f18\u5316\u751f\u6210\u524d\u7f00\u6570\u7ec4 (\u6210\u719f\u671f)","text":"<p>Inner iterator <code>j</code> \u4e0d\u9700\u8981\u662f\u904d\u5386<code>n</code>\uff0c\u6211\u4eec\u53ef\u4ee5\u7f29\u5c0f\u8303\u56f4\u4e3a\u904d\u5386<code>pi[i-1]+1</code>. \u8fd9\u4e00\u70b9\uff0c\u5229\u7528\u7684\u6027\u8d28\u662f</p> <ul> <li><code>max(pi[i] - pi[i-1]) == 1</code>, pi\u6570\u7ec4\u4e2d\u4e0b\u4e00\u4e2aelement\u5982\u679c\u589e\u52a0\uff0c\u81f3\u591a\u589e\u52a01.</li> <li>\u4e0a\u4e00\u4e2a\u6570\u7ec4\u7684\u6700\u957f\u524d\u7f00\u957f\u5ea6<code>pi[i-1]</code>\u662f\u6211\u4eec\u7684candidate char.</li> </ul> <p>Starting from <code>j = pi[i-1]+1</code>. \u7136\u540e\u6211\u4eec\u4e00\u76f4\u5f80\u524d\u6bd4\uff0c\u76f4\u5230\u627e\u5230\u4e00\u4e2a\u76f8\u7b49\u7684\u524d\u540e\u7f00\uff0c\u6216\u8005j=0.</p> <pre><code>def prefix_function(s):\n    n = len(s)\n    pi = [0] * n\n    for i in range(1, n):\n        for j in range(pi[i - 1] + 1, -1, -1):\n            if s[0 : j] == s[i - j + 1 : i + 1]:\n                pi[i] = j\n                break\n    return pi\n</code></pre> <p>\u4f46\u8fd9\u4e5f\u7b97minor improvement, time complexity is \\(O(n^2)\\), \u6709\u5174\u8da3\u770b\u63a8\u5bfc\u7684\uff0c\u8f97\u8f6c\u5230OI wiki.</p>"},{"location":"string/pattern_matching/single_pattern_matching/kmp/#approach-3","title":"Approach 3 \u7a76\u6781\u4f53","text":"<p>\u63a5\u7740Approach 2\u4e2d\u5f53decrement by 1, \u6211\u4eec\u80fd\u5426\u8ba9\u5b83decrement by more\u5462? </p> <p>\u6362\u53e5\u8bdd\u8bf4\uff0c\u6211\u4eec\u9047\u5230\u4e00\u4e2a\u65b0\u7684<code>i</code>, \u76f4\u63a5\u6bd4\u8f83<code>s[i] != s[pi[i-1]]</code>\uff0c</p> <ul> <li><code>s[i]</code>: \u65b0\u7684\u55f7\u55f7\u5f85\u54fa\u7684character.</li> <li><code>s[pi[i-1]]</code>: \u4e0a\u4e00\u4e2aiterator <code>i-1</code>\u6240\u7ed3\u5c3e\u7684\u6570\u7ec4\u7684\u6700\u957f\u524d\u7f00\u957f\u5ea6. \u7531\u4e8e0-indexed, \u6240\u4ee5\u8fd9\u4e2a\u6b63\u597d\u5c31\u662f\u6211\u4eec\u8981\u6bd4\u8f83\u7684potential char.</li> </ul> <p>Dry run\u89c1\u4e0b\u56fe</p> <p></p> <pre><code>def prefix_function(s):\n    n = len(s)\n    pi = [0] * n\n    for i in range(1, n):\n        # j \u4ece\u524d\u4e00\u4e2api[i-1]\u7684\u503c\u5f00\u59cb\u904d\u5386\n        j = pi[i - 1]\n\n        # \u5982\u679c\u4e0b\u4e00\u4e2a\u4e0d\u540c\uff0c\u6211\u7ee7\u7eed\u5f80\u524dbacktrack, \u4e0d\u540c\u4e8eapproach 2\u7684decrement by 1, \u6211\u4eec\u662f\u8df3\u8dc3\u7740\u51cf\u5c11, \u6700\u540e\u6536\u655b\u4e8epi[0] == 0\n        while j &gt; 0 and s[i] != s[j]:\n            j = pi[j - 1]\n\n        # \u8df3\u51fa\u5faa\u73af\u540e\u4e24\u79cd\u60c5\u51b5:\n        # 1. j == 0, \u8bf4\u660e\u6ca1\u6709\u627e\u5230\u76f8\u540c\u7684\u524d\u540e\u7f00, do nothing\n        # 2. s[i] == s[j], \u8bf4\u660e\u627e\u5230\u76f8\u540c\u7684\u524d\u540e\u7f00, \u627e\u5230increment by 1\n        if s[i] == s[j]:\n            j += 1\n            pi[i] = j\n        else:\n            pi[i] = j\n    return pi\n</code></pre> <p>\u597d\u4e86\uff0c\u73b0\u5728\u8bb2\u5b8c\u4e86\u524d\u7f00\u51fd\u6570next\u7684\u524d\u4e16\u4eca\u751f\uff0c\u6211\u4eec\u6765\u8bb2\u4e00\u4e0b\u524d\u7f00\u51fd\u6570\u7684\u5e94\u7528</p>"},{"location":"string/pattern_matching/single_pattern_matching/kmp/#_1","title":"\u524d\u7f00\u51fd\u6570\u7684\u5e94\u7528","text":""},{"location":"string/pattern_matching/single_pattern_matching/kmp/#1-kmp","title":"1. KMP\u627e\u5b50\u4e32","text":"<p>\u7ed9\u4f60\u4e00\u4e2a\u4e3b\u4e32T\u548c\u4e00\u4e2a\u6a21\u5f0f\u4e32p\uff0c\u4f60\u8981\u5728T\u4e2d\u627e\u5230p\u7b2c\u4e00\u6b21\u51fa\u73b0\u7684index\u3002\u5982\u679c\u627e\u4e0d\u5230\uff0c\u8fd4\u56de-1\u3002</p> <pre><code># KMP \u5339\u914d\u7b97\u6cd5\uff0cT \u4e3a\u6587\u672c\u4e32\uff0cp \u4e3a\u6a21\u5f0f\u4e32\ndef kmp(T: str, p: str) -&gt; int:\n    n, m = len(T), len(p)\n\n    # \u751f\u6210\u524d\u7f00\u6570\u7ec4\n    pi = generate_lps(p)                      \n\n    # j \u4e3a\u6a21\u5f0f\u4e32\u4e2d\u5f53\u524d\u5339\u914d\u7684\u4f4d\u7f6e, i \u4e3a\u6587\u672c\u4e32\u4e2d\u5f53\u524d\u5339\u914d\u7684\u4f4d\u7f6e, i\u4ece\u4e0d\u56de\u9000, j\u4f1a\u6839\u636enext\u6570\u7ec4\u56de\u9000\n    j = 0\n    for i in range(n):\n        # \u5982\u679c\u6a21\u5f0f\u4e32\u524d\u7f00\u5339\u914d\u4e0d\u6210\u529f, \u5c06\u6a21\u5f0f\u4e32\u8fdb\u884c\u56de\u9000, j == 0 \u65f6\u505c\u6b62\u56de\u9000\n        while j &gt; 0 and T[i] != p[j]:\n            j = pi[j - 1]\n        # \u5f53\u524d\u6a21\u5f0f\u4e32\u524d\u7f00\u5339\u914d\u6210\u529f\uff0c\u4ee4 j += 1\uff0c\u7ee7\u7eed\u5339\u914d\n        if T[i] == p[j]:\n            j += 1\n        # \u5f53\u524d\u6a21\u5f0f\u4e32\u5b8c\u5168\u5339\u914d\u6210\u529f\uff0c\u8d70\u5230\u6a21\u5f0f\u4e32\u7684tail\u4e86, return \u5339\u914d\u7684\u8d77\u59cbindex\n        if j == m:\n            return i - j + 1\n    # \u5339\u914d\u5931\u8d25\uff0c\u8fd4\u56de -1\n    return -1\n</code></pre>"},{"location":"string/pattern_matching/single_pattern_matching/kmp/#_2","title":"\u76f8\u5173\u9898\u76ee","text":"<ul> <li>26 implement strstr and solution here</li> </ul>"},{"location":"string/pattern_matching/single_pattern_matching/kmp/#reference","title":"Reference","text":"<ul> <li>Abdul,\u9002\u5408\u7406\u89e3KMP concept</li> <li>KMP by Neetcode, \u770b\u524d15\u5206\u949f\u5373\u53ef\uff0c\u8fd9\u65f6\u5019\u601d\u8def\u8fd8\u4e0d\u6e05\u6670</li> <li>lijingran's blog\u8bb2\u7684\u5f88\u7b80\u6d01</li> <li>LC CHN \u7406\u89e3next\u6570\u7ec4\u662f\u600e\u4e48\u751f\u6210\u7684</li> </ul>"},{"location":"techniques/","title":"Techniques","text":"<p>In this section, it has information on the common techniques such as <code>two pointer</code>, <code>sliding window</code> and <code>prefix sum</code>. Those are mainly techniques since they are not a specific data structure or algorithm. It's just a way to manipulate data structure to solve a problem, often combined with some algorithm such as binary search.</p>"},{"location":"techniques/greedy/","title":"Greedy (\u8d2a\u5fc3\u7b97\u6cd5)","text":"<p>\u8d2a\u5fc3\u7b97\u6cd5, \u662f\u6307\u5728\u6bcf\u4e00\u6b65\u9009\u62e9\u4e2d\u90fd\u91c7\u53d6\u5728\u5f53\u524d\u72b6\u6001\u4e0b\u6700\u597d\u6216\u6700\u4f18\u7684\u9009\u62e9, \u4ece\u800c\"\u5e0c\u671b\"\u5bfc\u81f4\u7ed3\u679c\u662f\u5168\u5c40\u6700\u597d\u6216\u6700\u4f18\u7684\u7b97\u6cd5. \u662f\u6ca1\u6709\u6a21\u7248\u7684, \u96be\u70b9\u5728\u4e8e\u5982\u4f55\u8bc1\u660e\u8d2a\u5fc3\u7684\u6b63\u786e\u6027. \u901a\u5e38\u8981\u7528\u6570\u5b66\u5f52\u7eb3\u6cd5\uff0c\u53cd\u8bc1\u6cd5\u53bb\u8bc1\u660e\u540e\u4f7f\u7528\uff0c\u6216\u8005\u76f4\u63a5\u61f5(\u4e0d\u4e00\u5b9a\u80fd\u8fc7).</p> <p>\u63a2\u9669\u7b97\u6cd5\u7684\u51e0\u4e2a\u7279\u70b9\u662f:</p> <ul> <li>\u5f88\u96be\u8bc1\u660e\uff1b\u4e5f\u5f88\u96be\u60f3\u5230\u4f60\u7684\u8d2a\u5fc3\u7b56\u7565\u662f\u4ec0\u4e48</li> <li>\u4e0d\u4f1a\u56de\u6eaf\uff0c\u56e0\u4e3a\u8d2a\u5fc3\u7b97\u6cd5\u4e00\u65e6\u505a\u51fa\u9009\u62e9 at time <code>t</code>\uff0c\u5c31\u4e0d\u4f1a\u6539\u53d8\u8fc7\u53bb\u7684\u9009\u62e9 (<code>0..t-1</code>)\u3002\u4e00\u65e6\u6539\u53d8\u4e86\uff0c\u90a3\u5c31\u662fdp. \u8fd9\u79cd\u6027\u8d28\u53eb\u65e0\u540e\u6548\u6027, \u901a\u5e38\u4f60\u53ef\u4ee5\u901a\u8fc7\u8fd9\u4e2a\u6765\u9a8c\u8bc1\u4f60\u7684\u8d2a\u5fc3\u7684\u7b56\u7565\u662f\u5426\u6ee1\u8db3\u8fd9\u4e2a\u6761\u4ef6\uff0c\u662f\u5fc5\u8981\u6761\u4ef6.\u8d2a\u5fc3\u7b97\u6cd5\uff0c\u6700\u591a\u53ea\u4fdd\u5b58\u524d\u4e00\u6b65\u7684\u6700\u4f18\u89e3, prev and curr two pointer\u8db3\u591f\u4e86.</li> <li>\u5e7f\u5ea6\u4f18\u5148\uff0cDijkstras algorithm\u90fd\u5c5e\u4e8egreedy. \u53ea\u662f\u5728\u5176\u95ee\u9898\u7b56\u7565\u7684\u9009\u62e9\u4e0a\uff0c\u521a\u597d\u5f97\u5230\u6700\u4f18\u89e3. \u66f4\u4e25\u8c28\u7684\u8bf4\uff0c\u662f\u5176\u7b97\u6cd5\u90e8\u5206\u6b65\u9aa4\uff0c\u7528\u4e86\u8d2a\u5fc3\u7684\u601d\u8def. </li> </ul> <p>\u57fa\u672c\u89e3\u9898\u601d\u8def:</p> <ul> <li>\u5efa\u7acb\u6570\u5b66\u6a21\u578b\u6765\u63cf\u8ff0\u95ee\u9898.</li> <li>\u628a\u6c42\u89e3\u7684\u95ee\u9898\u5206\u6210\u82e5\u5e72\u4e2a\u5b50\u95ee\u9898.</li> <li>\u5bf9\u6bcf\u4e00\u4e2a\u5b50\u95ee\u9898\u6c42\u89e3\uff0c\u5f97\u5230\u5b50\u95ee\u9898\u7684\u5c40\u90e8\u6700\u4f18\u89e3.</li> <li>\u628a\u5b50\u95ee\u9898\u7684\u89e3\u5c40\u90e8\u6700\u4f18\u89e3\u5408\u6210\u539f\u6765\u95ee\u9898\u7684\u4e00\u4e2a\u8fd1\u4f3c\u6700\u4f18\u89e3.</li> </ul> <p>\u7ed9\u94b1\u95ee\u9898</p> <p>\u4e2d\u56fd\u7684\u8d27\u5e01\uff0c\u53ea\u770b\u5143\uff0c\u67091\u5143\uff0c2\u5143\uff0c5\u5143\uff0c10\u5143\uff0c20\u5143\uff0c50\u5143\uff0c100\u5143\u3002\u5982\u679c\u6211\u898116\u5143\uff0c\u53ef\u4ee5\u62ff16\u4e2a1\u5143\uff0c\u6216\u80058\u4e2a2\u5143\uff0c\u4f46\u600e\u4e48\u6837\u80fd\u7528\u6700\u5c11\u7684\u5f20\u6570\u6765\u51d1\u51fa16\u5143\u5462\uff1f\u5982\u679c\u7528\u8d2a\u5fc3\u7b56\u7565\uff0c\u5c31\u662f\u6211\u4eec\u6bcf\u4e00\u6b21\u62ff\u90a3\u5f20\u9762\u503c\u6700\u5927\u7684\u94b1\u3002\u6bd4\u5982\u76ee\u6807\u662f16\u5143\uff0c\u6211\u4eec\u5148\u62ff20\u62ff\u4e0d\u8d77\uff0c\u5c31\u62ff10\u5143\uff0c\u8fd8\u4e0d\u591f\uff0c\u5c31\u62ff5\u5143\uff0c\u8fd8\u4e0d\u591f\uff0c\u5c31\u62ff1\u5143\uff0c\u8fd9\u6837\u5c31\u662f\u6700\u5c11\u7684\u5f20\u6570\uff0c\u6700\u540e\u6211\u4eec\u7684\u7ed3\u679c\u662f<code>[10,5,1]</code>.</p> <p>\u4f46\u5982\u679c\u5047\u8bbe\u6709\u4e2a\u56fd\u5bb6\u7684\u8d27\u5e01\u662f1\u5143\uff0c3\u5143\uff0c4\u5143\uff0c\u5982\u679c\u8981\u62ff6\u5143\uff0c\u6211\u4eec\u7528\u8d2a\u5fc3\u7b56\u7565\uff0c\u5c31\u662f\u62ff4\u5143\uff0c1\u5143\uff0c1\u5143\uff0c<code>[4,1,1]</code>. \u4f46\u5b9e\u9645\u4e0a\u6700\u5c11\u7684\u5f20\u6570\u662f3\u5143\uff0c3\u5143, <code>[3,3]</code>. \u6240\u4ee5\u8d2a\u5fc3\u7b56\u7565\uff0c\u5c31\u4e0d\u80fd\u7528\u5728\u8fd9\u4e2a\u95ee\u9898\u4e0a.</p>"},{"location":"techniques/greedy/#_1","title":"\u76f8\u5173\u9898\u76ee","text":"<p>\u8d2a\u5fc3\u7b97\u6cd5\u901a\u5e38\u5f88\u5c11\u505a\u5b8c\u5355\u72ec\u7684\u8003\u70b9\uff0c\u901a\u5e38\u548c\u5176\u5b83\u77e5\u8bc6\u70b9\u4e00\u8d77\u8003\u5bdf\uff0c\u8d2a\u5fc3\u7684\u601d\u60f3\u4f5c\u4e3a\u5176\u4e2d\u67d0\u4e00\u6b65\u9aa4\u7684\u7b56\u7565. \u4f46\u4e0d\u6392\u9664\u6709\u4e00\u4e9b\u9898\u76ee\u662f\u7eaf\u7cb9\u7684\u8d2a\u5fc3\u7b97\u6cd5\uff0c\u53ef\u4ee5\u5355\u72ec\u8003\u5bdf.</p> number \u7c7b\u578b \u8d2a\u5fc3\u7b56\u7565 solution 1710 Maximum Units on a Truck sort + greedy or heap + greedy <code>\u7b56\u7565\u662f:\u6c38\u8fdc\u88c5\u7bb1\u5b50\u4e2d\u88c5\u6709units\u6700\u591a\u7684\u7bb1\u5b50</code>\u3002\u8fd9\u9898\u5f88\u68d2\uff0c\u548cdp\u7684\u533a\u522b\u662f\uff0c\u6bcf\u4e2a\u7bb1\u5b50\u5360\u636e\u7684\u4f53\u79ef\u90fd\u4e3a1\uff0c\u800c\u4e0d\u662f\u53d8\u91cf\u3002\u5982\u679c\u662f\u53d8\u91cf\uff0c\u8fd9\u5c31\u662f\u4e00\u9053dp\u7684knapsack\u9898\u76ee. \u7531\u6b64\u53ef\u4ee5\u770b\uff0cgreedy\u662fdp\u7684\u4e00\u4e2a\u7279\u4f8b solution 11 container with most water two pointer(\u53cd\u5411) + greedy <code>\u7b56\u7565: \u6c38\u8fdc\u79fb\u52a8\u6700\u77ed\u7684height</code>, \u56e0\u4e3a\u968f\u7740\u53cd\u5411\u53cc\u6307\u9488\u4e0d\u65ad\u5185\u7f29\uff0cwidth\u4e0d\u65ad\u51cf\u5c0f\uff0c\u4e3a\u4e86maximize volume, \u5fc5\u987b\u4fee\u8865\u6700\u77ed\u7684height, \u4e0d\u8ba9\u5176\u6210\u4e3a\u81ea\u5df1\u7684\u77ed\u677f\u3002 solution 1328 Break a Palindrome \u8d2a\u5fc3 55 Jump Game greedy <code>\u7b56\u7565: \u6c38\u8fdc\u8d70\u6700\u6709\u6f5c\u529b\u7684\u90a3\u4e00\u6b65</code>, \u679a\u4e3e\u5b50\u95ee\u9898\u4e2d\u6240\u6709\u53ef\u4ee5\u8d70\u7684\u6b65\u6570\u4e2d\uff0c\u80fd\u8ba9\u81ea\u5df1reach\u6700\u8fdc\u7684\u8ddd\u79bb. solution 134 Gas Station \u8d2a\u5fc3"},{"location":"techniques/line_sweep/","title":"Line Sweep Algorithm","text":"<p>Line Sweep (\u626b\u63cf\u7ebf)\u662f\u4e00\u79cd\u7b97\u6cd5\u6280\u5de7\uff0c\u96b6\u5c5e\u4e8ecomputational geometry. \u5b83\u7684\u57fa\u672c\u601d\u60f3\u662f\u901a\u8fc7\u626b\u63cf\u7ebf\u7684\u65b9\u5f0f\uff0c\u5728\u4e00\u4e2a\u5750\u6807\u7cfb\u4e2d\u626b\u6765\u626b\u53bb\uff0c\u4ece\u800c\u8ba1\u7b97\u56fe\u5f62\u9762\u79ef\uff0c\u5468\u957f\uff0c\u4e8c\u4f4d\u6570\u70b9\u7b49\u95ee\u9898.</p> <p>\u5728OI\u4e2d\uff0c\u8ba1\u7b97\u51e0\u4f55\u53ef\u4ee5\u5355\u72ec\u62ce\u51fa\u6765\u8bb2\uff0c\u4f46\u8fd9\u91cc\u5c31\u4e0d\u5c55\u5f00\u4e86\u3002\u626b\u63cf\u7ebf\u4f1a\u7ecf\u5e38\u548cintervals\u6253\u4ea4\u9053\u3002\u8fd9\u91cc\u6211\u4eec\u4f1a\u8bb2\u89e3\u4e00\u4e9b\u5e38\u89c1\u7684intervals\u9898\u76ee\uff0c\u7136\u540e\u8bb2\u89e3\u4e00\u4e0b\u626b\u63cf\u7ebf\u7684\u57fa\u672c\u601d\u60f3\u3002</p> <p>lintcode 391\u6570\u98de\u673a</p> <p>\u7ed9\u51fa\u98de\u673a\u7684\u8d77\u98de\u548c\u964d\u843d\u65f6\u95f4\u7684\u5217\u8868\uff0c\u7528\u5e8f\u5217 interval \u8868\u793a. \u8bf7\u8ba1\u7b97\u51fa\u5929\u4e0a\u540c\u65f6\u6700\u591a\u6709\u591a\u5c11\u67b6\u98de\u673a\uff1f</p> <p>Warning</p> <p>\u5982\u679c\u591a\u67b6\u98de\u673a\u964d\u843d\u548c\u8d77\u98de\u5728\u540c\u4e00\u65f6\u523b\uff0c\u6211\u4eec\u8ba4\u4e3a\u964d\u843d\u6709\u4f18\u5148\u6743\u3002</p> <p>Example 1: <pre><code>\u8f93\u5165: [(1, 10), (2, 3), (5, 8), (4, 7)]\n\u8f93\u51fa: 3\n\u89e3\u91ca: \n\u7b2c\u4e00\u67b6\u98de\u673a\u57281\u65f6\u523b\u8d77\u98de, 10\u65f6\u523b\u964d\u843d.\n\u7b2c\u4e8c\u67b6\u98de\u673a\u57282\u65f6\u523b\u8d77\u98de, 3\u65f6\u523b\u964d\u843d.\n\u7b2c\u4e09\u67b6\u98de\u673a\u57285\u65f6\u523b\u8d77\u98de, 8\u65f6\u523b\u964d\u843d.\n\u7b2c\u56db\u67b6\u98de\u673a\u57284\u65f6\u523b\u8d77\u98de, 7\u65f6\u523b\u964d\u843d.\n\u57285\u65f6\u523b\u52306\u65f6\u523b\u4e4b\u95f4, \u5929\u7a7a\u4e2d\u6709\u4e09\u67b6\u98de\u673a.\n</code></pre> Example 2: <pre><code>\u8f93\u5165: [(1, 2), (2, 3), (3, 4)]\n\u8f93\u51fa: 1\n\u89e3\u91ca: \u964d\u843d\u4f18\u5148\u4e8e\u8d77\u98de. \n</code></pre></p> <p>\u6570\u98de\u673a\u8fd9\u4e2a\u9898\u76ee\u5c31\u662f\u4e00\u4e2a\u5178\u578b\u7684\u626b\u63cf\u7ebf\u7b97\u6cd5\u7684\u9898\u76ee\u3002\u6211\u4eec\u53ef\u4ee5\u628a\u98de\u673a\u7684\u8d77\u98de\u548c\u964d\u843d\u65f6\u95f4\u770b\u6210\u662f\u4e00\u4e2ainterval\uff0c\u7136\u540e\u6211\u4eec\u53ef\u4ee5\u628a\u8fd9\u4e9binterval\u7684\u6240\u6709\u8d77\u98de\u548c\u964d\u843d\u7684\u65f6\u95f4\u70b9\u6309\u7167\u65f6\u95f4\u6392\u5e8f\u3002\u53ea\u6709\u8fd9\u4e9b\u65f6\u95f4\u70b9\u5bf9\u7a7a\u4e2d\u98de\u673a\u6570\u91cf\u6709\u5f71\u54cd\u3002 \u626b\u63cf\u7ebf\u7684\u6982\u5ff5\u5c31\u662f\u4ece\u5de6\u5230\u53f3\u626b\u63cf\uff0c\u540c\u65f6\u8bb0\u5f55\u4e0b\u6765\u5f53\u524d\u65f6\u95f4\u70b9\u7684\u98de\u673a\u6570\u91cf\u3002\u8fd9\u6837\u6211\u4eec\u5c31\u53ef\u4ee5\u5f97\u5230\u5929\u4e0a\u540c\u65f6\u6700\u591a\u6709\u591a\u5c11\u67b6\u98de\u673a\u4e86\u3002</p> <p></p>"},{"location":"techniques/line_sweep/#interval","title":"Interval\u6280\u5de7","text":""},{"location":"techniques/line_sweep/#_1","title":"\u5224\u65ad\u662f\u5426\u76f8\u4ea4","text":"<p>A = [a1, a2], B = [b1, b2], we can have the intersection of A and B as <code>[max(a1, b1), min(a2, b2)].</code></p> \\[ y(A, B) = \\begin{cases}  \\text{overlap}\\quad\\max(A[0], B[0]) \\leq \\min(A[1], B[1]) \\\\  \\text{cover}\\quad \\max(A[0], B[0]) = \\min(A[1], B[1])\\\\  \\text{non-overlap}\\quad \\max(A[0], B[0]) &gt; \\min(A[1], B[1])\\\\ \\end{cases} \\] <p>\u5176\u4e2dcover\u662foverlap\u7684\u7279\u4f8b, \u8fd9\u662finterval\u4e2d\u975e\u5e38\u5e38\u7528\u7684\u4e00\u4e2a\u6280\u5de7.</p> <pre><code>def isIntersect(A, B):\n    return max(A[0], B[0]) &lt;= min(A[1], B[1])\n</code></pre>"},{"location":"techniques/line_sweep/#_2","title":"\u76f8\u5173\u9898\u76ee","text":"<p>line sweep\u7684\u9898\u76ee\u5f80\u5f80\u90fd\u662f\u548cintervals\u6253\u4ea4\u9053\u7684, \u540c\u65f6\u4e00\u9898\u591a\u89e3with heap or two pointers\u4e5f\u5f88\u5e38\u89c1.</p> <ul> <li>252 Meeting Rooms</li> <li>253 Meeting Rooms II</li> <li>intervals \u4e09\u5144\u5f1f<ul> <li>LC 56 Merge Intervals</li> <li>LC 57 Insert Interval</li> <li>LC 1272 Remove Interval</li> </ul> </li> <li>cover? non-overlap?\u50bb\u50bb\u5206\u4e0d\u6e05\u695a<ul> <li>435 Non-overlapping Intervals</li> <li>1288 Remove Covered Intervals</li> </ul> </li> <li>1229 Meeting Scheduler</li> <li>986 Interval List Intersections<ul> <li>line sweep\u53ef\u4ee5\u505a</li> </ul> </li> <li>352 Data Stream as Disjoint Intervals</li> <li>759 Employee Free Time</li> <li>218 The Skyline Problem</li> </ul>"},{"location":"techniques/line_sweep/#reference","title":"Reference","text":"<ul> <li>\u53e4\u57ce,\u57fa\u7840\u7b97\u6cd5\u4e00,\u626b\u63cf\u7ebf</li> <li>leetcode post by c0D3M, \u4e00\u540dC++\u9009\u624b</li> <li>OI wiki</li> </ul>"},{"location":"techniques/prefix_sum/","title":"Prefix Sum (\u524d\u7f00\u548c)","text":"<p>\u524d\u7f00\u548c\u7b97\u662f\u4e00\u79cd\u7b97\u6cd5\u9898\u4e2d\u7684\u6280\u5de7\uff0c\u64c5\u957f\u7528\u4e8e\u89e3\u51b3\u6574\u6570\u6570\u7ec4\uff0c\u4e14\u51fa\u73b0<code>subarray sum</code>\u6216\u8005<code>contiguous subarray</code>\u65f6\u53ef\u4ee5\u5c1d\u8bd5\u4f7f\u7528\u3002\u524d\u7f00\u548c\u7684\u601d\u60f3\u662f\u5c06\u6570\u7ec4\u7684\u524d\u7f00\u548c\u5b58\u50a8\u5728\u4e00\u4e2aauxillary data structure\u4e2d\uff0c\u7136\u540e\u901a\u8fc7\u8ba1\u7b97\u4e24\u4e2a\u524d\u7f00\u548c\u7684\u5dee\u503c\u6765\u5f97\u5230\u4e00\u4e2a\u4efb\u610fsubarray\u7684\u548c\u3002 \u901a\u5e38auxillary data structure\u53ef\u80fd\u662f</p> <ul> <li>\u4e00\u4e2ahashmap\uff0c\u7528\u4e8e\u5b58\u50a8\u524d\u7f00\u548c\u7684\u503cas key, \u51fa\u73b0\u7684\u6b21\u6570\uff0c\u6216\u8005index\u4f5c\u4e3avalue.</li> <li>\u4e00\u4e2aarray</li> </ul> <p>Prefix Sum\u4f5c\u4e3a\u6280\u5de7\uff0c\u53ef\u4ee5\u548c\u5176\u5b83\u7b97\u6cd5\u548c\u6570\u636e\u7ed3\u6784\u878d\u5408\u3002\u5177\u4f53\u7684\u51e0\u4e2a\u9ad8\u9891\u5927\u7c7b,</p> <ul> <li><code>2 sum\u7cfb\u5217</code><ul> <li>2 sum, 3 sum, 4 sum </li> <li>\u5176\u5b9econtiguous subarray sum\u4e5f\u662f\u4e00\u79cd2 sum</li> </ul> </li> <li><code>range sum</code></li> <li><code>sliding window</code><ul> <li>\u53ea\u80fd\u89e3\u51b3\u5168\u6b63\u6570\u7684array, \u6bd4\u5982best time to buy and sell stock. \u56e0\u4e3asliding window\u7684\u524d\u63d0\u662fleft pointer move right, subarray sum\u51cf\u5c11\uff0cright pointer move right, subarray sum\u589e\u52a0. \u4f46\u6709\u8d1f\u6570\u7684\u60c5\u51b5\u65e0\u6cd5\u4fdd\u8bc1\u8fd9\u4e00\u70b9.</li> </ul> </li> <li><code>monotonic queue</code><ul> <li>\u4f5c\u4e3a\u5176follow-up</li> </ul> </li> </ul>"},{"location":"techniques/prefix_sum/#_1","title":"\u76f8\u5173\u9898\u76ee","text":""},{"location":"techniques/prefix_sum/#two-sum","title":"Two Sum\u7cfb\u5217","text":"<p>2 sum, 3 sum, ..., n sum. \u8fd9\u4e2a\u6982\u5ff5\u5b9e\u9645\u662fprefix sum\u7684\u4e00\u4e2a\u7279\u4f8b\u3002prefix sum\u6c42\u7684\u662fsubarray sum, \u4e5f\u662f\u5229\u7528\u4e862 sum\u4e2d\u7684\u662f<code>\u4e24\u6570\u4e4b\u5dee\u7b26\u5408target</code>.</p> <p>\u6bd4\u8f83\u7ecf\u5178\u7684\u9898\u76ee\u6709</p> <ul> <li>1 two sum</li> <li>560 subarray sum equals k (\u5b8c\u5168\u5229\u7528\u4e86two sum\u7684\u601d\u60f3)</li> <li>974 subarray sums divisible by k (\u8f6c\u5316\u4e3a560\u7684\u6761\u4ef6)</li> <li>523 continuous subarray sum (\u548c974\u5b8c\u5168\u4e00\u6837, \u7528\u4e86\u4e2a\u5c0ftrick)</li> <li>525 contiguous array (binary array of <code>[0,1]</code> \u8f6c\u5316\u4e3a <code>[-1,1]</code> \u7684array, \u7528\u4e86\u4e2a\u5c0ftrick. \u5176\u5b9e\u4e5f\u50cfmajority elements\u91cc\u7684\u6295\u7968\u7b97\u6cd5\uff0c\u5982\u679c\u9047\u5230majority element + 1, else -1. \u7528\u4e00\u4e2acounter\u6765\u8bb0\u5f55)</li> </ul> <p>Tip</p> <p>subarray\u7684\u9898\u76ee\uff0c\u7b2c\u4e00\u53cd\u5e94\u662fprefix sum. But if it's subsequence, \u9996\u5148\u9700\u8981\u60f3\u5230\u5230DP. longest increasing subsequence(LIS)\u6bd4\u5982.</p>"},{"location":"techniques/prefix_sum/#range-sum","title":"Range Sum\u7cfb\u5217","text":"<p>Range Sum\u5229\u7528\u4e86\u524d\u7f00\u548c\u7684\u4e00\u4e9b\u6027\u8d28, lazy propagation\u7684\u601d\u7ef4\u5728range update\u5f88\u6709\u7528.</p> <ul> <li>370 range addition (\u5229\u7528\u4e86lazy propagation)</li> <li>304 range sum query 2D - immutable (2D\u7684\u524d\u7f00\u548c, pre-processing\u6280\u5de7\u5f88\u50cfdp in 2D)</li> </ul>"},{"location":"techniques/prefix_sum/#sliding-window","title":"Sliding Window\u7cfb\u5217","text":"<p>\u8fd9\u4e00\u90e8\u5206\u5c31\u8bb2\u4e86\u4e00\u9898.</p> <ul> <li>209 minimum size subarray sum</li> </ul>"},{"location":"techniques/prefix_sum/#monotonic-queue","title":"Monotonic Queue\u7cfb\u5217","text":"<p>\u8fd9\u4e00\u90e8\u5206\u4e5f\u662f, \u7b97\u662f209\u7684follow up\u4e86. \u6709\u96be\u5ea6\u7684\uff0c\u5f97\u60f3\u660e\u767d\u4e3a\u4ec0\u4e48\u8981\u7528\u5355\u8c03\u9012\u589e\u961f\u5217\u548c\u51ed\u4ec0\u4e48\u53ef\u4ee5\u5de6\u51fa.</p> <ul> <li>862 Shortest Subarray with Sum at Least K</li> </ul>"},{"location":"techniques/prefix_sum/#others","title":"Others","text":"number \u7c7b\u578b description solution 560 Subarray Sum Equals K subarray sum equals k. \u4e07\u7269\u4e4b\u6e90 solution 325 Maximum Size Subarray Sum Equals k subarray sum equals k, \u4f46\u662f\u8981\u6c42\u6700\u5927\u7684subarray solution 974 Subarray Sums Divisible by K - \u8f6c\u6362divisible by k\u7684\u6761\u4ef6\u4e3asubarray sum equals k solution 525 Contiguous Array trick, binary array of [0,1]\u8f6c\u5316\u4e3a[-1,1] solution 523 Continuous Subarray Sum similar to 974 but with a length constrains solution 370 Range Addition solution 304 Range Sum Query 2D - Immutable solution 209 Minimum Size Subarray Sum sliding window solution"},{"location":"techniques/sliding_window/","title":"Sliding Window","text":"<p>Sliding window\u4e5f\u662f\u4e00\u79cd\u6280\u5de7\uff0c\u662ftwo pointer\u7684\u4e00\u7c7b\uff0c\u4f46\u7531\u4e8e\u592a\u5e38\u89c1\u4e86\uff0c\u9010\u6e10\u81ea\u6210\u4e00\u8109\u3002Sliding window\u7684\u6838\u5fc3\u601d\u60f3\u662f\u7ef4\u62a4\u4e00\u4e2a\u7a97\u53e3 with pointer left and right\u5728both ends of the window. \u8fd9\u4e2a\u7a97\u53e3\u53ef\u4ee5\u662f\u56fa\u5b9a\u5927\u5c0f\uff0c\u4e5f\u53ef\u4ee5\u662f\u53ef\u53d8\u5927\u5c0f\u3002\u901a\u5e38\u4f1a\u7ef4\u62a4\u4e00\u4e9b\u5173\u4e8e\u7a97\u53e3\u5185\u7684\u4e1c\u897f\u7684\u4fe1\u606f, \u6bd4\u5982</p> <ul> <li>\u7a97\u53e3\u5185\u7684\u4fe1\u606f<ul> <li>rolling sum\u5c0f\u4e8ek</li> <li>max element\u51fa\u73b0\u7684\u6b21\u6570 &lt; k</li> </ul> </li> <li>\u7a97\u53e3\u4e0a\u7684\u4fe1\u606f</li> </ul> <p>Sliding window\u5e38\u7528\u4e8e\u89e3\u51b3subsequence. subsequence\u5305\u62ecsubarray\u6216\u8005substring\u95ee\u9898.</p> <ul> <li>\u5bf9\u4e8esubarray\u7684rolling sum, sliding window\u53ea\u80fd\u7528\u4e8e\u89e3\u51b3positive array, \u56e0\u4e3a\u5f97\u4fdd\u8bc1move left pointer\u4f1a\u51cf\u5c11\uff0cmove right pointer\u4f1a\u589e\u52a0.</li> <li>\u5bf9\u4e8esubstring, </li> </ul>"},{"location":"techniques/sliding_window/#_1","title":"\u76f8\u5173\u95ee\u9898","text":"<p>\u53e4\u57ce\u7b97\u6cd5\u63d0\u4f9b\u7684\u6e05\u5355\uff0c\u90fd\u662f1000\u4ee5\u5185\u7684sliding window\u7ecf\u5178.</p> number \u7c7b\u578b \u9898\u578b description solution 3 Longest Substring Without Repeating Characters <code>substring</code> sliding window \u7ef4\u62a4\u4e00\u4e2aset, \u7528\u4e8e\u5b58\u50a8\u7a97\u53e3\u5185\u7684\u4fe1\u606f solution 159 Longest Substring with At Most Two Distinct Characters <code>substring</code> sliding window \u7ef4\u62a4\u4e00\u4e2afreq map, \u7528\u4e8emonitor\u73b0\u5728\u7684counter solution 340 Longest Substring with At Most K Distinct Characters <code>substring</code> sliding window \u6839\u636e\u6761\u4ef6move left pointer, \u7ef4\u62a4\u4e00\u4e2afreq map. \u6ce8\u610f\u5f53freq = 0\u65f6\u9700\u8981\u79fb\u9664key solution 395 Longest Substring with At Least K Repeating Characters <code>substring</code> slidng window \u6709\u70b9\u96be\u7684\uff0c\u5c0f\u4e1c\u897f!! solution 209 Minimum Size Subarray Sum <code>subarray</code> sliding window \u7ef4\u62a4\u4e00\u4e2asum, \u5f53sum &gt;= target\u65f6, move left pointer, \u66f4\u65b0min length solution 76 Minimum Window Substring <code>substring</code> sliding window \u7ef4\u62a4\u4e00\u4e2afreq map, \u7528\u4e8e\u5b58\u50a8\u7a97\u53e3\u5185\u7684\u4fe1\u606f solution 992 Subarrays with K Different Integers <code>subarray</code> sliding window \u7ef4\u62a4\u4e00\u4e2afreq map, \u7528\u4e8e\u5b58\u50a8\u7a97\u53e3\u5185\u7684\u4fe1\u606f solution 1248 Count Number of Nice Subarrays <code>subarray</code> sliding window \u7ef4\u62a4\u4e00\u4e2afreq map, \u7528\u4e8e\u5b58\u50a8\u7a97\u53e3\u5185\u7684\u4fe1\u606f solution"},{"location":"techniques/sliding_window/#lees-list","title":"Lee's List","text":"<p>\u8fd9\u4e2alist is provided by lee215, \u7b97\u662f\u6bd4\u8f83\u65b0\u7684\u9898.</p> number \u7c7b\u578b description description solution 2958 Length of Longest Subarray With at Most K Frequency <code>subarray</code> \u7b26\u5408\u6761\u4ef6\u7684\u6700\u957f \u7ef4\u62a4hashmap for frequency, \u904d\u5386\u6240\u6709right pointer, \u5f53\u6761\u4ef6\u4e0d\u6ee1\u8db3\u65f6, move left pointer solution 2831 Find the longest equal subarray nope 2799 Count Complete Subarrays in an Array <code>subarray</code> \u7b26\u5408\u6761\u4ef6\u7684\u4e2a\u6570 \u7ef4\u62a4\u4e00\u4e2ahashmap solution 2730 Find the Longest Semi-Repetitive Substring <code>substring</code> \u7b26\u5408\u6761\u4ef6\u7684\u6700\u957f \u7ef4\u62a4\u4e00\u4e2a<code>int</code>, \u8bb0\u5f55pairs\u6b21\u6570. \u4e00\u65e6pairs == 2, \u79fb\u52a8\u5de6\u6307\u9488\u76f4\u81f3pairs == 1 solution 2555 Maximize Win From Two Segments 2537 Count the number of good subarrays 2401 Longest Nice Subarray 2398 Maximum Number of Robots Within Budget 2024 Maximize the confusion of an exam 1838 Frequency of the most frequent element 1493 longest subarray of 1's after deleting one element 1425 Constrained subsequence sum 1358 Number of Substrings Containing All Three Characters 1248 Count Number of Nice Subarrays 1234 Replace the Substring for Balanced String 1004 Max Consecutive Ones III 930 Binary Subarrays With Sum 992 Subarrays with K different integers 904 Fruit into baskets 862 Shortest subarray with sum at least K 424 Longest repeating character replacement 209 Minimum size subarray sum"},{"location":"techniques/two_pointers/","title":"Two Pointers","text":"<p>\u53cc\u6307\u9488\u662f\u4e00\u79cd\u7075\u6d3b\u7684\u601d\u60f3\u548c\u6280\u5de7\uff0c\u53ef\u4ee5\u5355\u72ec\u4f7f\u7528\u4e5f\u53ef\u4ee5\u548c\u5176\u4ed6\u7b97\u6cd5\u4e00\u8d77\u7ed3\u5408\u4f7f\u7528\u3002\u53cc\u6307\u9488\u540c\u65f6\u4f7f\u7528\u4e24\u4e2a\u6307\u9488\uff0c\u5728\u4e0d\u540c\u6570\u636e\u7ed3\u6784\u4e0a(\u6570\u7ec4\uff0c\u94fe\u8868\uff0c\u6811\uff0c\u56fe)\u4e2d\u8f97\u8f6c\u817e\u632a\uff0c\u540c\u5411\u79fb\u52a8\uff0c\u53cd\u5411\u79fb\u52a8\uff0c\u5feb\u6162\u901f\u7b49\u7b49\u6765maintain\u6211\u4eec\u7684\u72b6\u6001\u548c\u4fe1\u606f.</p> <p>\u5e38\u89c1\u7684\u5206\u6210\u4e24\u7c7b:</p> <ul> <li>\u540c\u5411\u6307\u9488(\u4e24\u4e2a\u6307\u9488\u6b65\u957f\u4e0d\u540c), line sweep, sliding window, Floyd's Cycle Detection (\u5feb\u6162\u6307\u9488), \u5355\u8c03\u961f\u5217\uff0c\u5355\u8c03\u6808<ul> <li>\u5feb\u6162\u6307\u9488: <ul> <li>\u627e\u4e2d\u70b9\uff0c</li> <li>\u5224\u65ad\u662f\u5426\u6709\u73af Floyd's Cycle Detection</li> </ul> </li> <li>sliding window:<ul> <li>\u53cc\u6307\u9488\u540c\u65f6scan, \u4e00\u4e2a\u6307\u9488\u7528\u4e8e\u6269\u5c55\u7a97\u53e3\uff0c\u4e00\u4e2a\u6307\u9488\u7528\u4e8e\u6536\u7f29\u7a97\u53e3. \u6269\u5c55\u6536\u7f29\u7684\u6761\u4ef6\u53d6\u51b3\u4e8e\u9898\u76ee\u7684\u9700\u6c42\uff0c\u5e38\u89c1\u7ef4\u62a4\u7684\u4fe1\u606f\u6709:<ul> <li>\u4e00\u4e2a\u7a97\u53e3\u5185\u7684\u4fe1\u606f, like rolling sum</li> <li>\u6307\u9488\u4e0a\u7684\u4fe1\u606f\uff0c\u5982\u8bb0\u5f55\u6700\u5927\u503c\uff0c\u6700\u5c0f\u503c</li> </ul> </li> <li>\u7528\u4e8e\u89e3\u51b3subsequence(subarray\u6216\u8005substring\u95ee\u9898). \u5bf9\u4e8esubarray, \u53ea\u80fd\u7528\u4e8e\u89e3\u51b3positive array, \u56e0\u4e3a\u5f97\u4fdd\u8bc1move left pointer\u4f1a\u51cf\u5c11\uff0cmove right pointer\u4f1a\u589e\u52a0.</li> </ul> </li> <li>on sorted array: <ul> <li>\u5982\u679c\u7ed9\u5b9a\u7684\u6761\u4ef6\u662f\u4e24\u4e2asorted array, \u4f60\u53ef\u4ee5\u7528\u53cc\u6307\u9488\u5728\u4e24\u4e2a\u6570\u7ec4\u4e0a\u540c\u65f6\u79fb\u52a8\uff0c\u6bd4\u5982merge two sorted array, find common elements in two sorted array\u7b49\u7b49.</li> </ul> </li> </ul> </li> <li>\u53cd\u5411\u6307\u9488(\u4e24\u4e2a\u6307\u9488\u4ece\u4e24\u7aef\u5411\u4e2d\u95f4\u79fb\u52a8), \u6bd4\u5982binary search.<ul> <li>binary search: \u7528\u4e8e\u5728\u6709\u5e8f\u6570\u7ec4\u4e2d\u67e5\u627e\u5143\u7d20\uff0c\u65f6\u95f4\u590d\u6742\u5ea6\u4e3aO(logn). \u4e24\u6307\u9488\u5728\u4e24\u7aef\uff0c\u5f80\u4e2d\u95f4\u79fb\u52a8\u3002</li> </ul> </li> </ul>"},{"location":"techniques/two_pointers/#_1","title":"\u76f8\u5173\u95ee\u9898","text":"number \u7c7b\u578b description solution 680 valid palindrome II \u53cd\u5411\u6307\u9488 - solution 408 valid word abbreviation \u540c\u5411\u53cc\u6307\u9488on two array \u6ce8\u610f\u5224\u5b9aleading zero and how to handle digits solution 253 meeting rooms II \u53cc\u6307\u9488 - solution 1570 Dot Product of Two Sparse Vectors \u540c\u5411\u53cc\u6307\u9488, on two sorted array \u5229\u7528list of tuple <code>(index,value)</code>\u50a8\u5b58non-zero elements, \u7136\u540e\u53cc\u6307\u9488on two sorted array,\u8fdb\u884cdot product\u8ba1\u7b97\u3002\u597d\u9898! solution 42 Trapping Rain Water \u53cc\u6307\u9488 - solution 141 linked list cycle \u53cc\u6307\u9488, \u5feb\u6162\u6307\u9488 - solution 142 linked list cycle II \u53cc\u6307\u9488, \u5feb\u6162\u6307\u9488 - solution 340 Longest Substring with At Most K Distinct Characters \u540c\u5411\u6307\u9488, sliding window \u6839\u636e\u6761\u4ef6move left pointer, \u7ef4\u62a4\u4e00\u4e2afreq map. \u6ce8\u610f\u5f53freq = 0\u65f6\u9700\u8981\u79fb\u9664key solution 15 3sum \u53cc\u6307\u9488, sliding window - solution 704 Binary Search \u53cc\u6307\u9488, binary search - solution 887 Super Egg Drop \u53cc\u6307\u9488, - solution"},{"location":"techniques/two_pointers/#reference","title":"Reference","text":"<ul> <li>\u53e4\u57ce\u7b97\u6cd5\u57fa\u7840\u5341\u4e00, \u53cc\u6307\u9488(\u4e0a) and \u53cc\u6307\u9488(\u4e0b)</li> </ul>"}]}